# =============================================================================
# TypeScript ベンチマーク問題集
# カテゴリ: 型安全, 非同期処理, API設計, OOP, ジェネリクス, etc.
# 各問題に複数テストケースを含み、部分点評価が可能
#
# 難易度レベル (エージェント問題):
#   Level 1 (★☆☆☆) - Easy:    基本的な設計判断、少しだけ曖昧な要件
#   Level 2 (★★☆☆) - Medium:  中程度の曖昧さ、複数の設計判断が必要
#   Level 3 (★★★☆) - Hard:    複雑な設計判断、複数の技術領域にまたがる
#   Level 4 (★★★★) - Expert:  実務レベルの複雑な問題、多くの考慮事項
# =============================================================================

# -----------------------------------------------------------------------------
# カテゴリ: 型安全 / Type Safety
# -----------------------------------------------------------------------------

- id: ts_typesafety
  lang: typescript
  prompt: |
    TypeScriptで型安全にリファクタしてください。解説不要、コードのみ。

    エクスポート:
    - export type User = { name: string; age: number }
    - export function processUser(user: User): { upperName: string; agePlus10: number }

    要件:
    - any を使わない
    - user.name を大文字化して upperName に
    - user.age + 10 を agePlus10 に

    元コード:
    function processUser(user: any) {
        console.log(user.name.toUpperCase());
        return user.age + 10;
    }
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import * as solution from "../solution";
      import { pickFn } from "./_flex";
      
      const processUser = pickFn(solution as any, ["processUser"]);
      // `export type User` は実行時には存在しない（型は消える）ので、テスト側では明示型を使う
      type User = { name: string; age: number };

      describe("processUser", () => {
        it("returns upperName", () => {
          expect(processUser).toBeTypeOf("function");
          const u: User = { name: "alice", age: 20 };
          const r = (processUser as any)(u);
          expect(r.upperName).toBe("ALICE");
        });

        it("returns agePlus10", () => {
          const u: User = { name: "bob", age: 25 };
          const r = (processUser as any)(u);
          expect(r.agePlus10).toBe(35);
        });

        it("handles mixed case", () => {
          const u: User = { name: "ChArLiE", age: 30 };
          const r = (processUser as any)(u);
          expect(r.upperName).toBe("CHARLIE");
        });

        it("handles zero age", () => {
          const u: User = { name: "dave", age: 0 };
          const r = (processUser as any)(u);
          expect(r.agePlus10).toBe(10);
        });
      });


- id: ts_type_guard
  lang: typescript
  prompt: |
    TypeScriptで型ガード関数を実装してください。解説不要、コードのみ。

    仕様:
    - isString(value: unknown): value is string
    - isNumber(value: unknown): value is number
    - isUser(value: unknown): value is User （User = { name: string, email: string }）
    - すべてexportする
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import * as solution from "../solution";
      import { pickFn } from "./_flex";

      const isString = pickFn(solution as any, ["isString", "is_string"]);
      const isNumber = pickFn(solution as any, ["isNumber", "is_number"]);
      const isUser = pickFn(solution as any, ["isUser", "is_user"]);

      describe("isString", () => {
        it("returns true for string", () => {
          expect((isString as any)("hello")).toBe(true);
        });
        it("returns false for number", () => {
          expect((isString as any)(123)).toBe(false);
        });
        it("returns false for null", () => {
          expect((isString as any)(null)).toBe(false);
        });
      });

      describe("isNumber", () => {
        it("returns true for number", () => {
          expect((isNumber as any)(42)).toBe(true);
        });
        it("returns false for string", () => {
          expect((isNumber as any)("42")).toBe(false);
        });
        it("returns true for zero", () => {
          expect((isNumber as any)(0)).toBe(true);
        });
      });

      describe("isUser", () => {
        it("returns true for valid user", () => {
          expect((isUser as any)({ name: "Alice", email: "alice@example.com" })).toBe(true);
        });
        it("returns false for missing email", () => {
          expect((isUser as any)({ name: "Bob" })).toBe(false);
        });
        it("returns false for null", () => {
          expect((isUser as any)(null)).toBe(false);
        });
        it("returns false for wrong types", () => {
          expect((isUser as any)({ name: 123, email: "test@test.com" })).toBe(false);
        });
      });


- id: ts_generic_function
  lang: typescript
  prompt: |
    ジェネリック関数を実装してください。解説不要、コードのみ。

    仕様:
    - first<T>(arr: T[]): T | undefined - 配列の最初の要素を返す
    - last<T>(arr: T[]): T | undefined - 配列の最後の要素を返す
    - unique<T>(arr: T[]): T[] - 重複を除去した配列を返す
    - groupBy<T, K extends string | number>(arr: T[], keyFn: (item: T) => K): Record<K, T[]>
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import * as solution from "../solution";
      import { pickFn } from "./_flex";

      const first = pickFn(solution as any, ["first", "head"], (fn) => fn([1,2,3]) === 1);
      const last = pickFn(solution as any, ["last", "tail"], (fn) => fn([1,2,3]) === 3);
      const unique = pickFn(solution as any, ["unique", "dedupe", "uniq"], (fn) => {
        const r = fn([1,2,2,3]);
        return Array.isArray(r) && r.length === 3;
      });
      const groupBy = pickFn(solution as any, ["groupBy", "group_by"], (fn) => {
        const r = fn([{ t: "x" }, { t: "y" }], (i: any) => i.t);
        return r && typeof r === "object" && r.x && r.y;
      });

      describe("first", () => {
        it("returns first element", () => {
          expect((first as any)([1, 2, 3])).toBe(1);
        });
        it("returns undefined for empty", () => {
          expect((first as any)([])).toBeUndefined();
        });
      });

      describe("last", () => {
        it("returns last element", () => {
          expect((last as any)([1, 2, 3])).toBe(3);
        });
        it("returns undefined for empty", () => {
          expect((last as any)([])).toBeUndefined();
        });
      });

      describe("unique", () => {
        it("removes duplicates", () => {
          expect((unique as any)([1, 2, 2, 3, 3, 3])).toEqual([1, 2, 3]);
        });
        it("handles strings", () => {
          expect((unique as any)(["a", "b", "a"])).toEqual(["a", "b"]);
        });
        it("handles empty", () => {
          expect((unique as any)([])).toEqual([]);
        });
      });

      describe("groupBy", () => {
        it("groups by key", () => {
          const items = [
            { name: "a", type: "x" },
            { name: "b", type: "y" },
            { name: "c", type: "x" },
          ];
          const result = (groupBy as any)(items, (i: any) => i.type);
          expect(result["x"].length).toBe(2);
          expect(result["y"].length).toBe(1);
        });
      });


# -----------------------------------------------------------------------------
# カテゴリ: 非同期処理 / Async
# -----------------------------------------------------------------------------

- id: ts_async_wait
  lang: typescript
  prompt: |
    TypeScriptで次の関数を修正してください（解説不要、コードのみ）。
    バグ: forEach内のawaitが効かず、処理完了前にDone相当が発生します。

    エクスポート:
    - export async function saveAll(items: string[], save: (item: string) => Promise<void>): Promise<void>

    要件:
    - items 配列の各要素に対して save 関数を呼び出す
    - 全件の save が完了してから resolve する
    - forEach は使わない（for...of または Promise.all を使用）

    参考(バグコード):
    async function saveAll(items: string[], save: (item: string) => Promise<void>) {
        items.forEach(async (item) => {
            await save(item);
        });
    }
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import * as solution from "../solution";
      import { pickFn } from "./_flex";

      const saveAll = pickFn(solution as any, ["saveAll", "save_all"]);

      const sleep = (ms: number) => new Promise((r) => setTimeout(r, ms));

      describe("saveAll", () => {
        it("waits for all saves", async () => {
          const calls: string[] = [];
          const save = async (item: string) => {
            await sleep(20);
            calls.push(item);
          };
          await (saveAll as any)(["a", "b", "c"], save);
          expect(calls.sort()).toEqual(["a", "b", "c"]);
        });

        it("executes in reasonable time", async () => {
          const save = async (item: string) => { await sleep(10); };
          const t0 = Date.now();
          await (saveAll as any)(["a", "b"], save);
          const dt = Date.now() - t0;
          expect(dt).toBeGreaterThanOrEqual(10);
        });

        it("handles empty array", async () => {
          const calls: string[] = [];
          const save = async (item: string) => { calls.push(item); };
          await (saveAll as any)([], save);
          expect(calls).toEqual([]);
        });
      });


- id: ts_promise_retry
  lang: typescript
  prompt: |
    リトライ機能付きの関数を実装してください。解説不要、コードのみ。

    仕様:
    - retry<T>(fn: () => Promise<T>, maxAttempts: number): Promise<T>
    - 失敗したらmaxAttempts回まで再試行
    - 全て失敗したら最後のエラーをthrow
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import * as solution from "../solution";
      import { pickFn } from "./_flex";

      const retry = pickFn(solution as any, ["retry", "withRetry", "with_retry"]);

      describe("retry", () => {
        it("returns on first success", async () => {
          const result = await (retry as any)(() => Promise.resolve("ok"), 3);
          expect(result).toBe("ok");
        });

        it("retries on failure", async () => {
          let attempts = 0;
          const fn = () => {
            attempts++;
            if (attempts < 3) return Promise.reject(new Error("fail"));
            return Promise.resolve("success");
          };
          const result = await (retry as any)(fn, 3);
          expect(result).toBe("success");
          expect(attempts).toBe(3);
        });

        it("throws after max attempts", async () => {
          const fn = () => Promise.reject(new Error("always fails"));
          await expect((retry as any)(fn, 2)).rejects.toThrow("always fails");
        });

        it("passes with single attempt allowed", async () => {
          const result = await (retry as any)(() => Promise.resolve(42), 1);
          expect(result).toBe(42);
        });
      });


- id: ts_promise_all_settled
  lang: typescript
  prompt: |
    Promise.allSettledのようなユーティリティを実装してください。解説不要、コードのみ。

    仕様:
    - settleAll<T>(promises: Promise<T>[]): Promise<SettledResult<T>[]>
    - SettledResult<T> = { status: "fulfilled", value: T } | { status: "rejected", reason: any }
    - すべてのPromiseが完了するまで待つ（失敗しても他を待つ）
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import * as solution from "../solution";
      import { pickFn } from "./_flex";

      const settleAll = pickFn(solution as any, ["settleAll", "allSettled", "all_settled"]);
      type SettledResult<T> = any;

      describe("settleAll", () => {
        it("handles all fulfilled", async () => {
          const results = await (settleAll as any)([
            Promise.resolve(1),
            Promise.resolve(2),
          ]);
          expect(results[0]).toEqual({ status: "fulfilled", value: 1 });
          expect(results[1]).toEqual({ status: "fulfilled", value: 2 });
        });

        it("handles all rejected", async () => {
          const results = await (settleAll as any)([
            Promise.reject(new Error("e1")),
            Promise.reject(new Error("e2")),
          ]);
          expect(results[0].status).toBe("rejected");
          expect(results[1].status).toBe("rejected");
        });

        it("handles mixed", async () => {
          const results = await (settleAll as any)([
            Promise.resolve("ok"),
            Promise.reject(new Error("fail")),
          ]);
          expect(results[0]).toEqual({ status: "fulfilled", value: "ok" });
          expect(results[1].status).toBe("rejected");
        });

        it("handles empty array", async () => {
          const results = await (settleAll as any)([]);
          expect(results).toEqual([]);
        });
      });


# -----------------------------------------------------------------------------
# カテゴリ: データ処理 / Data Processing
# -----------------------------------------------------------------------------

- id: ts_array_utils
  lang: typescript
  prompt: |
    配列ユーティリティ関数を実装してください。解説不要、コードのみ。

    仕様:
    - chunk<T>(arr: T[], size: number): T[][] - 配列をsize個ずつに分割
    - flatten<T>(arr: (T | T[])[]): T[] - 1レベルのネストを平坦化
    - zip<T, U>(arr1: T[], arr2: U[]): [T, U][] - 2つの配列をペアにする
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import * as solution from "../solution";
      import { pickFn } from "./_flex";

      const chunk = pickFn(solution as any, ["chunk"], (fn) => Array.isArray(fn([1,2,3,4,5], 2)));
      const flatten = pickFn(solution as any, ["flatten"], (fn) => {
        const r = fn([1,[2,3],4]);
        return Array.isArray(r) && r.length === 4;
      });
      const zip = pickFn(solution as any, ["zip"], (fn) => {
        const r = fn([1,2], ["a","b"]);
        return Array.isArray(r) && Array.isArray(r[0]) && r[0].length === 2;
      });

      describe("chunk", () => {
        it("splits array into chunks", () => {
          expect((chunk as any)([1, 2, 3, 4, 5], 2)).toEqual([[1, 2], [3, 4], [5]]);
        });
        it("handles exact division", () => {
          expect((chunk as any)([1, 2, 3, 4], 2)).toEqual([[1, 2], [3, 4]]);
        });
        it("handles empty array", () => {
          expect((chunk as any)([], 3)).toEqual([]);
        });
        it("handles size larger than array", () => {
          expect((chunk as any)([1, 2], 5)).toEqual([[1, 2]]);
        });
      });

      describe("flatten", () => {
        it("flattens one level", () => {
          expect((flatten as any)([1, [2, 3], 4])).toEqual([1, 2, 3, 4]);
        });
        it("handles already flat", () => {
          expect((flatten as any)([1, 2, 3])).toEqual([1, 2, 3]);
        });
        it("handles empty", () => {
          expect((flatten as any)([])).toEqual([]);
        });
      });

      describe("zip", () => {
        it("zips two arrays", () => {
          expect((zip as any)([1, 2], ["a", "b"])).toEqual([[1, "a"], [2, "b"]]);
        });
        it("handles different lengths", () => {
          expect((zip as any)([1, 2, 3], ["a"])).toEqual([[1, "a"]]);
        });
        it("handles empty", () => {
          expect((zip as any)([], [])).toEqual([]);
        });
      });


- id: ts_object_utils
  lang: typescript
  prompt: |
    オブジェクトユーティリティ関数を実装してください。解説不要、コードのみ。

    仕様:
    - pick<T, K extends keyof T>(obj: T, keys: K[]): Pick<T, K>
    - omit<T, K extends keyof T>(obj: T, keys: K[]): Omit<T, K>
    - merge<T>(target: T, source: Partial<T>): T
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import * as solution from "../solution";
      import { pickFn } from "./_flex";

      const pick = pickFn(solution as any, ["pick"], (fn) => JSON.stringify(fn({a:1,b:2}, ["a"])) === JSON.stringify({a:1}));
      const omit = pickFn(solution as any, ["omit"], (fn) => JSON.stringify(fn({a:1,b:2}, ["b"])) === JSON.stringify({a:1}));
      const merge = pickFn(solution as any, ["merge"], (fn) => {
        const r = fn({a:1,b:2}, {b:3});
        return r && r.b === 3;
      });

      describe("pick", () => {
        it("picks specified keys", () => {
          const obj = { a: 1, b: 2, c: 3 };
          expect((pick as any)(obj, ["a", "c"])).toEqual({ a: 1, c: 3 });
        });
        it("handles empty keys", () => {
          const obj = { a: 1 };
          expect((pick as any)(obj, [])).toEqual({});
        });
      });

      describe("omit", () => {
        it("omits specified keys", () => {
          const obj = { a: 1, b: 2, c: 3 };
          expect((omit as any)(obj, ["b"])).toEqual({ a: 1, c: 3 });
        });
        it("handles empty keys", () => {
          const obj = { a: 1 };
          expect((omit as any)(obj, [])).toEqual({ a: 1 });
        });
      });

      describe("merge", () => {
        it("merges objects", () => {
          const target = { a: 1, b: 2 };
          const source = { b: 3 };
          expect((merge as any)(target, source)).toEqual({ a: 1, b: 3 });
        });
        it("handles empty source", () => {
          const target = { a: 1 };
          expect((merge as any)(target, {})).toEqual({ a: 1 });
        });
      });


# -----------------------------------------------------------------------------
# カテゴリ: OOP / クラス設計
# -----------------------------------------------------------------------------

- id: ts_event_emitter
  lang: typescript
  prompt: |
    イベントエミッターを実装してください。解説不要、コードのみ。

    仕様:
    - class EventEmitter<Events extends Record<string, any>>
    - on<K extends keyof Events>(event: K, listener: (data: Events[K]) => void): void
    - off<K extends keyof Events>(event: K, listener: (data: Events[K]) => void): void
    - emit<K extends keyof Events>(event: K, data: Events[K]): void
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import * as solution from "../solution";
      import { makeInstance, pickValue } from "./_flex";

      function createEmitter() {
        const inst = makeInstance<any>(
          solution as any,
          ["EventEmitter", "Emitter"],
          [[]],
          ["createEmitter"],
          [[]],
        );
        expect(inst).not.toBeUndefined();
        return inst!;
      }

      type Events = {
        message: string;
        count: number;
      };

      describe("EventEmitter", () => {
        it("emits to listeners", () => {
          const emitter = createEmitter();
          const messages: string[] = [];
          emitter.on("message", (m) => messages.push(m));
          emitter.emit("message", "hello");
          expect(messages).toEqual(["hello"]);
        });

        it("handles multiple listeners", () => {
          const emitter = createEmitter();
          const results: number[] = [];
          emitter.on("count", (n) => results.push(n));
          emitter.on("count", (n) => results.push(n * 2));
          emitter.emit("count", 5);
          expect(results).toContain(5);
          expect(results).toContain(10);
        });

        it("removes listener with off", () => {
          const emitter = createEmitter();
          const messages: string[] = [];
          const listener = (m: string) => messages.push(m);
          emitter.on("message", listener);
          emitter.off("message", listener);
          emitter.emit("message", "test");
          expect(messages).toEqual([]);
        });

        it("handles no listeners", () => {
          const emitter = createEmitter();
          expect(() => emitter.emit("message", "test")).not.toThrow();
        });
      });


- id: ts_result_type
  lang: typescript
  prompt: |
    Result型（RustのResult相当）を実装してください。解説不要、コードのみ。

    仕様:
    - type Result<T, E> = Ok<T> | Err<E>
    - class Ok<T> { constructor(value: T); isOk(): true; isErr(): false; unwrap(): T }
    - class Err<E> { constructor(error: E); isOk(): false; isErr(): true; unwrap(): never }
    - ok<T>(value: T): Ok<T>
    - err<E>(error: E): Err<E>
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import * as solution from "../solution";
      import { pickFn } from "./_flex";

      const ok = pickFn(solution as any, ["ok", "Ok", "makeOk"]);
      const err = pickFn(solution as any, ["err", "Err", "makeErr"]);
      type Result<T, E> = any;

      describe("Result", () => {
        it("ok isOk returns true", () => {
          const result = (ok as any)(42);
          expect(result.isOk()).toBe(true);
          expect(result.isErr()).toBe(false);
        });

        it("err isErr returns true", () => {
          const result = (err as any)("error");
          expect(result.isErr()).toBe(true);
          expect(result.isOk()).toBe(false);
        });

        it("ok unwrap returns value", () => {
          const result = (ok as any)("success");
          expect(result.unwrap()).toBe("success");
        });

        it("err unwrap throws", () => {
          const result = (err as any)("failure");
          expect(() => result.unwrap()).toThrow();
        });

        it("works with type narrowing", () => {
          const result: Result<number, string> = (ok as any)(10);
          if (result.isOk()) {
            expect(result.unwrap()).toBe(10);
          }
        });
      });


# -----------------------------------------------------------------------------
# カテゴリ: バグ修正 / Bug Fix
# -----------------------------------------------------------------------------

- id: ts_closure_loop_bug
  lang: typescript
  prompt: |
    次のコードにはクロージャとループのバグがあります。修正してください。解説不要、コードのみ。

    問題: すべてのコールバックが同じ値を出力してしまう

    元コード:
    function createCallbacks(items: string[]): (() => string)[] {
        const callbacks: (() => string)[] = [];
        for (var i = 0; i < items.length; i++) {
            callbacks.push(() => items[i]);
        }
        return callbacks;
    }

    期待: 各コールバックはそれぞれの items[i] を返す
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import * as solution from "../solution";
      import { pickFn } from "./_flex";

      const createCallbacks = pickFn(solution as any, ["createCallbacks", "makeCallbacks"]);

      describe("createCallbacks", () => {
        it("returns correct values", () => {
          const callbacks = (createCallbacks as any)(["a", "b", "c"]);
          expect(callbacks[0]()).toBe("a");
          expect(callbacks[1]()).toBe("b");
          expect(callbacks[2]()).toBe("c");
        });

        it("handles single item", () => {
          const callbacks = (createCallbacks as any)(["only"]);
          expect(callbacks[0]()).toBe("only");
        });

        it("handles empty array", () => {
          const callbacks = (createCallbacks as any)([]);
          expect(callbacks.length).toBe(0);
        });

        it("callbacks are independent", () => {
          const callbacks = (createCallbacks as any)(["x", "y"]);
          const first = callbacks[0]();
          const second = callbacks[1]();
          expect(first).not.toBe(second);
        });
      });


# =============================================================================
# エージェント能力評価問題（Agent-Level Challenges）
# =============================================================================

# =============================================================================
# Level 1 (★☆☆☆) - Easy: 入門レベルのエージェント問題
# =============================================================================

- id: ts_agent_L1_storage
  lang: typescript
  prompt: |
    シンプルなKey-Valueストレージを実装してください。解説不要、コードのみ。

    エクスポート:
    - export class Storage
      - set(key: string, value: any, options?: { ttl?: number }): void  // ttl はミリ秒
      - get(key: string): any | undefined
      - delete(key: string): void
      - has(key: string): boolean

    要件:
    - キーと値の保存・取得・削除
    - TTL経過後は get で undefined を返す
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import * as solution from "../solution";
      import { makeInstance } from "./_flex";

      function createStorage() {
        const inst = makeInstance<any>(
          solution as any,
          ["Storage", "KVStorage", "KeyValueStore"],
          [[]],
          ["createStorage", "createKVStore"],
          [[]],
        );
        expect(inst).not.toBeUndefined();
        return inst!;
      }

      describe("Storage", () => {
        it("sets and gets value", () => {
          const storage = createStorage();
          storage.set("key", "value");
          expect(storage.get("key")).toBe("value");
        });

        it("returns undefined for missing key", () => {
          const storage = createStorage();
          expect(storage.get("missing")).toBeUndefined();
        });

        it("deletes value", () => {
          const storage = createStorage();
          storage.set("key", "value");
          storage.delete("key");
          expect(storage.get("key")).toBeUndefined();
        });

        it("handles different types", () => {
          const storage = createStorage();
          storage.set("num", 42);
          storage.set("obj", { a: 1 });
          expect(storage.get("num")).toBe(42);
          expect(storage.get("obj")).toEqual({ a: 1 });
        });

        it("supports TTL", async () => {
          const storage = createStorage();
          storage.set("temp", "value", { ttl: 50 });
          expect(storage.get("temp")).toBe("value");
          await new Promise(r => setTimeout(r, 60));
          expect(storage.get("temp")).toBeUndefined();
        });

        it("has method returns boolean", () => {
          const storage = createStorage();
          storage.set("key", "value");
          expect(storage.has("key")).toBe(true);
          expect(storage.has("missing")).toBe(false);
        });
      });


- id: ts_agent_L1_validator
  lang: typescript
  prompt: |
    シンプルなバリデーターを実装してください。解説不要、コードのみ。

    要件:
    - 文字列、数値、メールアドレスのバリデーション
    - エラーメッセージの取得

    使いやすいAPIを設計してください。
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import * as solution from "../solution";

      // 柔軟なテスト: 様々なAPI実装を許容
      function normalizeResult(r: any): boolean | null {
        if (typeof r === "boolean") return r;
        if (!r) return null;
        if (typeof r.valid === "boolean") return r.valid;
        if (typeof r.isValid === "boolean") return r.isValid;
        if (typeof r.ok === "boolean") return r.ok;
        if (typeof r.success === "boolean") return r.success;
        return null;
      }

      function tryByNameHints(value: any, hints: string[]): any[] {
        const out: any[] = [];
        for (const [k, v] of Object.entries(solution as any)) {
          if (!hints.some((h) => k.toLowerCase().includes(h))) continue;
          if (typeof v === "function") {
            out.push(() => (v as any)(value));
            out.push(() => (v as any)({ email: value }));
            out.push(() => (v as any)({ value }));
          }
        }
        return out;
      }

      function tryCall(thunk: () => any): any | null {
        try { return thunk(); } catch { return null; }
      }

      function tryValidateEmail(value: string): boolean | null {
        try {
          // パターン1: Fluent API (v.string().email().isValid())
          if (solution.Validator) {
            const v = new (solution.Validator as any)();
            if (v.string) return v.string(value).email().isValid();
            if (v.email) return v.email(value).isValid();
            if (v.validateEmail) return v.validateEmail(value);
          }
          // パターン2: 直接関数
          if ((solution as any).validateEmail) return (solution as any).validateEmail(value);
          if ((solution as any).isValidEmail) return (solution as any).isValidEmail(value);
          if ((solution as any).isEmail) return (solution as any).isEmail(value);
          // パターン3: validate関数
          if ((solution as any).validate) {
            const r = (solution as any).validate(value, "email");
            const n = normalizeResult(r);
            if (n !== null) return n;
          }
          // パターン4: それっぽいexportを探索（email含む関数名など）
          for (const thunk of tryByNameHints(value, ["email"])) {
            const r = tryCall(thunk);
            const n = normalizeResult(r);
            if (n !== null) return n;
          }
        } catch (e) {}
        return null;
      }

      function tryValidateRequired(value: string): boolean | null {
        try {
          if (solution.Validator) {
            const v = new (solution.Validator as any)();
            if (v.string) return v.string(value).required().isValid();
            if (v.required) return v.required(value).isValid();
          }
          if ((solution as any).isRequired) return (solution as any).isRequired(value);
          if ((solution as any).validateRequired) return (solution as any).validateRequired(value);
          // それっぽいexport探索
          for (const thunk of tryByNameHints(value, ["required", "nonempty", "non_empty", "notempty", "not_empty"])) {
            const r = tryCall(thunk);
            const n = normalizeResult(r);
            if (n !== null) return n;
          }
        } catch (e) {}
        return null;
      }

      function tryValidateMinLength(value: string, min: number): boolean | null {
        try {
          if (solution.Validator) {
            const v = new (solution.Validator as any)();
            if (v.string) return v.string(value).minLength(min).isValid();
            if (v.minLength) return v.minLength(value, min).isValid();
          }
          if ((solution as any).minLength) return (solution as any).minLength(value, min);
          if ((solution as any).validateMinLength) return (solution as any).validateMinLength(value, min);
          // それっぽいexport探索
          for (const [k, v] of Object.entries(solution as any)) {
            if (!k.toLowerCase().includes("min")) continue;
            if (typeof v !== "function") continue;
            const r = tryCall(() => (v as any)(value, min));
            const n = normalizeResult(r);
            if (n !== null) return n;
          }
        } catch (e) {}
        return null;
      }

      describe("Validator", () => {
        it("validates valid email", () => {
          const result = tryValidateEmail("test@example.com");
          expect(result).toBe(true);
        });

        it("rejects invalid email", () => {
          const result = tryValidateEmail("invalid");
          expect(result).toBe(false);
        });

        it("validates non-empty string as required", () => {
          const result = tryValidateRequired("hello");
          expect(result).toBe(true);
        });

        it("rejects empty string as required", () => {
          const result = tryValidateRequired("");
          expect(result).toBe(false);
        });

        it("validates string meeting min length", () => {
          const result = tryValidateMinLength("hello", 3);
          expect(result).toBe(true);
        });

        it("rejects string below min length", () => {
          const result = tryValidateMinLength("hi", 3);
          expect(result).toBe(false);
        });
      });


- id: ts_agent_L1_formatter
  lang: typescript
  prompt: |
    データフォーマッターを実装してください。解説不要、コードのみ。

    要件:
    - 日付のフォーマット（例: "2024-01-15"）
    - 数値の千区切りフォーマット（例: "1,234,567"）
    - 通貨のフォーマット（例: "$1,234.56"）
    - パーセンテージのフォーマット（例: "75%"）
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import * as solution from "../solution";

      // 柔軟なテスト: 様々なAPI実装を許容
      function tryFormatDate(d: Date): string | null {
        try {
          if (solution.Formatter) {
            const f = new (solution.Formatter as any)();
            if (f.date) return f.date(d);
            if (f.formatDate) return f.formatDate(d);
          }
          if ((solution as any).formatDate) return (solution as any).formatDate(d);
          if ((solution as any).dateFormat) return (solution as any).dateFormat(d);
        } catch (e) {}
        return null;
      }

      function tryFormatNumber(n: number): string | null {
        try {
          if (solution.Formatter) {
            const f = new (solution.Formatter as any)();
            if (f.number) return f.number(n);
            if (f.formatNumber) return f.formatNumber(n);
          }
          if ((solution as any).formatNumber) return (solution as any).formatNumber(n);
          if ((solution as any).numberFormat) return (solution as any).numberFormat(n);
        } catch (e) {}
        return null;
      }

      function tryFormatPercentage(n: number): string | null {
        try {
          if (solution.Formatter) {
            const f = new (solution.Formatter as any)();
            if (f.percentage) return f.percentage(n);
            if (f.percent) return f.percent(n);
            if (f.formatPercentage) return f.formatPercentage(n);
          }
          if ((solution as any).formatPercentage) return (solution as any).formatPercentage(n);
          if ((solution as any).formatPercent) return (solution as any).formatPercent(n);
        } catch (e) {}
        return null;
      }

      describe("Formatter", () => {
        it("formats date with year 2024", () => {
          const result = tryFormatDate(new Date("2024-01-15"));
          expect(result).not.toBeNull();
          expect(result).toContain("2024");
        });

        it("formats number with thousands separator", () => {
          const result = tryFormatNumber(1234567);
          expect(result).not.toBeNull();
          expect(result!.includes(",") || result!.includes(" ") || result!.includes(".")).toBe(true);
        });

        it("formats percentage with percent sign", () => {
          const result = tryFormatPercentage(0.75);
          expect(result).not.toBeNull();
          expect(result!.includes("75") || result!.includes("%")).toBe(true);
        });

        it("formats zero", () => {
          const result = tryFormatNumber(0);
          expect(result).not.toBeNull();
          expect(result).toContain("0");
        });
      });


- id: ts_agent_L1_queue
  lang: typescript
  prompt: |
    シンプルなキュー（FIFO）を実装してください。解説不要、コードのみ。

    要件:
    - エンキュー、デキュー、ピーク
    - サイズ取得、空かどうか判定
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import * as solution from "../solution";
      import { makeInstance } from "./_flex";

      function createQueue() {
        const inst = makeInstance<any>(
          solution as any,
          ["Queue", "FIFOQueue"],
          [[]],
          ["createQueue"],
          [[]],
        );
        expect(inst).not.toBeUndefined();
        return inst!;
      }

      describe("Queue", () => {
        it("enqueues and dequeues in order", () => {
          const q = createQueue();
          q.enqueue(1);
          q.enqueue(2);
          q.enqueue(3);
          expect(q.dequeue()).toBe(1);
          expect(q.dequeue()).toBe(2);
          expect(q.dequeue()).toBe(3);
        });

        it("peeks without removing", () => {
          const q = createQueue();
          q.enqueue("first");
          expect(q.peek()).toBe("first");
          expect(q.size()).toBe(1);
        });

        it("returns undefined on empty dequeue", () => {
          const q = createQueue();
          expect(q.dequeue()).toBeUndefined();
        });

        it("tracks size correctly", () => {
          const q = createQueue();
          expect(q.size()).toBe(0);
          q.enqueue(1);
          q.enqueue(2);
          expect(q.size()).toBe(2);
          q.dequeue();
          expect(q.size()).toBe(1);
        });

        it("isEmpty returns correct value", () => {
          const q = createQueue();
          expect(q.isEmpty()).toBe(true);
          q.enqueue(1);
          expect(q.isEmpty()).toBe(false);
        });
      });


- id: ts_agent_L1_logger
  lang: typescript
  prompt: |
    シンプルなロガーを実装してください。解説不要、コードのみ。

    要件:
    - ログレベル（DEBUG, INFO, WARN, ERROR）
    - レベルに応じたフィルタリング
    - console.logに出力
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect, vi, beforeEach, afterEach } from "vitest";
      import * as solution from "../solution";

      // 柔軟なテスト: console.logをモックして様々なAPI実装を許容
      describe("Logger", () => {
        let logs: string[] = [];
        const originalLog = console.log;

        beforeEach(() => {
          logs = [];
          console.log = (...args) => logs.push(args.join(" "));
        });

        afterEach(() => {
          console.log = originalLog;
        });

        function createLogger(level: string): any {
          const LoggerClass = (solution as any).Logger || (solution as any).default;
          const LogLevel = (solution as any).LogLevel || { DEBUG: 0, INFO: 1, WARN: 2, ERROR: 3 };
          const levelValue = LogLevel[level] ?? level;
          
          if (LoggerClass) {
            try { return new LoggerClass(levelValue); } catch {}
            try { return new LoggerClass({ level: levelValue }); } catch {}
            try { return new LoggerClass(level); } catch {}
            try { return new LoggerClass({ level }); } catch {}
          }
          return null;
        }

        it("logs info message", () => {
          const logger = createLogger("INFO");
          expect(logger).not.toBeNull();
          if (logger?.info) logger.info("test message");
          else if (logger?.log) logger.log("INFO", "test message");
          expect(logs.some(l => l.includes("test message"))).toBe(true);
        });

        it("has log methods", () => {
          const logger = createLogger("DEBUG");
          expect(logger).not.toBeNull();
          const hasDebug = logger?.debug || logger?.log;
          const hasInfo = logger?.info || logger?.log;
          const hasWarn = logger?.warn || logger?.warning || logger?.log;
          const hasError = logger?.error || logger?.log;
          expect(hasDebug || hasInfo || hasWarn || hasError).toBeTruthy();
        });

        it("filters below level", () => {
          const logger = createLogger("WARN");
          if (!logger) return;
          logs = [];
          if (logger.debug) logger.debug("debug msg");
          if (logger.info) logger.info("info msg");
          if (logger.warn) logger.warn("warn msg");
          else if (logger.warning) logger.warning("warn msg");
          // WARNレベルではdebug/infoは出ない、warnは出る
          const hasDebug = logs.some(l => l.includes("debug msg"));
          const hasWarn = logs.some(l => l.includes("warn msg"));
          expect(hasDebug).toBe(false);
        });
      });


# =============================================================================
# Level 2 (★★☆☆) - Medium: 中級レベルのエージェント問題
# =============================================================================

- id: ts_agent_L2_http_client
  lang: typescript
  prompt: |
    HTTPクライアントのラッパーを実装してください。解説不要、コードのみ。

    要件:
    - リトライ機能
    - タイムアウト設定
    - 共通ヘッダの設定
    - レスポンスの型安全な取得

    実際の通信は不要。インターフェースとロジックの実装のみ。
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import * as solution from "../solution";
      import { pickValue, safe } from "./_flex";

      type RequestConfig = any;

      function createClient(opts: any) {
        // "/api" のような相対URLを扱えない実装が多いので、ベースURLをデフォルト注入
        if (!opts.baseUrl && !opts.baseURL) opts.baseUrl = "http://example.com";
        const Ctor = pickValue(solution as any, ["HttpClient", "Client", "APIClient", "Http"]);
        if (Ctor) {
          return (
            safe(() => new (Ctor as any)(opts)) ??
            safe(() => new (Ctor as any)(opts.transport, opts)) ??
            safe(() => new (Ctor as any)(opts.transport)) ??
            undefined
          );
        }
        const factory =
          (solution as any).createHttpClient ??
          (solution as any).createClient ??
          (solution as any).httpClient ??
          (solution as any).client;
        if (typeof factory === "function") return factory(opts);
        return undefined;
      }

      describe("HttpClient", () => {
        it("executes request through transport", async () => {
          const transport = async (url: string, config: RequestConfig) => ({
            status: 200,
            data: { result: "ok" }
          });
          const client = createClient({ transport });
          expect(client).not.toBeUndefined();
          const response = await client.get("/api/test");
          expect(response.data.result).toBe("ok");
        });

        it("applies default headers", async () => {
          let capturedHeaders: Record<string, string> = {};
          const transport = async (url: string, config: RequestConfig) => {
            capturedHeaders = config.headers || {};
            return { status: 200, data: {} };
          };
          const client = createClient({
            transport,
            defaultHeaders: { "Authorization": "Bearer token" }
          });
          expect(client).not.toBeUndefined();
          await client.get("/api");
          expect(capturedHeaders["Authorization"]).toBe("Bearer token");
        });

        it("retries on failure", async () => {
          let attempts = 0;
          const transport = async () => {
            attempts++;
            if (attempts < 3) throw new Error("fail");
            return { status: 200, data: {} };
          };
          const client = createClient({ transport, retries: 3 });
          expect(client).not.toBeUndefined();
          await client.get("/api");
          expect(attempts).toBe(3);
        });

        it("throws after max retries", async () => {
          const transport = async () => { throw new Error("always fails"); };
          const client = createClient({ transport, retries: 2 });
          expect(client).not.toBeUndefined();
          await expect(client.get("/api")).rejects.toThrow();
        });
      });


- id: ts_agent_L2_state_manager
  lang: typescript
  prompt: |
    シンプルな状態管理ライブラリを実装してください。解説不要、コードのみ。

    要件:
    - クラス名: `Store` を export すること
    - メソッド:
      - `constructor(initialState: any)`
      - `getState(): any`: 現在の状態を返す
      - `setState(newState: any): void`: 状態を更新する
      - `subscribe(listener: (state: any) => void): () => void`: 変更を購読し、解除関数を返す
    - 機能:
      - 状態の取得・更新
      - 変更の購読
      - セレクター（派生状態）も考慮すること
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import * as solution from "../solution";

      function createStore(initial: any) {
        const Store = (solution as any).Store;
        if (!Store) return undefined;
        return new Store(initial);
      }

      describe("Store", () => {
        it("gets initial state", () => {
          const store = createStore({ count: 0 });
          expect(store).not.toBeUndefined();
          expect(store.getState().count).toBe(0);
        });

        it("updates state", () => {
          const store = createStore({ count: 0 });
          expect(store).not.toBeUndefined();
          store.setState({ count: 5 });
          expect(store.getState().count).toBe(5);
        });

        it("notifies subscribers", () => {
          const store = createStore({ count: 0 });
          expect(store).not.toBeUndefined();
          const values: number[] = [];
          store.subscribe((state: any) => values.push(state.count));
          store.setState({ count: 1 });
          store.setState({ count: 2 });
          expect(values).toContain(1);
          expect(values).toContain(2);
        });

        it("unsubscribes", () => {
          const store = createStore({ count: 0 });
          expect(store).not.toBeUndefined();
          const values: number[] = [];
          const unsub = store.subscribe((state: any) => values.push(state.count));
          store.setState({ count: 1 });
          if (typeof unsub === "function") unsub();
          store.setState({ count: 2 });
          expect(values).toEqual([1]);
        });
      });


- id: ts_agent_L2_router
  lang: typescript
  prompt: |
    シンプルなURLルーターを実装してください。解説不要、コードのみ。

    要件:
    - クラス名: `Router` を export すること
    - メソッド:
      - `add(path: string, handler: (params: any, query: any) => void): void`
      - `navigate(path: string): any`
    - 機能:
      - パスパターンのマッチング（/users/:id など）
      - クエリパラメータの解析
      - ルートハンドラの登録と実行
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import * as solution from "../solution";

      function createRouter() {
        const Router = (solution as any).Router;
        if (!Router) return undefined;
        return new Router();
      }

      describe("Router", () => {
        it("matches exact path", () => {
          const router = createRouter();
          expect(router).not.toBeUndefined();
          let called = false;
          router.add("/users", () => { called = true; });
          router.navigate("/users");
          expect(called).toBe(true);
        });

        it("extracts path parameters", () => {
          const router = createRouter();
          expect(router).not.toBeUndefined();
          let userId = "";
          router.add("/users/:id", (params: any) => { userId = params.id; });
          router.navigate("/users/123");
          expect(userId).toBe("123");
        });

        it("handles multiple parameters", () => {
          const router = createRouter();
          expect(router).not.toBeUndefined();
          let params: Record<string, string> = {};
          router.add("/users/:userId/posts/:postId", (p: any) => { params = p; });
          router.navigate("/users/1/posts/2");
          expect(params.userId).toBe("1");
          expect(params.postId).toBe("2");
        });

        it("parses query parameters", () => {
          const router = createRouter();
          expect(router).not.toBeUndefined();
          let query: Record<string, string> = {};
          router.add("/search", (params: any, q: any) => { query = q; });
          router.navigate("/search?q=test&page=1");
          expect(query.q).toBe("test");
          expect(query.page).toBe("1");
        });

        it("returns false for no match", () => {
          const router = createRouter();
          expect(router).not.toBeUndefined();
          router.add("/users", () => {});
          const matched = router.navigate("/posts");
          expect(matched).toBe(false);
        });
      });


- id: ts_agent_L2_task_queue
  lang: typescript
  prompt: |
    非同期タスクキューを実装してください。解説不要、コードのみ。

    要件:
    - クラス名: `TaskQueue` を export すること
    - メソッド:
      - `constructor(options: { concurrency: number })`
      - `add(task: () => Promise<void>): void`
      - `drain(): Promise<void>`: 全タスク完了まで待機
    - 機能:
      - タスクの追加と実行
      - 同時実行数の制限（concurrency）
      - 実行状態の追跡
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import * as solution from "../solution";

      const TaskQueue = (solution as any).TaskQueue;
      const sleep = (ms: number) => new Promise(r => setTimeout(r, ms));

      describe("TaskQueue", () => {
        if (!TaskQueue) {
          it("exports TaskQueue class", () => {
            expect(TaskQueue).toBeDefined();
          });
          return;
        }

        it("executes tasks", async () => {
          const queue = new TaskQueue({ concurrency: 2 });
          const results: number[] = [];
          queue.add(async () => { results.push(1); });
          queue.add(async () => { results.push(2); });
          await queue.drain();
          expect(results).toContain(1);
          expect(results).toContain(2);
        });

        it("respects concurrency limit", async () => {
          const queue = new TaskQueue({ concurrency: 1 });
          const order: number[] = [];
          queue.add(async () => { await sleep(30); order.push(1); });
          queue.add(async () => { order.push(2); });
          await queue.drain();
          expect(order).toEqual([1, 2]);
        });

        it("handles errors gracefully", async () => {
          const queue = new TaskQueue({ concurrency: 2 });
          const results: string[] = [];
          queue.add(async () => { throw new Error("fail"); });
          queue.add(async () => { results.push("ok"); });
          await queue.drain();
          expect(results).toContain("ok");
        });
      });


- id: ts_agent_L2_cache
  lang: typescript
  prompt: |
    LRUキャッシュを実装してください。解説不要、コードのみ。

    要件:
    - クラス名: `LRUCache` を export すること
    - メソッド:
      - `constructor(options: { maxSize: number })`
      - `get(key: string): any`
      - `set(key: string, value: any, options?: { ttl: number }): void`
      - `size(): number`
      - `has(key: string): boolean`
    - 機能:
      - 最大サイズの制限
      - 最も使われていないアイテムを削除
      - TTL（有効期限）サポート
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import * as solution from "../solution";

      const LRUCache = (solution as any).LRUCache;

      describe("LRUCache", () => {
        if (!LRUCache) {
          it("exports LRUCache class", () => {
            expect(LRUCache).toBeDefined();
          });
          return;
        }

        it("stores and retrieves values", () => {
          const cache = new LRUCache({ maxSize: 3 });
          cache.set("a", 1);
          expect(cache.get("a")).toBe(1);
        });

        it("evicts least recently used", () => {
          const cache = new LRUCache({ maxSize: 2 });
          cache.set("a", 1);
          cache.set("b", 2);
          cache.get("a"); // access a
          cache.set("c", 3); // should evict b
          expect(cache.get("b")).toBeUndefined();
          expect(cache.get("a")).toBe(1);
        });

        it("respects max size", () => {
          const cache = new LRUCache({ maxSize: 2 });
          cache.set("a", 1);
          cache.set("b", 2);
          cache.set("c", 3);
          expect(cache.size()).toBe(2);
        });

        it("supports TTL", async () => {
          const cache = new LRUCache({ maxSize: 10 });
          cache.set("temp", 42, { ttl: 50 });
          expect(cache.get("temp")).toBe(42);
          await new Promise(r => setTimeout(r, 60));
          expect(cache.get("temp")).toBeUndefined();
        });

        it("has method works correctly", () => {
          const cache = new LRUCache({ maxSize: 2 });
          cache.set("a", 1);
          expect(cache.has("a")).toBe(true);
          expect(cache.has("b")).toBe(false);
        });
      });


- id: ts_agent_L2_schema_validator
  lang: typescript
  prompt: |
    JSONスキーマバリデーターを実装してください。解説不要、コードのみ。

    要件:
    - オブジェクトスキーマの定義
    - 必須/オプショナルフィールド
    - 型チェック（string, number, boolean, array, object）
    - ネストしたオブジェクトの検証
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import * as solution from "../solution";
      import { pickValue, pickFn } from "./_flex";

      function getSchemaApi() {
        const Schema = pickValue(solution as any, ["Schema", "schema", "S", "s"]);
        const validate = pickFn(solution as any, ["validate", "validateSchema", "check"], (fn) => {
          const sc = Schema?.object?.({ name: Schema.string?.() });
          const r = fn({ name: "x" }, sc);
          return r && typeof r === "object" && "valid" in r;
        });
        // fallback: zod-like (parse throws)
        const z = pickValue(solution as any, ["z"]);
        return { Schema, validate, z };
      }

      const api = getSchemaApi();

      describe("Schema Validator", () => {
        it("validates simple object", () => {
          if (api.Schema && api.validate) {
            const schema = api.Schema.object({
              name: api.Schema.string(),
              age: api.Schema.number()
            });
            const result = api.validate({ name: "Alice", age: 30 }, schema);
            expect(result.valid).toBe(true);
            return;
          }
          if (api.z) {
            const schema = api.z.object({ name: api.z.string(), age: api.z.number() });
            expect(schema.parse({ name: "Alice", age: 30 })).toEqual({ name: "Alice", age: 30 });
            return;
          }
          throw new Error("No schema API found");
        });

        it("fails on wrong type", () => {
          if (api.Schema && api.validate) {
            const schema = api.Schema.object({
              name: api.Schema.string()
            });
            const result = api.validate({ name: 123 }, schema);
            expect(result.valid).toBe(false);
            return;
          }
          if (api.z) {
            const schema = api.z.object({ name: api.z.string() });
            expect(() => schema.parse({ name: 123 })).toThrow();
            return;
          }
          throw new Error("No schema API found");
        });

        it("validates optional fields", () => {
          if (api.Schema && api.validate) {
            const schema = api.Schema.object({
              name: api.Schema.string(),
              age: api.Schema.number().optional()
            });
            const result = api.validate({ name: "Bob" }, schema);
            expect(result.valid).toBe(true);
            return;
          }
          if (api.z) {
            const schema = api.z.object({ name: api.z.string(), age: api.z.number().optional() });
            expect(schema.parse({ name: "Bob" }).name).toBe("Bob");
            return;
          }
          throw new Error("No schema API found");
        });

        it("validates arrays", () => {
          if (api.Schema && api.validate) {
            const schema = api.Schema.object({
              tags: api.Schema.array(api.Schema.string())
            });
            const result = api.validate({ tags: ["a", "b"] }, schema);
            expect(result.valid).toBe(true);
            return;
          }
          if (api.z) {
            const schema = api.z.object({ tags: api.z.array(api.z.string()) });
            expect(schema.parse({ tags: ["a", "b"] }).tags).toEqual(["a", "b"]);
            return;
          }
          throw new Error("No schema API found");
        });

        it("validates nested objects", () => {
          if (api.Schema && api.validate) {
            const schema = api.Schema.object({
              user: api.Schema.object({
                name: api.Schema.string()
              })
            });
            const result = api.validate({ user: { name: "Charlie" } }, schema);
            expect(result.valid).toBe(true);
            return;
          }
          if (api.z) {
            const schema = api.z.object({ user: api.z.object({ name: api.z.string() }) });
            expect(schema.parse({ user: { name: "Charlie" } }).user.name).toBe("Charlie");
            return;
          }
          throw new Error("No schema API found");
        });

        it("returns error details", () => {
          if (api.Schema && api.validate) {
            const schema = api.Schema.object({ name: api.Schema.string() });
            const result = api.validate({ name: 123 }, schema);
            expect(result.errors?.length ?? 0).toBeGreaterThan(0);
            return;
          }
          if (api.z) {
            const schema = api.z.object({ name: api.z.string() });
            try {
              schema.parse({ name: 123 });
            } catch (e: any) {
              expect(String(e)).toContain("");
              return;
            }
            throw new Error("expected parse to throw");
          }
          throw new Error("No schema API found");
        });
      });


# =============================================================================
# Level 3 (★★★☆) - Hard: 上級レベルのエージェント問題
# =============================================================================

- id: ts_agent_L3_dependency_injection
  lang: typescript
  prompt: |
    依存性注入（DI）コンテナを実装してください。解説不要、コードのみ。

    要件:
    - サービスの登録と解決
    - シングルトン/ファクトリのライフタイム管理
    - 依存関係の自動解決
    - 型安全なAPI
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import * as solution from "../solution";
      import { pickValue, safe } from "./_flex";

      function createContainer() {
        const Ctor = pickValue(solution as any, ["Container", "DIContainer", "Injector"]);
        if (Ctor) return safe(() => new (Ctor as any)());
        const factory = (solution as any).createContainer ?? (solution as any).container;
        if (typeof factory === "function") return factory();
        return undefined;
      }

      describe("DI Container", () => {
        it("resolves simple service", () => {
          const container = createContainer();
          expect(container).not.toBeUndefined();
          class UserService { name = "UserService"; }
          container.register(UserService);
          const instance = container.resolve(UserService);
          expect(instance.name).toBe("UserService");
        });

        it("resolves with dependencies", () => {
          const container = createContainer();
          expect(container).not.toBeUndefined();
          class Database { connected = true; }
          class UserService {
            constructor(public db: Database) {}
          }
          container.register(Database);
          container.register(UserService, [Database]);
          const instance = container.resolve(UserService);
          expect(instance.db.connected).toBe(true);
        });

        it("singleton returns same instance", () => {
          const container = createContainer();
          expect(container).not.toBeUndefined();
          class Service {}
          container.register(Service, [], { singleton: true });
          const a = container.resolve(Service);
          const b = container.resolve(Service);
          expect(a).toBe(b);
        });

        it("transient creates new instances", () => {
          const container = createContainer();
          expect(container).not.toBeUndefined();
          class Service {}
          container.register(Service, [], { singleton: false });
          const a = container.resolve(Service);
          const b = container.resolve(Service);
          expect(a).not.toBe(b);
        });

        it("throws for unregistered service", () => {
          const container = createContainer();
          expect(container).not.toBeUndefined();
          class Missing {}
          expect(() => container.resolve(Missing)).toThrow();
        });
      });


- id: ts_agent_L3_state_machine
  lang: typescript
  prompt: |
    型安全な有限状態マシン（FSM）を実装してください。解説不要、コードのみ。

    要件:
    - 状態と遷移の定義
    - 無効な遷移のコンパイル時/実行時検出
    - 遷移時のコールバック
    - TypeScriptの型システムを活用
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import * as solution from "../solution";
      import { pickValue, safe } from "./_flex";

      function createSM(def: any) {
        const Ctor = pickValue(solution as any, ["StateMachine", "FSM", "Machine", "TypeSafeFSM", "TrafficLightFSM"]);
        if (Ctor) return safe(() => new (Ctor as any)(def)) ?? safe(() => (Ctor as any)(def)) ?? undefined;
        const factory = (solution as any).createStateMachine ?? (solution as any).createMachine;
        if (typeof factory === "function") return factory(def);
        return undefined;
      }

      describe("StateMachine", () => {
        it("starts in initial state", () => {
          const sm = createSM({
            initial: "idle",
            states: {
              idle: { on: { START: "running" } },
              running: { on: { STOP: "idle" } }
            }
          });
          expect(sm).not.toBeUndefined();
          expect(sm.state ?? sm.getState?.()).toBe("idle");
        });

        it("transitions on valid event", () => {
          const sm = createSM({
            initial: "idle",
            states: {
              idle: { on: { START: "running" } },
              running: { on: { STOP: "idle" } }
            }
          });
          expect(sm).not.toBeUndefined();
          (sm.send ?? sm.dispatch ?? sm.transition)("START");
          expect(sm.state ?? sm.getState?.()).toBe("running");
        });

        it("ignores invalid event", () => {
          const sm = createSM({
            initial: "idle",
            states: {
              idle: { on: { START: "running" } },
              running: {}
            }
          });
          expect(sm).not.toBeUndefined();
          (sm.send ?? sm.dispatch ?? sm.transition)("START");
          (sm.send ?? sm.dispatch ?? sm.transition)("START"); // invalid in running state
          expect(sm.state ?? sm.getState?.()).toBe("running");
        });

        it("calls onEnter callback", () => {
          let entered = false;
          const sm = createSM({
            initial: "idle",
            states: {
              idle: { on: { START: "running" } },
              running: { onEnter: () => { entered = true; } }
            }
          });
          expect(sm).not.toBeUndefined();
          (sm.send ?? sm.dispatch ?? sm.transition)("START");
          expect(entered).toBe(true);
        });

        it("can check available transitions", () => {
          const sm = createSM({
            initial: "idle",
            states: {
              idle: { on: { START: "running", RESET: "idle" } },
              running: {}
            }
          });
          expect(sm).not.toBeUndefined();
          const available = (sm.availableEvents ?? sm.events ?? sm.getAvailableEvents)?.call(sm) ?? [];
          expect(available).toContain("START");
        });
      });


- id: ts_agent_L3_query_builder
  lang: typescript
  prompt: |
    型安全なSQLクエリビルダーを実装してください。解説不要、コードのみ。

    要件:
    - SELECT, WHERE, JOIN, ORDER BY をサポート
    - メソッドチェーンで組み立て
    - パラメータのプレースホルダ（SQLインジェクション対策）
    - TypeScriptの型推論を活用
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import * as solution from "../solution";
      import { pickValue, safe } from "./_flex";

      function createQB() {
        const Ctor = pickValue(solution as any, ["QueryBuilder", "SQLBuilder", "Builder"]);
        if (Ctor) return safe(() => new (Ctor as any)()) ?? safe(() => (Ctor as any)()) ?? undefined;
        const factory = (solution as any).createQueryBuilder ?? (solution as any).qb;
        if (typeof factory === "function") return factory();
        return undefined;
      }

      describe("QueryBuilder", () => {
        it("builds simple select", () => {
          const qb = createQB();
          expect(qb).not.toBeUndefined();
          const { query } = qb.select("users").build();
          expect(query.toUpperCase()).toContain("SELECT");
          expect(query.toLowerCase()).toContain("users");
        });

        it("builds select with columns", () => {
          const qb = createQB();
          expect(qb).not.toBeUndefined();
          const { query } = qb.select("users", ["id", "name"]).build();
          expect(query).toContain("id");
          expect(query).toContain("name");
        });

        it("builds where clause", () => {
          const qb = createQB();
          expect(qb).not.toBeUndefined();
          const { query, params } = qb.select("users").where("age", ">", 18).build();
          expect(query.toUpperCase()).toContain("WHERE");
          expect(params).toContain(18);
        });

        it("builds multiple where clauses", () => {
          const qb = createQB();
          expect(qb).not.toBeUndefined();
          const { query } = qb.select("users").where("age", ">", 18).where("status", "=", "active").build();
          expect(query.toUpperCase()).toContain("AND");
        });

        it("builds order by", () => {
          const qb = createQB();
          expect(qb).not.toBeUndefined();
          const { query } = qb.select("users").orderBy("name", "ASC").build();
          expect(query.toUpperCase()).toContain("ORDER BY");
        });

        it("prevents SQL injection", () => {
          const qb = createQB();
          expect(qb).not.toBeUndefined();
          const { query, params } = qb.select("users").where("name", "=", "'; DROP TABLE users;--").build();
          expect(query).not.toContain("DROP TABLE");
          expect(params).toContain("'; DROP TABLE users;--");
        });
      });


- id: ts_agent_L3_event_sourcing
  lang: typescript
  prompt: |
    イベントソーシングシステムを実装してください。解説不要、コードのみ。

    要件:
    - イベントの記録
    - イベントからの状態復元
    - 集約（Aggregate）パターン
    - スナップショットのサポート
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import * as solution from "../solution";
      import { pickValue, safe } from "./_flex";

      const EventStoreCtor = pickValue(solution as any, ["EventStore", "Store"]);
      const BankAccountCtor = pickValue(solution as any, ["BankAccount", "Account"]);

      describe("EventStore", () => {
        it("stores events", () => {
          const store = safe(() => new (EventStoreCtor as any)());
          expect(store).not.toBeUndefined();
          store.append("account-1", { type: "deposited", amount: 100 });
          const events = store.getEvents("account-1");
          expect(events.length).toBe(1);
        });

        it("stores events in order", () => {
          const store = safe(() => new (EventStoreCtor as any)());
          expect(store).not.toBeUndefined();
          store.append("acc", { type: "deposited", amount: 100 });
          store.append("acc", { type: "withdrawn", amount: 30 });
          const events = store.getEvents("acc");
          expect(events[0].amount).toBe(100);
          expect(events[1].amount).toBe(30);
        });

        it("isolates aggregates", () => {
          const store = safe(() => new (EventStoreCtor as any)());
          expect(store).not.toBeUndefined();
          store.append("acc-1", { type: "deposited", amount: 100 });
          store.append("acc-2", { type: "deposited", amount: 200 });
          expect(store.getEvents("acc-1").length).toBe(1);
          expect(store.getEvents("acc-2").length).toBe(1);
        });
      });

      describe("BankAccount", () => {
        it("reconstructs from events", () => {
          const events = [
            { type: "deposited", amount: 100 },
            { type: "deposited", amount: 50 },
            { type: "withdrawn", amount: 30 }
          ];
          const account = (BankAccountCtor as any)?.fromEvents?.(events);
          expect(account).not.toBeUndefined();
          expect(account.balance).toBe(120);
        });

        it("handles empty events", () => {
          const account = (BankAccountCtor as any)?.fromEvents?.([]);
          expect(account).not.toBeUndefined();
          expect(account.balance).toBe(0);
        });
      });


- id: ts_agent_L3_circuit_breaker
  lang: typescript
  prompt: |
    サーキットブレーカーパターンを実装してください。解説不要、コードのみ。

    要件:
    - クラス名: `CircuitBreaker` を export すること
    - メソッド:
      - `constructor(options: { failureThreshold: number, recoveryTimeout: number })`
      - `call<T>(fn: () => Promise<T>): Promise<T>`
    - プロパティ:
      - `state`: 現在の状態 ("CLOSED" | "OPEN" | "HALF_OPEN")
    - 機能:
      - 連続失敗でサーキットをオープン
      - タイムアウト後にハーフオープン状態
      - 成功でクローズ状態に復帰
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import * as solution from "../solution";

      const CircuitBreaker = (solution as any).CircuitBreaker;
      const sleep = (ms: number) => new Promise(r => setTimeout(r, ms));

      describe("CircuitBreaker", () => {
        if (!CircuitBreaker) {
          it("exports CircuitBreaker class", () => {
            expect(CircuitBreaker).toBeDefined();
          });
          return;
        }

        it("starts in closed state", () => {
          const cb = new CircuitBreaker({ failureThreshold: 3, recoveryTimeout: 100 });
          expect(cb.state).toBe("CLOSED");
        });

        it("passes calls in closed state", async () => {
          const cb = new CircuitBreaker({ failureThreshold: 3, recoveryTimeout: 100 });
          const result = await cb.call(() => Promise.resolve("ok"));
          expect(result).toBe("ok");
        });

        it("opens after threshold failures", async () => {
          const cb = new CircuitBreaker({ failureThreshold: 2, recoveryTimeout: 100 });
          for (let i = 0; i < 2; i++) {
            try {
              await cb.call(() => Promise.reject(new Error("fail")));
            } catch {}
          }
          expect(cb.state).toBe("OPEN");
        });

        it("rejects calls in open state", async () => {
          const cb = new CircuitBreaker({ failureThreshold: 1, recoveryTimeout: 1000 });
          try {
            await cb.call(() => Promise.reject(new Error("fail")));
          } catch {}
          await expect(cb.call(() => Promise.resolve("test"))).rejects.toThrow();
        });

        it("transitions to half-open after timeout", async () => {
          const cb = new CircuitBreaker({ failureThreshold: 1, recoveryTimeout: 50 });
          try {
            await cb.call(() => Promise.reject(new Error("fail")));
          } catch {}
          await sleep(60);
          expect(cb.state).toBe("HALF_OPEN");
        });

        it("closes on success in half-open", async () => {
          const cb = new CircuitBreaker({ failureThreshold: 1, recoveryTimeout: 50 });
          try {
            await cb.call(() => Promise.reject(new Error("fail")));
          } catch {}
          await sleep(60);
          await cb.call(() => Promise.resolve("recovered"));
          expect(cb.state).toBe("CLOSED");
        });
      });


- id: ts_agent_L3_plugin_system
  lang: typescript
  prompt: |
    型安全なプラグインシステムを実装してください。解説不要、コードのみ。

    要件:
    - クラス名: `PluginManager` を export
    - メソッド:
      - `register(plugin: any): void`
      - `activate(name: string): void`
      - `deactivate(name: string): void`
      - `hook(point: string, handler: Function, options?: { priority: number }): void`
      - `trigger(point: string, ...args: any[]): any[]`
    - 機能:
      - プラグインの登録とライフサイクル管理
      - フックポイントでの拡張
      - プラグイン間の依存関係
      - 型安全なプラグインAPI
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import * as solution from "../solution";

      const PluginManager = (solution as any).PluginManager;

      describe("PluginManager", () => {
        if (!PluginManager) {
          it("exports PluginManager class", () => {
            expect(PluginManager).toBeDefined();
          });
          return;
        }

        it("registers plugins", () => {
          const manager = new PluginManager();
          const plugin = { name: "test", activate: () => {}, deactivate: () => {} };
          manager.register(plugin);
          // 内部実装依存を避けるため、動作で確認したいが、ここではエラーにならないことだけ確認
          expect(true).toBe(true);
        });

        it("activates plugins", () => {
          const manager = new PluginManager();
          let activated = false;
          const plugin = {
            name: "test",
            activate: () => { activated = true; },
            deactivate: () => {}
          };
          manager.register(plugin);
          manager.activate("test");
          expect(activated).toBe(true);
        });
        
        it("supports hooks", () => {
          const manager = new PluginManager();
          const results: string[] = [];
          manager.hook("onInit", () => results.push("init"));
          manager.trigger("onInit");
          expect(results).toContain("init");
        });
      });


# =============================================================================
# Level 4 (★★★★) - Expert: エキスパートレベルのエージェント問題
# =============================================================================

- id: ts_agent_L4_workflow_engine
  lang: typescript
  prompt: |
    ワークフローエンジンを実装してください。解説不要、コードのみ。

    要件:
    - タスクの定義と依存関係
    - 並列/直列実行
    - 失敗時のリトライ/スキップ戦略
    - 実行状態の追跡
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import * as solution from "../solution";
      import { pickValue, safe, bindAny } from "./_flex";

      const WorkflowCtor = pickValue(solution as any, ["Workflow", "WorkflowEngine", "Engine"]);
      const TaskStatus = pickValue(solution as any, ["TaskStatus", "Status"]) ?? {
        COMPLETED: "COMPLETED",
        FAILED: "FAILED",
        SKIPPED: "SKIPPED",
      };

      const isStatus = (s: any, key: string) => s === (TaskStatus as any)[key] || String(s).toLowerCase().includes(key.toLowerCase());

      function createWF() {
        return safe(() => new (WorkflowCtor as any)()) ?? safe(() => (WorkflowCtor as any)()) ?? undefined;
      }

      describe("Workflow", () => {
        it("executes sequential tasks", async () => {
          const results: string[] = [];
          const wf = createWF();
          expect(wf).not.toBeUndefined();
          const addTask = bindAny(wf, ["addTask", "add", "register", "task"])!;
          const run = bindAny(wf, ["run", "execute", "start", "dispatch"])!;
          addTask("a", async () => { results.push("a"); });
          addTask("b", async () => { results.push("b"); }, { dependsOn: ["a"] });
          await run();
          expect(results).toEqual(["a", "b"]);
        });

        it("executes parallel tasks", async () => {
          const results: string[] = [];
          const wf = createWF();
          expect(wf).not.toBeUndefined();
          const addTask = bindAny(wf, ["addTask", "add", "register", "task"])!;
          const run = bindAny(wf, ["run", "execute", "start", "dispatch"])!;
          addTask("a", async () => { results.push("a"); });
          addTask("b", async () => { results.push("b"); });
          addTask("c", async () => { results.push("c"); }, { dependsOn: ["a", "b"] });
          await run();
          expect(results).toContain("a");
          expect(results).toContain("b");
          expect(results[results.length - 1]).toBe("c");
        });

        it("handles task failure", async () => {
          const wf = createWF();
          expect(wf).not.toBeUndefined();
          const addTask = bindAny(wf, ["addTask", "add", "register", "task"])!;
          const run = bindAny(wf, ["run", "execute", "start", "dispatch"])!;
          const getStatus = bindAny(wf, ["getStatus", "status", "getTaskStatus", "state"])!;
          addTask("a", async () => { throw new Error("fail"); });
          addTask("b", async () => {}, { dependsOn: ["a"] });
          await run();
          expect(isStatus(getStatus("a"), "FAILED")).toBe(true);
          expect(isStatus(getStatus("b"), "SKIPPED")).toBe(true);
        });

        it("retries failed tasks", async () => {
          let attempts = 0;
          const wf = createWF();
          expect(wf).not.toBeUndefined();
          const addTask = bindAny(wf, ["addTask", "add", "register", "task"])!;
          const run = bindAny(wf, ["run", "execute", "start", "dispatch"])!;
          const getStatus = bindAny(wf, ["getStatus", "status", "getTaskStatus", "state"])!;
          addTask("a", async () => {
            attempts++;
            if (attempts < 3) throw new Error("fail");
          }, { retries: 3 });
          await run();
          expect(isStatus(getStatus("a"), "COMPLETED")).toBe(true);
        });
      });


- id: ts_agent_L4_rule_engine
  lang: typescript
  prompt: |
    ビジネスルールエンジンを実装してください。解説不要、コードのみ。

    要件:
    - ルールの定義（条件 + アクション）
    - ルールの優先度と競合解決
    - ファクトに対するルール適用
    - 型安全なルール定義
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import * as solution from "../solution";
      import { pickValue, safe, bindAny } from "./_flex";

      const RuleEngineCtor = pickValue(solution as any, ["RuleEngine", "Engine"]);

      function createEngine<T>() {
        return safe(() => new (RuleEngineCtor as any)()) ?? safe(() => (RuleEngineCtor as any)()) ?? undefined;
      }

      describe("RuleEngine", () => {
        it("applies matching rule", () => {
          const engine = createEngine<{ age: number; discount: number }>();
          expect(engine).not.toBeUndefined();
          const addRule = bindAny(engine, ["addRule", "add", "register", "rule"])!;
          const run = bindAny(engine, ["run", "execute", "apply", "process"])!;
          addRule({
            name: "senior",
            condition: (facts: any) => facts.age >= 65,
            action: (facts: any) => { facts.discount = 20; }
          });
          const facts = { age: 70, discount: 0 };
          run(facts);
          expect(facts.discount).toBe(20);
        });

        it("skips non-matching rules", () => {
          const engine = createEngine<{ age: number; discount: number }>();
          expect(engine).not.toBeUndefined();
          const addRule = bindAny(engine, ["addRule", "add", "register", "rule"])!;
          const run = bindAny(engine, ["run", "execute", "apply", "process"])!;
          addRule({
            name: "senior",
            condition: (facts: any) => facts.age >= 65,
            action: (facts: any) => { facts.discount = 20; }
          });
          const facts = { age: 30, discount: 0 };
          run(facts);
          expect(facts.discount).toBe(0);
        });

        it("applies multiple rules", () => {
          const engine = createEngine<{ member: boolean; quantity: number; discount: number }>();
          expect(engine).not.toBeUndefined();
          const addRule = bindAny(engine, ["addRule", "add", "register", "rule"])!;
          const run = bindAny(engine, ["run", "execute", "apply", "process"])!;
          addRule({
            name: "member",
            condition: (f: any) => f.member,
            action: (f: any) => { f.discount += 5; }
          });
          addRule({
            name: "bulk",
            condition: (f: any) => f.quantity >= 10,
            action: (f: any) => { f.discount += 10; }
          });
          const facts = { member: true, quantity: 15, discount: 0 };
          run(facts);
          expect(facts.discount).toBe(15);
        });

        it("respects priority", () => {
          const engine = createEngine<{ value: string }>();
          expect(engine).not.toBeUndefined();
          const results: string[] = [];
          const addRule = bindAny(engine, ["addRule", "add", "register", "rule"])!;
          const run = bindAny(engine, ["run", "execute", "apply", "process"])!;
          addRule({
            name: "low",
            priority: 10,
            condition: () => true,
            action: () => { results.push("low"); }
          });
          addRule({
            name: "high",
            priority: 1,
            condition: () => true,
            action: () => { results.push("high"); }
          });
          run({ value: "" });
          expect(results[0]).toBe("high");
        });
      });


- id: ts_agent_L4_saga_pattern
  lang: typescript
  prompt: |
    Sagaパターン（分散トランザクション）を実装してください。解説不要、コードのみ。

    要件:
    - 複数ステップのトランザクション
    - 各ステップの補償アクション
    - 失敗時の自動ロールバック
    - オーケストレーション型
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import * as solution from "../solution";
      import { pickValue, safe, bindAny } from "./_flex";

      const SagaCtor = pickValue(solution as any, ["Saga", "SagaOrchestrator"]);
      const SagaStatus = pickValue(solution as any, ["SagaStatus", "Status"]) ?? {
        COMPLETED: "COMPLETED",
        COMPENSATED: "COMPENSATED",
      };

      const isSagaStatus = (s: any, key: string) => s === (SagaStatus as any)[key] || String(s).toLowerCase().includes(key.toLowerCase());

      function createSaga() {
        return safe(() => new (SagaCtor as any)()) ?? safe(() => (SagaCtor as any)()) ?? undefined;
      }

      describe("Saga", () => {
        it("executes all steps on success", async () => {
          const results: string[] = [];
          const saga = createSaga();
          expect(saga).not.toBeUndefined();
          const addStep = bindAny(saga, ["addStep", "add", "step", "register"])!;
          const run = bindAny(saga, ["run", "execute", "start", "dispatch"])!;
          addStep({
            execute: async () => { results.push("s1"); },
            compensate: async () => { results.push("c1"); }
          });
          addStep({
            execute: async () => { results.push("s2"); },
            compensate: async () => { results.push("c2"); }
          });
          await run();
          expect(results).toEqual(["s1", "s2"]);
          expect(isSagaStatus(saga.status, "COMPLETED")).toBe(true);
        });

        it("compensates on failure", async () => {
          const results: string[] = [];
          const saga = createSaga();
          expect(saga).not.toBeUndefined();
          const addStep = bindAny(saga, ["addStep", "add", "step", "register"])!;
          const run = bindAny(saga, ["run", "execute", "start", "dispatch"])!;
          addStep({
            execute: async () => { results.push("s1"); },
            compensate: async () => { results.push("c1"); }
          });
          addStep({
            execute: async () => { throw new Error("fail"); },
            compensate: async () => { results.push("c2"); }
          });
          await run();
          expect(results).toContain("c1");
          expect(isSagaStatus(saga.status, "COMPENSATED")).toBe(true);
        });

        it("compensates in reverse order", async () => {
          const results: string[] = [];
          const saga = createSaga();
          expect(saga).not.toBeUndefined();
          saga.addStep({
            execute: async () => { results.push("s1"); },
            compensate: async () => { results.push("c1"); }
          });
          saga.addStep({
            execute: async () => { results.push("s2"); },
            compensate: async () => { results.push("c2"); }
          });
          saga.addStep({
            execute: async () => { throw new Error("fail"); },
            compensate: async () => {}
          });
          await saga.run();
          const compIdx1 = results.indexOf("c1");
          const compIdx2 = results.indexOf("c2");
          expect(compIdx2).toBeLessThan(compIdx1); // c2 before c1
        });
      });


- id: ts_agent_L4_api_gateway
  lang: typescript
  prompt: |
    APIゲートウェイを実装してください。解説不要、コードのみ。

    要件:
    - ルートベースのリクエストルーティング
    - 認証/認可ミドルウェア
    - レート制限
    - リクエスト/レスポンス変換
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import * as solution from "../solution";
      import { pickValue, safe } from "./_flex";

      type Request = any;
      type Response = any;

      const GatewayCtor = pickValue(solution as any, ["Gateway", "APIGateway", "ApiGateway"]);

      function createGW() {
        return safe(() => new (GatewayCtor as any)()) ?? safe(() => (GatewayCtor as any)()) ?? undefined;
      }

      describe("Gateway", () => {
        it("routes to handler", async () => {
          const gw = createGW();
          expect(gw).not.toBeUndefined();
          const route = bindAny(gw, ["route", "add", "register", "get", "handle"])!;
          const handle = bindAny(gw, ["handle", "process", "request", "dispatch"])!;
          route("GET", "/users", async () => ({ status: 200, body: [] }));
          const res = await handle({ method: "GET", path: "/users" });
          expect(res.status).toBe(200);
        });

        it("extracts path params", async () => {
          const gw = createGW();
          expect(gw).not.toBeUndefined();
          const route = bindAny(gw, ["route", "add", "register", "get", "handle"])!;
          const handle = bindAny(gw, ["handle", "process", "request", "dispatch"])!;
          route("GET", "/users/:id", async (req: any) => ({
            status: 200,
            body: { id: req.params.id }
          }));
          const res = await handle({ method: "GET", path: "/users/123" });
          expect(res.body.id).toBe("123");
        });

        it("applies auth middleware", async () => {
          const gw = createGW();
          expect(gw).not.toBeUndefined();
          const route = bindAny(gw, ["route", "add", "register", "get", "handle"])!;
          const handle = bindAny(gw, ["handle", "process", "request", "dispatch"])!;
          const use = bindAny(gw, ["use", "middleware", "addMiddleware"])!;
          use(async (req: any, next: any) => {
            if (!req.headers?.["Authorization"]) {
              return { status: 401, body: { error: "Unauthorized" } };
            }
            return next();
          });
          route("GET", "/protected", async () => ({ status: 200, body: {} }));
          const res = await handle({ method: "GET", path: "/protected" });
          expect(res.status).toBe(401);
        });

        it("applies rate limiting", async () => {
          const gw = createGW();
          expect(gw).not.toBeUndefined();
          const route = bindAny(gw, ["route", "add", "register", "get", "handle"])!;
          const handle = bindAny(gw, ["handle", "process", "request", "dispatch"])!;
          const rateLimit = bindAny(gw, ["rateLimit", "limit", "throttle"])!;
          rateLimit({ maxRequests: 2, windowMs: 1000 });
          route("GET", "/api", async () => ({ status: 200, body: {} }));
          await handle({ method: "GET", path: "/api", clientId: "c1" });
          await handle({ method: "GET", path: "/api", clientId: "c1" });
          const res = await handle({ method: "GET", path: "/api", clientId: "c1" });
          expect(res.status).toBe(429);
        });

        it("returns 404 for unknown routes", async () => {
          const gw = createGW();
          expect(gw).not.toBeUndefined();
          const handle = bindAny(gw, ["handle", "process", "request", "dispatch"])!;
          const res = await handle({ method: "GET", path: "/unknown" });
          expect(res.status).toBe(404);
        });
      });


- id: ts_agent_L4_cqrs
  lang: typescript
  prompt: |
    CQRS（Command Query Responsibility Segregation）を実装してください。解説不要、コードのみ。

    要件:
    - コマンドハンドラ（書き込み）
    - クエリハンドラ（読み取り）
    - コマンドとクエリの分離
    - 型安全なコマンド/クエリ定義
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import * as solution from "../solution";
      import { pickValue, safe, bindAny } from "./_flex";

      const AppCtor = pickValue(solution as any, ["CQRSApp", "CqrsApp", "App"]);
      const CreateUserCommand = pickValue(solution as any, ["CreateUserCommand", "CreateUser"]);
      const GetUserQuery = pickValue(solution as any, ["GetUserQuery", "GetUser"]);
      const ListUsersQuery = pickValue(solution as any, ["ListUsersQuery", "ListUsers"]);

      function createApp() {
        return safe(() => new (AppCtor as any)()) ?? safe(() => (AppCtor as any)()) ?? undefined;
      }

      function cmdCreate(id: string, name: string) {
        if (CreateUserCommand) return safe(() => new (CreateUserCommand as any)(id, name)) ?? { type: "CreateUser", id, name };
        return { type: "CreateUser", id, name };
      }
      function qryGet(id: string) {
        if (GetUserQuery) return safe(() => new (GetUserQuery as any)(id)) ?? { type: "GetUser", id };
        return { type: "GetUser", id };
      }
      function qryList() {
        if (ListUsersQuery) return safe(() => new (ListUsersQuery as any)()) ?? { type: "ListUsers" };
        return { type: "ListUsers" };
      }

      async function exec(app: any, cmd: any) {
        const fn = bindAny(app, ["execute", "dispatch", "command", "handle"])!;
        return fn(cmd);
      }
      async function query(app: any, q: any) {
        const fn = bindAny(app, ["query", "read", "ask", "execute", "dispatch", "handle"])!;
        return fn(q);
      }

      describe("CQRS", () => {
        it("executes command", async () => {
          const app = createApp();
          expect(app).not.toBeUndefined();
          const result = await exec(app, cmdCreate("u1", "Alice"));
          expect(result.success).toBe(true);
        });

        it("executes query", async () => {
          const app = createApp();
          expect(app).not.toBeUndefined();
          await exec(app, cmdCreate("u1", "Alice"));
          const user = await query(app, qryGet("u1"));
          expect(user.name).toBe("Alice");
        });

        it("lists users", async () => {
          const app = createApp();
          expect(app).not.toBeUndefined();
          await exec(app, cmdCreate("u1", "Alice"));
          await exec(app, cmdCreate("u2", "Bob"));
          const users = await query(app, qryList());
          expect(users.length).toBe(2);
        });

        it("separates read and write models", async () => {
          const app = createApp();
          expect(app).not.toBeUndefined();
          await exec(app, cmdCreate("u1", "Alice"));
          const user1 = await query(app, qryGet("u1"));
          const user2 = await query(app, qryGet("u1"));
          expect(user1).toEqual(user2);
        });
      });


- id: ts_agent_L4_distributed_lock
  lang: typescript
  prompt: |
    分散ロックマネージャーを実装してください。解説不要、コードのみ。

    要件:
    - クラス名: `LockManager` を export すること
    - メソッド:
      - `acquire(resource: string, owner: string, ttl: number): Promise<boolean>`
      - `release(resource: string, owner: string): Promise<void>`
    - 機能:
      - ロックの取得と解放
      - TTL（有効期限）による自動解放
      - 所有者の検証
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import * as solution from "../solution";

      const LockManager = (solution as any).LockManager;
      const sleep = (ms: number) => new Promise(r => setTimeout(r, ms));

      describe("LockManager", () => {
        if (!LockManager) {
          it("exports LockManager class", () => {
            expect(LockManager).toBeDefined();
          });
          return;
        }

        it("acquires and releases lock", async () => {
          const manager = new LockManager();
          const acquired = await manager.acquire("res1", "owner1", 1000);
          expect(acquired).toBe(true);
          await manager.release("res1", "owner1");
          // can acquire again
          const acquired2 = await manager.acquire("res1", "owner2", 1000);
          expect(acquired2).toBe(true);
        });

        it("blocks concurrent acquire", async () => {
          const manager = new LockManager();
          await manager.acquire("res1", "owner1", 1000);
          const acquired = await manager.acquire("res1", "owner2", 1000);
          expect(acquired).toBe(false);
        });

        it("expires after TTL", async () => {
          const manager = new LockManager();
          await manager.acquire("res1", "owner1", 50);
          await sleep(60);
          const acquired = await manager.acquire("res1", "owner2", 1000);
          expect(acquired).toBe(true);
        });
      });
# =============================================================================
# TypeScript固有の強み: 高度な型システム
# =============================================================================

- id: ts_conditional_types
  lang: typescript
  prompt: |
    Conditional Typesを使った型ユーティリティを実装。解説不要、コードのみ。
    - Flatten<T> - 配列なら要素型、そうでなければT
    - MyNonNullable<T> - nullとundefinedを除去（自作）
    - ReturnTypeOf<T> - 関数の戻り値型を取得（自作）
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import type { Flatten, MyNonNullable, ReturnTypeOf } from "../solution";
      describe("Conditional Types", () => {
        it("Flatten works", () => {
          type A = Flatten<string[]>;
          type B = Flatten<number>;
          const a: A = "test";
          const b: B = 42;
          expect(typeof a).toBe("string");
          expect(typeof b).toBe("number");
        });
        it("MyNonNullable works", () => {
          type A = MyNonNullable<string | null | undefined>;
          const a: A = "test";
          expect(a).toBe("test");
        });
        it("ReturnTypeOf works", () => {
          type Fn = () => { id: number };
          type R = ReturnTypeOf<Fn>;
          const r: R = { id: 1 };
          expect(r.id).toBe(1);
        });
      });

- id: ts_mapped_types
  lang: typescript
  prompt: |
    Mapped Typesを使った型ユーティリティを実装。解説不要、コードのみ。
    - MyReadonly<T> - 全プロパティをreadonly（自作）
    - MyPartial<T> - 全プロパティをoptional（自作）
    - MyRequired<T> - 全プロパティを必須（自作）
    - Mutable<T> - readonlyを除去
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import type { MyReadonly, MyPartial, MyRequired, Mutable } from "../solution";
      describe("Mapped Types", () => {
        it("MyReadonly works", () => {
          type User = { name: string };
          type RO = MyReadonly<User>;
          const u: RO = { name: "test" };
          expect(u.name).toBe("test");
        });
        it("MyPartial works", () => {
          type User = { name: string; age: number };
          type P = MyPartial<User>;
          const u: P = { name: "test" };
          expect(u.name).toBe("test");
        });
        it("MyRequired works", () => {
          type User = { name?: string };
          type R = MyRequired<User>;
          const u: R = { name: "test" };
          expect(u.name).toBe("test");
        });
        it("Mutable works", () => {
          type RO = { readonly name: string };
          type M = Mutable<RO>;
          const u: M = { name: "test" };
          u.name = "changed";
          expect(u.name).toBe("changed");
        });
      });

- id: ts_template_literal
  lang: typescript
  prompt: |
    Template Literal Typesを使った型を実装。解説不要、コードのみ。
    - EventName<T> - "on" + Capitalize<T> (例: "click" → "onClick")
    - toEventName(event: string): string
    - PathParams<T> - URLパスからパラメータ抽出
    - extractParams(pattern: string, path: string): Record<string, string>
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import type { EventName, PathParams } from "../solution";
      import * as solution from "../solution";
      import { pickFn } from "./_flex";

      const toEventName = pickFn(solution as any, ["toEventName", "to_event_name"]);
      const extractParams = pickFn(solution as any, ["extractParams", "extract_params", "matchParams"]);
      describe("Template Literal Types", () => {
        it("EventName type", () => {
          type E = EventName<"click">;
          const e: E = "onClick";
          expect(e).toBe("onClick");
        });
        it("toEventName function", () => {
          expect((toEventName as any)("click")).toBe("onClick");
          expect((toEventName as any)("mouseOver")).toBe("onMouseOver");
        });
        it("extractParams function", () => {
          const params = (extractParams as any)("/users/:id", "/users/123");
          expect(params.id).toBe("123");
        });
      });

- id: ts_discriminated_union
  lang: typescript
  prompt: |
    Discriminated Unionを使ったパターンマッチングを実装。解説不要、コードのみ。
    - type Action = { type: "INCREMENT" } | { type: "DECREMENT" } | { type: "SET"; value: number }
    - reducer(state: number, action: Action): number
    - increment(), decrement(), set(value) アクションクリエーター
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import * as solution from "../solution";
      import { pickFn } from "./_flex";

      const reducer = pickFn(solution as any, ["reducer"]);
      const increment = pickFn(solution as any, ["increment"], (fn) => fn()?.type === "INCREMENT") ?? (() => ({ type: "INCREMENT" }));
      const decrement = pickFn(solution as any, ["decrement"], (fn) => fn()?.type === "DECREMENT") ?? (() => ({ type: "DECREMENT" }));
      const set = pickFn(solution as any, ["set"], (fn) => fn(1)?.type === "SET") ?? ((value: number) => ({ type: "SET", value }));
      type Action = any;
      describe("Discriminated Union", () => {
        it("handles INCREMENT", () => {
          expect((reducer as any)(0, (increment as any)())).toBe(1);
        });
        it("handles DECREMENT", () => {
          expect((reducer as any)(5, (decrement as any)())).toBe(4);
        });
        it("handles SET", () => {
          expect((reducer as any)(0, (set as any)(10))).toBe(10);
        });
        it("type safety", () => {
          const action: Action = { type: "SET", value: 42 };
          expect((reducer as any)(0, action)).toBe(42);
        });
      });

# React風パターン
- id: ts_react_hooks
  lang: typescript
  prompt: |
    React風のカスタムフックを実装（Reactなし）。解説不要、コードのみ。
    - useState<T>(initial: T): [T, (v: T | ((prev: T) => T)) => void]
    - useMemo<T>(factory: () => T, deps: any[]): T
    - resetHooks(): void
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect, beforeEach } from "vitest";
      import * as solution from "../solution";
      import { pickFn } from "./_flex";

      const useState = pickFn(solution as any, ["useState", "use_state"]);
      const useMemo = pickFn(solution as any, ["useMemo", "use_memo"]);
      const resetHooks = pickFn(solution as any, ["resetHooks", "reset", "reset_hooks"]);
      describe("React Hooks", () => {
        beforeEach(() => (resetHooks as any)());
        it("useState returns state and setter", () => {
          const [count, setCount] = (useState as any)(0);
          expect(count).toBe(0);
          setCount(5);
          const [count2] = (useState as any)(0);
          expect(count2).toBe(5);
        });
        it("useState with updater function", () => {
          const [count, setCount] = (useState as any)(10);
          setCount(prev => prev + 1);
          const [count2] = (useState as any)(0);
          expect(count2).toBe(11);
        });
        it("useMemo caches value", () => {
          let calls = 0;
          const value = (useMemo as any)(() => { calls++; return 42; }, [1]);
          const value2 = (useMemo as any)(() => { calls++; return 42; }, [1]);
          expect(calls).toBe(1);
        });
      });

# Express風パターン
- id: ts_express_middleware
  lang: typescript
  prompt: |
    Express風のミドルウェアシステムを実装。解説不要、コードのみ。
    - createApp() でアプリ作成
    - app.use(middleware), app.get(path, handler), app.post(path, handler)
    - app.handle(req) でリクエスト処理
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import * as solution from "../solution";
      import { pickFn } from "./_flex";

      const createApp = pickFn(solution as any, ["createApp", "create_app", "app"]);
      describe("Express-like App", () => {
        it("handles GET request", async () => {
          const app = (createApp as any)();
          app.get("/users", (req, res) => { res.json([{ id: 1 }]); });
          const res = await app.handle({ method: "GET", path: "/users" });
          expect(res.body).toEqual([{ id: 1 }]);
        });
        it("extracts params", async () => {
          const app = (createApp as any)();
          app.get("/users/:id", (req, res) => { res.json({ id: req.params.id }); });
          const res = await app.handle({ method: "GET", path: "/users/123" });
          expect(res.body.id).toBe("123");
        });
        it("runs middleware", async () => {
          const app = (createApp as any)();
          const logs: string[] = [];
          app.use((req, res, next) => { logs.push("m1"); next(); });
          app.get("/test", (req, res) => { res.json({ ok: true }); });
          await app.handle({ method: "GET", path: "/test" });
          expect(logs).toContain("m1");
        });
      });

# Zod風バリデーション
- id: ts_validation_schema
  lang: typescript
  prompt: |
    Zod風のバリデーションスキーマを実装。解説不要、コードのみ。
    - z.string(), z.number(), z.boolean()
    - z.object({...}), z.array(schema)
    - .optional(), .parse(data)
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import * as solution from "../solution";
      import { pickValue } from "./_flex";

      const z = pickValue(solution as any, ["z", "schema", "Schema"]);
      describe("Validation Schema", () => {
        it("validates string", () => {
          const schema = z.string();
          expect(schema.parse("hello")).toBe("hello");
          expect(() => schema.parse(123)).toThrow();
        });
        it("validates object", () => {
          const schema = z.object({ name: z.string(), age: z.number() });
          const result = schema.parse({ name: "Alice", age: 30 });
          expect(result.name).toBe("Alice");
        });
        it("validates array", () => {
          const schema = z.array(z.number());
          expect(schema.parse([1, 2, 3])).toEqual([1, 2, 3]);
        });
        it("handles optional", () => {
          const schema = z.object({ name: z.string(), age: z.number().optional() });
          const result = schema.parse({ name: "Bob" });
          expect(result.name).toBe("Bob");
        });
      });

# バグ修正問題
- id: ts_this_binding_bug
  lang: typescript
  prompt: |
    thisバインディングバグを修正。解説不要、コードのみ。
    問題: クラスメソッドをコールバックとして渡すとthisが失われる
    class Counter { count = 0; increment() { this.count++; } getCount() { return this.count; } }
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import * as solution from "../solution";
      import { pickValue, safe } from "./_flex";

      const Counter = pickValue(solution as any, ["Counter"]);
      describe("Counter this binding", () => {
        it("works with direct call", () => {
          const c = safe(() => new (Counter as any)());
          expect(c).not.toBeUndefined();
          c.increment();
          expect(c.getCount()).toBe(1);
        });
        it("works as callback", async () => {
          const c = safe(() => new (Counter as any)());
          expect(c).not.toBeUndefined();
          await new Promise<void>(resolve => {
            setTimeout(() => { c.increment(); resolve(); }, 0);
          });
          expect(c.getCount()).toBe(1);
        });
        it("works with array methods", () => {
          const c = safe(() => new (Counter as any)());
          expect(c).not.toBeUndefined();
          [1, 2, 3].forEach(c.increment);
          expect(c.getCount()).toBe(3);
        });
      });

- id: ts_equality_bug
  lang: typescript
  prompt: |
    等価性チェックのバグを修正。解説不要、コードのみ。
    問題: オブジェクトの等価性を正しく比較できない
    元コード: function isEqual(a: any, b: any) { return a == b; }
    期待: 深い比較で正しく判定
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import * as solution from "../solution";
      import { pickFn } from "./_flex";

      const isEqual = pickFn(solution as any, ["isEqual", "deepEqual", "equals"]);
      describe("isEqual", () => {
        it("compares primitives", () => {
          expect((isEqual as any)(1, 1)).toBe(true);
          expect((isEqual as any)(1, 2)).toBe(false);
        });
        it("compares objects", () => {
          expect((isEqual as any)({ a: 1 }, { a: 1 })).toBe(true);
          expect((isEqual as any)({ a: 1 }, { a: 2 })).toBe(false);
        });
        it("compares nested objects", () => {
          expect((isEqual as any)({ a: { b: 1 } }, { a: { b: 1 } })).toBe(true);
        });
        it("compares arrays", () => {
          expect((isEqual as any)([1, 2], [1, 2])).toBe(true);
          expect((isEqual as any)([1, 2], [1, 3])).toBe(false);
        });
      });
