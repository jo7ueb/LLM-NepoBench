# =============================================================================
# TypeScript ベンチマーク問題集
# カテゴリ: 型安全, 非同期処理, API設計, OOP, ジェネリクス, etc.
# 各問題に複数テストケースを含み、部分点評価が可能
#
# 難易度レベル (エージェント問題):
#   Level 1 (★☆☆☆) - Easy:    基本的な設計判断、少しだけ曖昧な要件
#   Level 2 (★★☆☆) - Medium:  中程度の曖昧さ、複数の設計判断が必要
#   Level 3 (★★★☆) - Hard:    複雑な設計判断、複数の技術領域にまたがる
#   Level 4 (★★★★) - Expert:  実務レベルの複雑な問題、多くの考慮事項
# =============================================================================

# -----------------------------------------------------------------------------
# カテゴリ: 型安全 / Type Safety
# -----------------------------------------------------------------------------

- id: ts_typesafety
  lang: typescript
  prompt: |
    TypeScriptで型安全にリファクタしてください。解説不要、コードのみ。

    エクスポート:
    - export type User = { name: string; age: number }
    - export function processUser(user: User): { upperName: string; agePlus10: number }

    要件:
    - any を使わない
    - user.name を大文字化して upperName に
    - user.age + 10 を agePlus10 に

    元コード:
    function processUser(user: any) {
        console.log(user.name.toUpperCase());
        return user.age + 10;
    }
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import { processUser, type User } from "../solution";

      describe("processUser", () => {
        it("returns upperName", () => {
          const u: User = { name: "alice", age: 20 };
          const r = processUser(u);
          expect(r.upperName).toBe("ALICE");
        });

        it("returns agePlus10", () => {
          const u: User = { name: "bob", age: 25 };
          const r = processUser(u);
          expect(r.agePlus10).toBe(35);
        });

        it("handles mixed case", () => {
          const u: User = { name: "ChArLiE", age: 30 };
          const r = processUser(u);
          expect(r.upperName).toBe("CHARLIE");
        });

        it("handles zero age", () => {
          const u: User = { name: "dave", age: 0 };
          const r = processUser(u);
          expect(r.agePlus10).toBe(10);
        });
      });


- id: ts_type_guard
  lang: typescript
  prompt: |
    TypeScriptで型ガード関数を実装してください。解説不要、コードのみ。

    仕様:
    - isString(value: unknown): value is string
    - isNumber(value: unknown): value is number
    - isUser(value: unknown): value is User （User = { name: string, email: string }）
    - すべてexportする
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import { isString, isNumber, isUser } from "../solution";

      describe("isString", () => {
        it("returns true for string", () => {
          expect(isString("hello")).toBe(true);
        });
        it("returns false for number", () => {
          expect(isString(123)).toBe(false);
        });
        it("returns false for null", () => {
          expect(isString(null)).toBe(false);
        });
      });

      describe("isNumber", () => {
        it("returns true for number", () => {
          expect(isNumber(42)).toBe(true);
        });
        it("returns false for string", () => {
          expect(isNumber("42")).toBe(false);
        });
        it("returns true for zero", () => {
          expect(isNumber(0)).toBe(true);
        });
      });

      describe("isUser", () => {
        it("returns true for valid user", () => {
          expect(isUser({ name: "Alice", email: "alice@example.com" })).toBe(true);
        });
        it("returns false for missing email", () => {
          expect(isUser({ name: "Bob" })).toBe(false);
        });
        it("returns false for null", () => {
          expect(isUser(null)).toBe(false);
        });
        it("returns false for wrong types", () => {
          expect(isUser({ name: 123, email: "test@test.com" })).toBe(false);
        });
      });


- id: ts_generic_function
  lang: typescript
  prompt: |
    ジェネリック関数を実装してください。解説不要、コードのみ。

    仕様:
    - first<T>(arr: T[]): T | undefined - 配列の最初の要素を返す
    - last<T>(arr: T[]): T | undefined - 配列の最後の要素を返す
    - unique<T>(arr: T[]): T[] - 重複を除去した配列を返す
    - groupBy<T, K extends string | number>(arr: T[], keyFn: (item: T) => K): Record<K, T[]>
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import { first, last, unique, groupBy } from "../solution";

      describe("first", () => {
        it("returns first element", () => {
          expect(first([1, 2, 3])).toBe(1);
        });
        it("returns undefined for empty", () => {
          expect(first([])).toBeUndefined();
        });
      });

      describe("last", () => {
        it("returns last element", () => {
          expect(last([1, 2, 3])).toBe(3);
        });
        it("returns undefined for empty", () => {
          expect(last([])).toBeUndefined();
        });
      });

      describe("unique", () => {
        it("removes duplicates", () => {
          expect(unique([1, 2, 2, 3, 3, 3])).toEqual([1, 2, 3]);
        });
        it("handles strings", () => {
          expect(unique(["a", "b", "a"])).toEqual(["a", "b"]);
        });
        it("handles empty", () => {
          expect(unique([])).toEqual([]);
        });
      });

      describe("groupBy", () => {
        it("groups by key", () => {
          const items = [
            { name: "a", type: "x" },
            { name: "b", type: "y" },
            { name: "c", type: "x" },
          ];
          const result = groupBy(items, (i) => i.type);
          expect(result["x"].length).toBe(2);
          expect(result["y"].length).toBe(1);
        });
      });


# -----------------------------------------------------------------------------
# カテゴリ: 非同期処理 / Async
# -----------------------------------------------------------------------------

- id: ts_async_wait
  lang: typescript
  prompt: |
    TypeScriptで次の関数を修正してください（解説不要、コードのみ）。
    バグ: forEach内のawaitが効かず、処理完了前にDone相当が発生します。

    エクスポート:
    - export async function saveAll(items: string[], save: (item: string) => Promise<void>): Promise<void>

    要件:
    - items 配列の各要素に対して save 関数を呼び出す
    - 全件の save が完了してから resolve する
    - forEach は使わない（for...of または Promise.all を使用）

    参考(バグコード):
    async function saveAll(items: string[], save: (item: string) => Promise<void>) {
        items.forEach(async (item) => {
            await save(item);
        });
    }
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import { saveAll } from "../solution";

      const sleep = (ms: number) => new Promise((r) => setTimeout(r, ms));

      describe("saveAll", () => {
        it("waits for all saves", async () => {
          const calls: string[] = [];
          const save = async (item: string) => {
            await sleep(20);
            calls.push(item);
          };
          await saveAll(["a", "b", "c"], save);
          expect(calls.sort()).toEqual(["a", "b", "c"]);
        });

        it("executes in reasonable time", async () => {
          const save = async (item: string) => { await sleep(10); };
          const t0 = Date.now();
          await saveAll(["a", "b"], save);
          const dt = Date.now() - t0;
          expect(dt).toBeGreaterThanOrEqual(10);
        });

        it("handles empty array", async () => {
          const calls: string[] = [];
          const save = async (item: string) => { calls.push(item); };
          await saveAll([], save);
          expect(calls).toEqual([]);
        });
      });


- id: ts_promise_retry
  lang: typescript
  prompt: |
    リトライ機能付きの関数を実装してください。解説不要、コードのみ。

    仕様:
    - retry<T>(fn: () => Promise<T>, maxAttempts: number): Promise<T>
    - 失敗したらmaxAttempts回まで再試行
    - 全て失敗したら最後のエラーをthrow
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import { retry } from "../solution";

      describe("retry", () => {
        it("returns on first success", async () => {
          const result = await retry(() => Promise.resolve("ok"), 3);
          expect(result).toBe("ok");
        });

        it("retries on failure", async () => {
          let attempts = 0;
          const fn = () => {
            attempts++;
            if (attempts < 3) return Promise.reject(new Error("fail"));
            return Promise.resolve("success");
          };
          const result = await retry(fn, 3);
          expect(result).toBe("success");
          expect(attempts).toBe(3);
        });

        it("throws after max attempts", async () => {
          const fn = () => Promise.reject(new Error("always fails"));
          await expect(retry(fn, 2)).rejects.toThrow("always fails");
        });

        it("passes with single attempt allowed", async () => {
          const result = await retry(() => Promise.resolve(42), 1);
          expect(result).toBe(42);
        });
      });


- id: ts_promise_all_settled
  lang: typescript
  prompt: |
    Promise.allSettledのようなユーティリティを実装してください。解説不要、コードのみ。

    仕様:
    - settleAll<T>(promises: Promise<T>[]): Promise<SettledResult<T>[]>
    - SettledResult<T> = { status: "fulfilled", value: T } | { status: "rejected", reason: any }
    - すべてのPromiseが完了するまで待つ（失敗しても他を待つ）
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import { settleAll, type SettledResult } from "../solution";

      describe("settleAll", () => {
        it("handles all fulfilled", async () => {
          const results = await settleAll([
            Promise.resolve(1),
            Promise.resolve(2),
          ]);
          expect(results[0]).toEqual({ status: "fulfilled", value: 1 });
          expect(results[1]).toEqual({ status: "fulfilled", value: 2 });
        });

        it("handles all rejected", async () => {
          const results = await settleAll([
            Promise.reject(new Error("e1")),
            Promise.reject(new Error("e2")),
          ]);
          expect(results[0].status).toBe("rejected");
          expect(results[1].status).toBe("rejected");
        });

        it("handles mixed", async () => {
          const results = await settleAll([
            Promise.resolve("ok"),
            Promise.reject(new Error("fail")),
          ]);
          expect(results[0]).toEqual({ status: "fulfilled", value: "ok" });
          expect(results[1].status).toBe("rejected");
        });

        it("handles empty array", async () => {
          const results = await settleAll([]);
          expect(results).toEqual([]);
        });
      });


# -----------------------------------------------------------------------------
# カテゴリ: データ処理 / Data Processing
# -----------------------------------------------------------------------------

- id: ts_array_utils
  lang: typescript
  prompt: |
    配列ユーティリティ関数を実装してください。解説不要、コードのみ。

    仕様:
    - chunk<T>(arr: T[], size: number): T[][] - 配列をsize個ずつに分割
    - flatten<T>(arr: (T | T[])[]): T[] - 1レベルのネストを平坦化
    - zip<T, U>(arr1: T[], arr2: U[]): [T, U][] - 2つの配列をペアにする
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import { chunk, flatten, zip } from "../solution";

      describe("chunk", () => {
        it("splits array into chunks", () => {
          expect(chunk([1, 2, 3, 4, 5], 2)).toEqual([[1, 2], [3, 4], [5]]);
        });
        it("handles exact division", () => {
          expect(chunk([1, 2, 3, 4], 2)).toEqual([[1, 2], [3, 4]]);
        });
        it("handles empty array", () => {
          expect(chunk([], 3)).toEqual([]);
        });
        it("handles size larger than array", () => {
          expect(chunk([1, 2], 5)).toEqual([[1, 2]]);
        });
      });

      describe("flatten", () => {
        it("flattens one level", () => {
          expect(flatten([1, [2, 3], 4])).toEqual([1, 2, 3, 4]);
        });
        it("handles already flat", () => {
          expect(flatten([1, 2, 3])).toEqual([1, 2, 3]);
        });
        it("handles empty", () => {
          expect(flatten([])).toEqual([]);
        });
      });

      describe("zip", () => {
        it("zips two arrays", () => {
          expect(zip([1, 2], ["a", "b"])).toEqual([[1, "a"], [2, "b"]]);
        });
        it("handles different lengths", () => {
          expect(zip([1, 2, 3], ["a"])).toEqual([[1, "a"]]);
        });
        it("handles empty", () => {
          expect(zip([], [])).toEqual([]);
        });
      });


- id: ts_object_utils
  lang: typescript
  prompt: |
    オブジェクトユーティリティ関数を実装してください。解説不要、コードのみ。

    仕様:
    - pick<T, K extends keyof T>(obj: T, keys: K[]): Pick<T, K>
    - omit<T, K extends keyof T>(obj: T, keys: K[]): Omit<T, K>
    - merge<T>(target: T, source: Partial<T>): T
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import { pick, omit, merge } from "../solution";

      describe("pick", () => {
        it("picks specified keys", () => {
          const obj = { a: 1, b: 2, c: 3 };
          expect(pick(obj, ["a", "c"])).toEqual({ a: 1, c: 3 });
        });
        it("handles empty keys", () => {
          const obj = { a: 1 };
          expect(pick(obj, [])).toEqual({});
        });
      });

      describe("omit", () => {
        it("omits specified keys", () => {
          const obj = { a: 1, b: 2, c: 3 };
          expect(omit(obj, ["b"])).toEqual({ a: 1, c: 3 });
        });
        it("handles empty keys", () => {
          const obj = { a: 1 };
          expect(omit(obj, [])).toEqual({ a: 1 });
        });
      });

      describe("merge", () => {
        it("merges objects", () => {
          const target = { a: 1, b: 2 };
          const source = { b: 3 };
          expect(merge(target, source)).toEqual({ a: 1, b: 3 });
        });
        it("handles empty source", () => {
          const target = { a: 1 };
          expect(merge(target, {})).toEqual({ a: 1 });
        });
      });


# -----------------------------------------------------------------------------
# カテゴリ: OOP / クラス設計
# -----------------------------------------------------------------------------

- id: ts_event_emitter
  lang: typescript
  prompt: |
    イベントエミッターを実装してください。解説不要、コードのみ。

    仕様:
    - class EventEmitter<Events extends Record<string, any>>
    - on<K extends keyof Events>(event: K, listener: (data: Events[K]) => void): void
    - off<K extends keyof Events>(event: K, listener: (data: Events[K]) => void): void
    - emit<K extends keyof Events>(event: K, data: Events[K]): void
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import { EventEmitter } from "../solution";

      type Events = {
        message: string;
        count: number;
      };

      describe("EventEmitter", () => {
        it("emits to listeners", () => {
          const emitter = new EventEmitter<Events>();
          const messages: string[] = [];
          emitter.on("message", (m) => messages.push(m));
          emitter.emit("message", "hello");
          expect(messages).toEqual(["hello"]);
        });

        it("handles multiple listeners", () => {
          const emitter = new EventEmitter<Events>();
          const results: number[] = [];
          emitter.on("count", (n) => results.push(n));
          emitter.on("count", (n) => results.push(n * 2));
          emitter.emit("count", 5);
          expect(results).toContain(5);
          expect(results).toContain(10);
        });

        it("removes listener with off", () => {
          const emitter = new EventEmitter<Events>();
          const messages: string[] = [];
          const listener = (m: string) => messages.push(m);
          emitter.on("message", listener);
          emitter.off("message", listener);
          emitter.emit("message", "test");
          expect(messages).toEqual([]);
        });

        it("handles no listeners", () => {
          const emitter = new EventEmitter<Events>();
          expect(() => emitter.emit("message", "test")).not.toThrow();
        });
      });


- id: ts_result_type
  lang: typescript
  prompt: |
    Result型（RustのResult相当）を実装してください。解説不要、コードのみ。

    仕様:
    - type Result<T, E> = Ok<T> | Err<E>
    - class Ok<T> { constructor(value: T); isOk(): true; isErr(): false; unwrap(): T }
    - class Err<E> { constructor(error: E); isOk(): false; isErr(): true; unwrap(): never }
    - ok<T>(value: T): Ok<T>
    - err<E>(error: E): Err<E>
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import { ok, err, type Result } from "../solution";

      describe("Result", () => {
        it("ok isOk returns true", () => {
          const result = ok(42);
          expect(result.isOk()).toBe(true);
          expect(result.isErr()).toBe(false);
        });

        it("err isErr returns true", () => {
          const result = err("error");
          expect(result.isErr()).toBe(true);
          expect(result.isOk()).toBe(false);
        });

        it("ok unwrap returns value", () => {
          const result = ok("success");
          expect(result.unwrap()).toBe("success");
        });

        it("err unwrap throws", () => {
          const result = err("failure");
          expect(() => result.unwrap()).toThrow();
        });

        it("works with type narrowing", () => {
          const result: Result<number, string> = ok(10);
          if (result.isOk()) {
            expect(result.unwrap()).toBe(10);
          }
        });
      });


# -----------------------------------------------------------------------------
# カテゴリ: バグ修正 / Bug Fix
# -----------------------------------------------------------------------------

- id: ts_closure_loop_bug
  lang: typescript
  prompt: |
    次のコードにはクロージャとループのバグがあります。修正してください。解説不要、コードのみ。

    問題: すべてのコールバックが同じ値を出力してしまう

    元コード:
    function createCallbacks(items: string[]): (() => string)[] {
        const callbacks: (() => string)[] = [];
        for (var i = 0; i < items.length; i++) {
            callbacks.push(() => items[i]);
        }
        return callbacks;
    }

    期待: 各コールバックはそれぞれの items[i] を返す
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import { createCallbacks } from "../solution";

      describe("createCallbacks", () => {
        it("returns correct values", () => {
          const callbacks = createCallbacks(["a", "b", "c"]);
          expect(callbacks[0]()).toBe("a");
          expect(callbacks[1]()).toBe("b");
          expect(callbacks[2]()).toBe("c");
        });

        it("handles single item", () => {
          const callbacks = createCallbacks(["only"]);
          expect(callbacks[0]()).toBe("only");
        });

        it("handles empty array", () => {
          const callbacks = createCallbacks([]);
          expect(callbacks.length).toBe(0);
        });

        it("callbacks are independent", () => {
          const callbacks = createCallbacks(["x", "y"]);
          const first = callbacks[0]();
          const second = callbacks[1]();
          expect(first).not.toBe(second);
        });
      });


# =============================================================================
# エージェント能力評価問題（Agent-Level Challenges）
# =============================================================================

# =============================================================================
# Level 1 (★☆☆☆) - Easy: 入門レベルのエージェント問題
# =============================================================================

- id: ts_agent_L1_storage
  lang: typescript
  prompt: |
    シンプルなKey-Valueストレージを実装してください。解説不要、コードのみ。

    エクスポート:
    - export class Storage
      - set(key: string, value: any, options?: { ttl?: number }): void  // ttl はミリ秒
      - get(key: string): any | undefined
      - delete(key: string): void
      - has(key: string): boolean

    要件:
    - キーと値の保存・取得・削除
    - TTL経過後は get で undefined を返す
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import { Storage } from "../solution";

      describe("Storage", () => {
        it("sets and gets value", () => {
          const storage = new Storage();
          storage.set("key", "value");
          expect(storage.get("key")).toBe("value");
        });

        it("returns undefined for missing key", () => {
          const storage = new Storage();
          expect(storage.get("missing")).toBeUndefined();
        });

        it("deletes value", () => {
          const storage = new Storage();
          storage.set("key", "value");
          storage.delete("key");
          expect(storage.get("key")).toBeUndefined();
        });

        it("handles different types", () => {
          const storage = new Storage();
          storage.set("num", 42);
          storage.set("obj", { a: 1 });
          expect(storage.get("num")).toBe(42);
          expect(storage.get("obj")).toEqual({ a: 1 });
        });

        it("supports TTL", async () => {
          const storage = new Storage();
          storage.set("temp", "value", { ttl: 50 });
          expect(storage.get("temp")).toBe("value");
          await new Promise(r => setTimeout(r, 60));
          expect(storage.get("temp")).toBeUndefined();
        });

        it("has method returns boolean", () => {
          const storage = new Storage();
          storage.set("key", "value");
          expect(storage.has("key")).toBe(true);
          expect(storage.has("missing")).toBe(false);
        });
      });


- id: ts_agent_L1_validator
  lang: typescript
  prompt: |
    シンプルなバリデーターを実装してください。解説不要、コードのみ。

    要件:
    - 文字列、数値、メールアドレスのバリデーション
    - エラーメッセージの取得

    使いやすいAPIを設計してください。
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import { Validator } from "../solution";

      describe("Validator", () => {
        it("validates required string", () => {
          const v = new Validator();
          expect(v.string("hello").required().isValid()).toBe(true);
          expect(v.string("").required().isValid()).toBe(false);
        });

        it("validates min length", () => {
          const v = new Validator();
          expect(v.string("hello").minLength(3).isValid()).toBe(true);
          expect(v.string("hi").minLength(3).isValid()).toBe(false);
        });

        it("validates email format", () => {
          const v = new Validator();
          expect(v.string("test@example.com").email().isValid()).toBe(true);
          expect(v.string("invalid").email().isValid()).toBe(false);
        });

        it("validates number range", () => {
          const v = new Validator();
          expect(v.number(5).min(0).max(10).isValid()).toBe(true);
          expect(v.number(15).max(10).isValid()).toBe(false);
        });

        it("returns error messages", () => {
          const v = new Validator();
          const result = v.string("").required();
          expect(result.getErrors().length).toBeGreaterThan(0);
        });

        it("chains validations", () => {
          const v = new Validator();
          const result = v.string("ab").required().minLength(3);
          expect(result.isValid()).toBe(false);
        });
      });


- id: ts_agent_L1_formatter
  lang: typescript
  prompt: |
    データフォーマッターを実装してください。解説不要、コードのみ。

    要件:
    - 日付、数値、通貨のフォーマット
    - ロケール対応（基本的なもので可）
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import { Formatter } from "../solution";

      describe("Formatter", () => {
        it("formats date", () => {
          const f = new Formatter();
          const date = new Date("2024-01-15");
          const result = f.date(date);
          expect(result).toContain("2024");
          expect(result).toContain("01") || expect(result).toContain("1");
        });

        it("formats number with thousands separator", () => {
          const f = new Formatter();
          const result = f.number(1234567);
          expect(result).toContain(",") || expect(result).toContain(" ");
        });

        it("formats currency", () => {
          const f = new Formatter();
          const result = f.currency(1234.56, "USD");
          expect(result).toContain("1234") || expect(result).toContain("1,234");
        });

        it("formats percentage", () => {
          const f = new Formatter();
          const result = f.percentage(0.75);
          expect(result).toContain("75");
        });

        it("handles zero", () => {
          const f = new Formatter();
          expect(f.number(0)).toBe("0");
        });
      });


- id: ts_agent_L1_queue
  lang: typescript
  prompt: |
    シンプルなキュー（FIFO）を実装してください。解説不要、コードのみ。

    要件:
    - エンキュー、デキュー、ピーク
    - サイズ取得、空かどうか判定
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import { Queue } from "../solution";

      describe("Queue", () => {
        it("enqueues and dequeues in order", () => {
          const q = new Queue<number>();
          q.enqueue(1);
          q.enqueue(2);
          q.enqueue(3);
          expect(q.dequeue()).toBe(1);
          expect(q.dequeue()).toBe(2);
          expect(q.dequeue()).toBe(3);
        });

        it("peeks without removing", () => {
          const q = new Queue<string>();
          q.enqueue("first");
          expect(q.peek()).toBe("first");
          expect(q.size()).toBe(1);
        });

        it("returns undefined on empty dequeue", () => {
          const q = new Queue<number>();
          expect(q.dequeue()).toBeUndefined();
        });

        it("tracks size correctly", () => {
          const q = new Queue<number>();
          expect(q.size()).toBe(0);
          q.enqueue(1);
          q.enqueue(2);
          expect(q.size()).toBe(2);
          q.dequeue();
          expect(q.size()).toBe(1);
        });

        it("isEmpty returns correct value", () => {
          const q = new Queue<number>();
          expect(q.isEmpty()).toBe(true);
          q.enqueue(1);
          expect(q.isEmpty()).toBe(false);
        });
      });


- id: ts_agent_L1_logger
  lang: typescript
  prompt: |
    シンプルなロガーを実装してください。解説不要、コードのみ。

    要件:
    - ログレベル（DEBUG, INFO, WARN, ERROR）
    - レベルに応じたフィルタリング
    - タイムスタンプ付きログ
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect, vi } from "vitest";
      import { Logger, LogLevel } from "../solution";

      describe("Logger", () => {
        it("logs info message", () => {
          const output: string[] = [];
          const logger = new Logger({ level: LogLevel.INFO, output: (msg) => output.push(msg) });
          logger.info("test message");
          expect(output.some(o => o.includes("test message"))).toBe(true);
        });

        it("filters below level", () => {
          const output: string[] = [];
          const logger = new Logger({ level: LogLevel.WARN, output: (msg) => output.push(msg) });
          logger.debug("debug");
          logger.info("info");
          logger.warn("warn");
          expect(output.some(o => o.includes("debug"))).toBe(false);
          expect(output.some(o => o.includes("info"))).toBe(false);
          expect(output.some(o => o.includes("warn"))).toBe(true);
        });

        it("includes level in output", () => {
          const output: string[] = [];
          const logger = new Logger({ level: LogLevel.DEBUG, output: (msg) => output.push(msg) });
          logger.error("error message");
          expect(output.some(o => o.includes("ERROR"))).toBe(true);
        });

        it("logs all levels when set to DEBUG", () => {
          const output: string[] = [];
          const logger = new Logger({ level: LogLevel.DEBUG, output: (msg) => output.push(msg) });
          logger.debug("d");
          logger.info("i");
          logger.warn("w");
          logger.error("e");
          expect(output.length).toBe(4);
        });
      });


# =============================================================================
# Level 2 (★★☆☆) - Medium: 中級レベルのエージェント問題
# =============================================================================

- id: ts_agent_L2_http_client
  lang: typescript
  prompt: |
    HTTPクライアントのラッパーを実装してください。解説不要、コードのみ。

    要件:
    - リトライ機能
    - タイムアウト設定
    - 共通ヘッダの設定
    - レスポンスの型安全な取得

    実際の通信は不要。インターフェースとロジックの実装のみ。
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import { HttpClient, type RequestConfig } from "../solution";

      describe("HttpClient", () => {
        it("executes request through transport", async () => {
          const transport = async (url: string, config: RequestConfig) => ({
            status: 200,
            data: { result: "ok" }
          });
          const client = new HttpClient({ transport });
          const response = await client.get("/api/test");
          expect(response.data.result).toBe("ok");
        });

        it("applies default headers", async () => {
          let capturedHeaders: Record<string, string> = {};
          const transport = async (url: string, config: RequestConfig) => {
            capturedHeaders = config.headers || {};
            return { status: 200, data: {} };
          };
          const client = new HttpClient({
            transport,
            defaultHeaders: { "Authorization": "Bearer token" }
          });
          await client.get("/api");
          expect(capturedHeaders["Authorization"]).toBe("Bearer token");
        });

        it("retries on failure", async () => {
          let attempts = 0;
          const transport = async () => {
            attempts++;
            if (attempts < 3) throw new Error("fail");
            return { status: 200, data: {} };
          };
          const client = new HttpClient({ transport, retries: 3 });
          await client.get("/api");
          expect(attempts).toBe(3);
        });

        it("throws after max retries", async () => {
          const transport = async () => { throw new Error("always fails"); };
          const client = new HttpClient({ transport, retries: 2 });
          await expect(client.get("/api")).rejects.toThrow();
        });
      });


- id: ts_agent_L2_state_manager
  lang: typescript
  prompt: |
    シンプルな状態管理ライブラリを実装してください。解説不要、コードのみ。

    要件:
    - 状態の取得・更新
    - 変更の購読（subscribe）
    - セレクター（派生状態）
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import { Store } from "../solution";

      describe("Store", () => {
        it("gets initial state", () => {
          const store = new Store({ count: 0 });
          expect(store.getState().count).toBe(0);
        });

        it("updates state", () => {
          const store = new Store({ count: 0 });
          store.setState({ count: 5 });
          expect(store.getState().count).toBe(5);
        });

        it("notifies subscribers", () => {
          const store = new Store({ count: 0 });
          const values: number[] = [];
          store.subscribe((state) => values.push(state.count));
          store.setState({ count: 1 });
          store.setState({ count: 2 });
          expect(values).toContain(1);
          expect(values).toContain(2);
        });

        it("unsubscribes", () => {
          const store = new Store({ count: 0 });
          const values: number[] = [];
          const unsub = store.subscribe((state) => values.push(state.count));
          store.setState({ count: 1 });
          unsub();
          store.setState({ count: 2 });
          expect(values).toEqual([1]);
        });

        it("supports selectors", () => {
          const store = new Store({ count: 5 });
          const doubled = store.select((state) => state.count * 2);
          expect(doubled()).toBe(10);
        });
      });


- id: ts_agent_L2_router
  lang: typescript
  prompt: |
    シンプルなURLルーターを実装してください。解説不要、コードのみ。

    要件:
    - パスパターンのマッチング（/users/:id など）
    - クエリパラメータの解析
    - ルートハンドラの登録と実行
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import { Router } from "../solution";

      describe("Router", () => {
        it("matches exact path", () => {
          const router = new Router();
          let called = false;
          router.add("/users", () => { called = true; });
          router.navigate("/users");
          expect(called).toBe(true);
        });

        it("extracts path parameters", () => {
          const router = new Router();
          let userId = "";
          router.add("/users/:id", (params) => { userId = params.id; });
          router.navigate("/users/123");
          expect(userId).toBe("123");
        });

        it("handles multiple parameters", () => {
          const router = new Router();
          let params: Record<string, string> = {};
          router.add("/users/:userId/posts/:postId", (p) => { params = p; });
          router.navigate("/users/1/posts/2");
          expect(params.userId).toBe("1");
          expect(params.postId).toBe("2");
        });

        it("parses query parameters", () => {
          const router = new Router();
          let query: Record<string, string> = {};
          router.add("/search", (params, q) => { query = q; });
          router.navigate("/search?q=test&page=1");
          expect(query.q).toBe("test");
          expect(query.page).toBe("1");
        });

        it("returns false for no match", () => {
          const router = new Router();
          router.add("/users", () => {});
          const matched = router.navigate("/posts");
          expect(matched).toBe(false);
        });
      });


- id: ts_agent_L2_task_queue
  lang: typescript
  prompt: |
    非同期タスクキューを実装してください。解説不要、コードのみ。

    要件:
    - タスクの追加と実行
    - 同時実行数の制限（concurrency）
    - 実行状態の追跡
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import { TaskQueue } from "../solution";

      const sleep = (ms: number) => new Promise(r => setTimeout(r, ms));

      describe("TaskQueue", () => {
        it("executes tasks", async () => {
          const queue = new TaskQueue({ concurrency: 2 });
          const results: number[] = [];
          queue.add(async () => { results.push(1); });
          queue.add(async () => { results.push(2); });
          await queue.drain();
          expect(results).toContain(1);
          expect(results).toContain(2);
        });

        it("respects concurrency limit", async () => {
          const queue = new TaskQueue({ concurrency: 1 });
          const order: number[] = [];
          queue.add(async () => { await sleep(30); order.push(1); });
          queue.add(async () => { order.push(2); });
          await queue.drain();
          expect(order).toEqual([1, 2]);
        });

        it("tracks pending count", () => {
          const queue = new TaskQueue({ concurrency: 1 });
          queue.add(async () => sleep(100));
          queue.add(async () => sleep(100));
          expect(queue.pending()).toBeGreaterThanOrEqual(1);
        });

        it("handles errors gracefully", async () => {
          const queue = new TaskQueue({ concurrency: 2 });
          const results: string[] = [];
          queue.add(async () => { throw new Error("fail"); });
          queue.add(async () => { results.push("ok"); });
          await queue.drain();
          expect(results).toContain("ok");
        });
      });


- id: ts_agent_L2_cache
  lang: typescript
  prompt: |
    LRUキャッシュを実装してください。解説不要、コードのみ。

    要件:
    - 最大サイズの制限
    - 最も使われていないアイテムを削除
    - TTL（有効期限）サポート
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import { LRUCache } from "../solution";

      describe("LRUCache", () => {
        it("stores and retrieves values", () => {
          const cache = new LRUCache<string, number>({ maxSize: 3 });
          cache.set("a", 1);
          expect(cache.get("a")).toBe(1);
        });

        it("evicts least recently used", () => {
          const cache = new LRUCache<string, number>({ maxSize: 2 });
          cache.set("a", 1);
          cache.set("b", 2);
          cache.get("a"); // access a
          cache.set("c", 3); // should evict b
          expect(cache.get("b")).toBeUndefined();
          expect(cache.get("a")).toBe(1);
        });

        it("respects max size", () => {
          const cache = new LRUCache<string, number>({ maxSize: 2 });
          cache.set("a", 1);
          cache.set("b", 2);
          cache.set("c", 3);
          expect(cache.size()).toBe(2);
        });

        it("supports TTL", async () => {
          const cache = new LRUCache<string, number>({ maxSize: 10 });
          cache.set("temp", 42, { ttl: 50 });
          expect(cache.get("temp")).toBe(42);
          await new Promise(r => setTimeout(r, 60));
          expect(cache.get("temp")).toBeUndefined();
        });

        it("has method works correctly", () => {
          const cache = new LRUCache<string, number>({ maxSize: 2 });
          cache.set("a", 1);
          expect(cache.has("a")).toBe(true);
          expect(cache.has("b")).toBe(false);
        });
      });


- id: ts_agent_L2_schema_validator
  lang: typescript
  prompt: |
    JSONスキーマバリデーターを実装してください。解説不要、コードのみ。

    要件:
    - オブジェクトスキーマの定義
    - 必須/オプショナルフィールド
    - 型チェック（string, number, boolean, array, object）
    - ネストしたオブジェクトの検証
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import { Schema, validate } from "../solution";

      describe("Schema Validator", () => {
        it("validates simple object", () => {
          const schema = Schema.object({
            name: Schema.string(),
            age: Schema.number()
          });
          const result = validate({ name: "Alice", age: 30 }, schema);
          expect(result.valid).toBe(true);
        });

        it("fails on wrong type", () => {
          const schema = Schema.object({
            name: Schema.string()
          });
          const result = validate({ name: 123 }, schema);
          expect(result.valid).toBe(false);
        });

        it("validates optional fields", () => {
          const schema = Schema.object({
            name: Schema.string(),
            age: Schema.number().optional()
          });
          const result = validate({ name: "Bob" }, schema);
          expect(result.valid).toBe(true);
        });

        it("validates arrays", () => {
          const schema = Schema.object({
            tags: Schema.array(Schema.string())
          });
          const result = validate({ tags: ["a", "b"] }, schema);
          expect(result.valid).toBe(true);
        });

        it("validates nested objects", () => {
          const schema = Schema.object({
            user: Schema.object({
              name: Schema.string()
            })
          });
          const result = validate({ user: { name: "Charlie" } }, schema);
          expect(result.valid).toBe(true);
        });

        it("returns error details", () => {
          const schema = Schema.object({ name: Schema.string() });
          const result = validate({ name: 123 }, schema);
          expect(result.errors.length).toBeGreaterThan(0);
        });
      });


# =============================================================================
# Level 3 (★★★☆) - Hard: 上級レベルのエージェント問題
# =============================================================================

- id: ts_agent_L3_dependency_injection
  lang: typescript
  prompt: |
    依存性注入（DI）コンテナを実装してください。解説不要、コードのみ。

    要件:
    - サービスの登録と解決
    - シングルトン/ファクトリのライフタイム管理
    - 依存関係の自動解決
    - 型安全なAPI
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import { Container, Injectable } from "../solution";

      describe("DI Container", () => {
        it("resolves simple service", () => {
          const container = new Container();
          class UserService { name = "UserService"; }
          container.register(UserService);
          const instance = container.resolve(UserService);
          expect(instance.name).toBe("UserService");
        });

        it("resolves with dependencies", () => {
          const container = new Container();
          class Database { connected = true; }
          class UserService {
            constructor(public db: Database) {}
          }
          container.register(Database);
          container.register(UserService, [Database]);
          const instance = container.resolve(UserService);
          expect(instance.db.connected).toBe(true);
        });

        it("singleton returns same instance", () => {
          const container = new Container();
          class Service {}
          container.register(Service, [], { singleton: true });
          const a = container.resolve(Service);
          const b = container.resolve(Service);
          expect(a).toBe(b);
        });

        it("transient creates new instances", () => {
          const container = new Container();
          class Service {}
          container.register(Service, [], { singleton: false });
          const a = container.resolve(Service);
          const b = container.resolve(Service);
          expect(a).not.toBe(b);
        });

        it("throws for unregistered service", () => {
          const container = new Container();
          class Missing {}
          expect(() => container.resolve(Missing)).toThrow();
        });
      });


- id: ts_agent_L3_state_machine
  lang: typescript
  prompt: |
    型安全な有限状態マシン（FSM）を実装してください。解説不要、コードのみ。

    要件:
    - 状態と遷移の定義
    - 無効な遷移のコンパイル時/実行時検出
    - 遷移時のコールバック
    - TypeScriptの型システムを活用
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import { StateMachine } from "../solution";

      describe("StateMachine", () => {
        it("starts in initial state", () => {
          const sm = new StateMachine({
            initial: "idle",
            states: {
              idle: { on: { START: "running" } },
              running: { on: { STOP: "idle" } }
            }
          });
          expect(sm.state).toBe("idle");
        });

        it("transitions on valid event", () => {
          const sm = new StateMachine({
            initial: "idle",
            states: {
              idle: { on: { START: "running" } },
              running: { on: { STOP: "idle" } }
            }
          });
          sm.send("START");
          expect(sm.state).toBe("running");
        });

        it("ignores invalid event", () => {
          const sm = new StateMachine({
            initial: "idle",
            states: {
              idle: { on: { START: "running" } },
              running: {}
            }
          });
          sm.send("START");
          sm.send("START"); // invalid in running state
          expect(sm.state).toBe("running");
        });

        it("calls onEnter callback", () => {
          let entered = false;
          const sm = new StateMachine({
            initial: "idle",
            states: {
              idle: { on: { START: "running" } },
              running: { onEnter: () => { entered = true; } }
            }
          });
          sm.send("START");
          expect(entered).toBe(true);
        });

        it("can check available transitions", () => {
          const sm = new StateMachine({
            initial: "idle",
            states: {
              idle: { on: { START: "running", RESET: "idle" } },
              running: {}
            }
          });
          const available = sm.availableEvents();
          expect(available).toContain("START");
        });
      });


- id: ts_agent_L3_query_builder
  lang: typescript
  prompt: |
    型安全なSQLクエリビルダーを実装してください。解説不要、コードのみ。

    要件:
    - SELECT, WHERE, JOIN, ORDER BY をサポート
    - メソッドチェーンで組み立て
    - パラメータのプレースホルダ（SQLインジェクション対策）
    - TypeScriptの型推論を活用
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import { QueryBuilder } from "../solution";

      describe("QueryBuilder", () => {
        it("builds simple select", () => {
          const { query } = new QueryBuilder()
            .select("users")
            .build();
          expect(query.toUpperCase()).toContain("SELECT");
          expect(query.toLowerCase()).toContain("users");
        });

        it("builds select with columns", () => {
          const { query } = new QueryBuilder()
            .select("users", ["id", "name"])
            .build();
          expect(query).toContain("id");
          expect(query).toContain("name");
        });

        it("builds where clause", () => {
          const { query, params } = new QueryBuilder()
            .select("users")
            .where("age", ">", 18)
            .build();
          expect(query.toUpperCase()).toContain("WHERE");
          expect(params).toContain(18);
        });

        it("builds multiple where clauses", () => {
          const { query } = new QueryBuilder()
            .select("users")
            .where("age", ">", 18)
            .where("status", "=", "active")
            .build();
          expect(query.toUpperCase()).toContain("AND");
        });

        it("builds order by", () => {
          const { query } = new QueryBuilder()
            .select("users")
            .orderBy("name", "ASC")
            .build();
          expect(query.toUpperCase()).toContain("ORDER BY");
        });

        it("prevents SQL injection", () => {
          const { query, params } = new QueryBuilder()
            .select("users")
            .where("name", "=", "'; DROP TABLE users;--")
            .build();
          expect(query).not.toContain("DROP TABLE");
          expect(params).toContain("'; DROP TABLE users;--");
        });
      });


- id: ts_agent_L3_event_sourcing
  lang: typescript
  prompt: |
    イベントソーシングシステムを実装してください。解説不要、コードのみ。

    要件:
    - イベントの記録
    - イベントからの状態復元
    - 集約（Aggregate）パターン
    - スナップショットのサポート
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import { EventStore, BankAccount } from "../solution";

      describe("EventStore", () => {
        it("stores events", () => {
          const store = new EventStore();
          store.append("account-1", { type: "deposited", amount: 100 });
          const events = store.getEvents("account-1");
          expect(events.length).toBe(1);
        });

        it("stores events in order", () => {
          const store = new EventStore();
          store.append("acc", { type: "deposited", amount: 100 });
          store.append("acc", { type: "withdrawn", amount: 30 });
          const events = store.getEvents("acc");
          expect(events[0].amount).toBe(100);
          expect(events[1].amount).toBe(30);
        });

        it("isolates aggregates", () => {
          const store = new EventStore();
          store.append("acc-1", { type: "deposited", amount: 100 });
          store.append("acc-2", { type: "deposited", amount: 200 });
          expect(store.getEvents("acc-1").length).toBe(1);
          expect(store.getEvents("acc-2").length).toBe(1);
        });
      });

      describe("BankAccount", () => {
        it("reconstructs from events", () => {
          const events = [
            { type: "deposited", amount: 100 },
            { type: "deposited", amount: 50 },
            { type: "withdrawn", amount: 30 }
          ];
          const account = BankAccount.fromEvents(events);
          expect(account.balance).toBe(120);
        });

        it("handles empty events", () => {
          const account = BankAccount.fromEvents([]);
          expect(account.balance).toBe(0);
        });
      });


- id: ts_agent_L3_circuit_breaker
  lang: typescript
  prompt: |
    サーキットブレーカーパターンを実装してください。解説不要、コードのみ。

    要件:
    - 連続失敗でサーキットをオープン
    - タイムアウト後にハーフオープン状態
    - 成功でクローズ状態に復帰
    - 型安全な実装
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import { CircuitBreaker, CircuitState } from "../solution";

      const sleep = (ms: number) => new Promise(r => setTimeout(r, ms));

      describe("CircuitBreaker", () => {
        it("starts in closed state", () => {
          const cb = new CircuitBreaker({ failureThreshold: 3, recoveryTimeout: 100 });
          expect(cb.state).toBe(CircuitState.CLOSED);
        });

        it("passes calls in closed state", async () => {
          const cb = new CircuitBreaker({ failureThreshold: 3, recoveryTimeout: 100 });
          const result = await cb.call(() => Promise.resolve("ok"));
          expect(result).toBe("ok");
        });

        it("opens after threshold failures", async () => {
          const cb = new CircuitBreaker({ failureThreshold: 2, recoveryTimeout: 100 });
          for (let i = 0; i < 2; i++) {
            try {
              await cb.call(() => Promise.reject(new Error("fail")));
            } catch {}
          }
          expect(cb.state).toBe(CircuitState.OPEN);
        });

        it("rejects calls in open state", async () => {
          const cb = new CircuitBreaker({ failureThreshold: 1, recoveryTimeout: 1000 });
          try {
            await cb.call(() => Promise.reject(new Error("fail")));
          } catch {}
          await expect(cb.call(() => Promise.resolve("test"))).rejects.toThrow();
        });

        it("transitions to half-open after timeout", async () => {
          const cb = new CircuitBreaker({ failureThreshold: 1, recoveryTimeout: 50 });
          try {
            await cb.call(() => Promise.reject(new Error("fail")));
          } catch {}
          await sleep(60);
          expect(cb.state).toBe(CircuitState.HALF_OPEN);
        });

        it("closes on success in half-open", async () => {
          const cb = new CircuitBreaker({ failureThreshold: 1, recoveryTimeout: 50 });
          try {
            await cb.call(() => Promise.reject(new Error("fail")));
          } catch {}
          await sleep(60);
          await cb.call(() => Promise.resolve("recovered"));
          expect(cb.state).toBe(CircuitState.CLOSED);
        });
      });


- id: ts_agent_L3_plugin_system
  lang: typescript
  prompt: |
    型安全なプラグインシステムを実装してください。解説不要、コードのみ。

    要件:
    - プラグインの登録とライフサイクル管理
    - フックポイントでの拡張
    - プラグイン間の依存関係
    - 型安全なプラグインAPI
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import { PluginManager, type Plugin } from "../solution";

      describe("PluginManager", () => {
        it("registers plugins", () => {
          const manager = new PluginManager();
          const plugin: Plugin = {
            name: "test",
            activate: () => {},
            deactivate: () => {}
          };
          manager.register(plugin);
          expect(manager.list()).toContain("test");
        });

        it("activates plugins", () => {
          const manager = new PluginManager();
          let activated = false;
          const plugin: Plugin = {
            name: "test",
            activate: () => { activated = true; },
            deactivate: () => {}
          };
          manager.register(plugin);
          manager.activate("test");
          expect(activated).toBe(true);
        });

        it("deactivates plugins", () => {
          const manager = new PluginManager();
          let deactivated = false;
          const plugin: Plugin = {
            name: "test",
            activate: () => {},
            deactivate: () => { deactivated = true; }
          };
          manager.register(plugin);
          manager.activate("test");
          manager.deactivate("test");
          expect(deactivated).toBe(true);
        });

        it("supports hooks", () => {
          const manager = new PluginManager();
          const results: string[] = [];
          manager.hook("onInit", () => results.push("init"));
          manager.trigger("onInit");
          expect(results).toContain("init");
        });

        it("handles hook priority", () => {
          const manager = new PluginManager();
          const results: number[] = [];
          manager.hook("test", () => results.push(2), { priority: 10 });
          manager.hook("test", () => results.push(1), { priority: 1 });
          manager.trigger("test");
          expect(results[0]).toBe(1);
        });
      });


# =============================================================================
# Level 4 (★★★★) - Expert: エキスパートレベルのエージェント問題
# =============================================================================

- id: ts_agent_L4_workflow_engine
  lang: typescript
  prompt: |
    ワークフローエンジンを実装してください。解説不要、コードのみ。

    要件:
    - タスクの定義と依存関係
    - 並列/直列実行
    - 失敗時のリトライ/スキップ戦略
    - 実行状態の追跡
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import { Workflow, TaskStatus } from "../solution";

      describe("Workflow", () => {
        it("executes sequential tasks", async () => {
          const results: string[] = [];
          const wf = new Workflow();
          wf.addTask("a", async () => { results.push("a"); });
          wf.addTask("b", async () => { results.push("b"); }, { dependsOn: ["a"] });
          await wf.run();
          expect(results).toEqual(["a", "b"]);
        });

        it("executes parallel tasks", async () => {
          const results: string[] = [];
          const wf = new Workflow();
          wf.addTask("a", async () => { results.push("a"); });
          wf.addTask("b", async () => { results.push("b"); });
          wf.addTask("c", async () => { results.push("c"); }, { dependsOn: ["a", "b"] });
          await wf.run();
          expect(results).toContain("a");
          expect(results).toContain("b");
          expect(results[results.length - 1]).toBe("c");
        });

        it("handles task failure", async () => {
          const wf = new Workflow();
          wf.addTask("a", async () => { throw new Error("fail"); });
          wf.addTask("b", async () => {}, { dependsOn: ["a"] });
          await wf.run();
          expect(wf.getStatus("a")).toBe(TaskStatus.FAILED);
          expect(wf.getStatus("b")).toBe(TaskStatus.SKIPPED);
        });

        it("retries failed tasks", async () => {
          let attempts = 0;
          const wf = new Workflow();
          wf.addTask("a", async () => {
            attempts++;
            if (attempts < 3) throw new Error("fail");
          }, { retries: 3 });
          await wf.run();
          expect(wf.getStatus("a")).toBe(TaskStatus.COMPLETED);
        });
      });


- id: ts_agent_L4_rule_engine
  lang: typescript
  prompt: |
    ビジネスルールエンジンを実装してください。解説不要、コードのみ。

    要件:
    - ルールの定義（条件 + アクション）
    - ルールの優先度と競合解決
    - ファクトに対するルール適用
    - 型安全なルール定義
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import { RuleEngine } from "../solution";

      describe("RuleEngine", () => {
        it("applies matching rule", () => {
          const engine = new RuleEngine<{ age: number; discount: number }>();
          engine.addRule({
            name: "senior",
            condition: (facts) => facts.age >= 65,
            action: (facts) => { facts.discount = 20; }
          });
          const facts = { age: 70, discount: 0 };
          engine.run(facts);
          expect(facts.discount).toBe(20);
        });

        it("skips non-matching rules", () => {
          const engine = new RuleEngine<{ age: number; discount: number }>();
          engine.addRule({
            name: "senior",
            condition: (facts) => facts.age >= 65,
            action: (facts) => { facts.discount = 20; }
          });
          const facts = { age: 30, discount: 0 };
          engine.run(facts);
          expect(facts.discount).toBe(0);
        });

        it("applies multiple rules", () => {
          const engine = new RuleEngine<{ member: boolean; quantity: number; discount: number }>();
          engine.addRule({
            name: "member",
            condition: (f) => f.member,
            action: (f) => { f.discount += 5; }
          });
          engine.addRule({
            name: "bulk",
            condition: (f) => f.quantity >= 10,
            action: (f) => { f.discount += 10; }
          });
          const facts = { member: true, quantity: 15, discount: 0 };
          engine.run(facts);
          expect(facts.discount).toBe(15);
        });

        it("respects priority", () => {
          const engine = new RuleEngine<{ value: string }>();
          const results: string[] = [];
          engine.addRule({
            name: "low",
            priority: 10,
            condition: () => true,
            action: () => { results.push("low"); }
          });
          engine.addRule({
            name: "high",
            priority: 1,
            condition: () => true,
            action: () => { results.push("high"); }
          });
          engine.run({ value: "" });
          expect(results[0]).toBe("high");
        });
      });


- id: ts_agent_L4_saga_pattern
  lang: typescript
  prompt: |
    Sagaパターン（分散トランザクション）を実装してください。解説不要、コードのみ。

    要件:
    - 複数ステップのトランザクション
    - 各ステップの補償アクション
    - 失敗時の自動ロールバック
    - オーケストレーション型
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import { Saga, SagaStatus } from "../solution";

      describe("Saga", () => {
        it("executes all steps on success", async () => {
          const results: string[] = [];
          const saga = new Saga();
          saga.addStep({
            execute: async () => { results.push("s1"); },
            compensate: async () => { results.push("c1"); }
          });
          saga.addStep({
            execute: async () => { results.push("s2"); },
            compensate: async () => { results.push("c2"); }
          });
          await saga.run();
          expect(results).toEqual(["s1", "s2"]);
          expect(saga.status).toBe(SagaStatus.COMPLETED);
        });

        it("compensates on failure", async () => {
          const results: string[] = [];
          const saga = new Saga();
          saga.addStep({
            execute: async () => { results.push("s1"); },
            compensate: async () => { results.push("c1"); }
          });
          saga.addStep({
            execute: async () => { throw new Error("fail"); },
            compensate: async () => { results.push("c2"); }
          });
          await saga.run();
          expect(results).toContain("c1");
          expect(saga.status).toBe(SagaStatus.COMPENSATED);
        });

        it("compensates in reverse order", async () => {
          const results: string[] = [];
          const saga = new Saga();
          saga.addStep({
            execute: async () => { results.push("s1"); },
            compensate: async () => { results.push("c1"); }
          });
          saga.addStep({
            execute: async () => { results.push("s2"); },
            compensate: async () => { results.push("c2"); }
          });
          saga.addStep({
            execute: async () => { throw new Error("fail"); },
            compensate: async () => {}
          });
          await saga.run();
          const compIdx1 = results.indexOf("c1");
          const compIdx2 = results.indexOf("c2");
          expect(compIdx2).toBeLessThan(compIdx1); // c2 before c1
        });
      });


- id: ts_agent_L4_api_gateway
  lang: typescript
  prompt: |
    APIゲートウェイを実装してください。解説不要、コードのみ。

    要件:
    - ルートベースのリクエストルーティング
    - 認証/認可ミドルウェア
    - レート制限
    - リクエスト/レスポンス変換
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import { Gateway, type Request, type Response } from "../solution";

      describe("Gateway", () => {
        it("routes to handler", async () => {
          const gw = new Gateway();
          gw.route("GET", "/users", async () => ({ status: 200, body: [] }));
          const res = await gw.handle({ method: "GET", path: "/users" });
          expect(res.status).toBe(200);
        });

        it("extracts path params", async () => {
          const gw = new Gateway();
          gw.route("GET", "/users/:id", async (req) => ({
            status: 200,
            body: { id: req.params.id }
          }));
          const res = await gw.handle({ method: "GET", path: "/users/123" });
          expect(res.body.id).toBe("123");
        });

        it("applies auth middleware", async () => {
          const gw = new Gateway();
          gw.use(async (req, next) => {
            if (!req.headers?.["Authorization"]) {
              return { status: 401, body: { error: "Unauthorized" } };
            }
            return next();
          });
          gw.route("GET", "/protected", async () => ({ status: 200, body: {} }));
          const res = await gw.handle({ method: "GET", path: "/protected" });
          expect(res.status).toBe(401);
        });

        it("applies rate limiting", async () => {
          const gw = new Gateway();
          gw.rateLimit({ maxRequests: 2, windowMs: 1000 });
          gw.route("GET", "/api", async () => ({ status: 200, body: {} }));
          await gw.handle({ method: "GET", path: "/api", clientId: "c1" });
          await gw.handle({ method: "GET", path: "/api", clientId: "c1" });
          const res = await gw.handle({ method: "GET", path: "/api", clientId: "c1" });
          expect(res.status).toBe(429);
        });

        it("returns 404 for unknown routes", async () => {
          const gw = new Gateway();
          const res = await gw.handle({ method: "GET", path: "/unknown" });
          expect(res.status).toBe(404);
        });
      });


- id: ts_agent_L4_cqrs
  lang: typescript
  prompt: |
    CQRS（Command Query Responsibility Segregation）を実装してください。解説不要、コードのみ。

    要件:
    - コマンドハンドラ（書き込み）
    - クエリハンドラ（読み取り）
    - コマンドとクエリの分離
    - 型安全なコマンド/クエリ定義
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import { CQRSApp, CreateUserCommand, GetUserQuery, ListUsersQuery } from "../solution";

      describe("CQRS", () => {
        it("executes command", async () => {
          const app = new CQRSApp();
          const result = await app.execute(new CreateUserCommand("u1", "Alice"));
          expect(result.success).toBe(true);
        });

        it("executes query", async () => {
          const app = new CQRSApp();
          await app.execute(new CreateUserCommand("u1", "Alice"));
          const user = await app.query(new GetUserQuery("u1"));
          expect(user.name).toBe("Alice");
        });

        it("lists users", async () => {
          const app = new CQRSApp();
          await app.execute(new CreateUserCommand("u1", "Alice"));
          await app.execute(new CreateUserCommand("u2", "Bob"));
          const users = await app.query(new ListUsersQuery());
          expect(users.length).toBe(2);
        });

        it("separates read and write models", async () => {
          const app = new CQRSApp();
          await app.execute(new CreateUserCommand("u1", "Alice"));
          const user1 = await app.query(new GetUserQuery("u1"));
          const user2 = await app.query(new GetUserQuery("u1"));
          expect(user1).toEqual(user2);
        });
      });


- id: ts_agent_L4_distributed_lock
  lang: typescript
  prompt: |
    分散ロック機構を実装してください。解説不要、コードのみ。

    要件:
    - ロックの取得と解放
    - タイムアウト付きの取得
    - 自動期限切れ（TTL）
    - ロック所有者の検証
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import { LockManager } from "../solution";

      const sleep = (ms: number) => new Promise(r => setTimeout(r, ms));

      describe("LockManager", () => {
        it("acquires and releases lock", async () => {
          const manager = new LockManager();
          const lock = await manager.acquire("resource-1", "client-a");
          expect(lock).not.toBeNull();
          await manager.release("resource-1", "client-a");
          const lock2 = await manager.acquire("resource-1", "client-b");
          expect(lock2).not.toBeNull();
        });

        it("blocks concurrent acquire", async () => {
          const manager = new LockManager();
          await manager.acquire("resource-1", "client-a");
          const lock2 = await manager.acquire("resource-1", "client-b", { timeout: 10 });
          expect(lock2).toBeNull();
        });

        it("validates owner on release", async () => {
          const manager = new LockManager();
          await manager.acquire("resource-1", "client-a");
          const released = await manager.release("resource-1", "client-b");
          expect(released).toBe(false);
        });

        it("expires after TTL", async () => {
          const manager = new LockManager();
          await manager.acquire("resource-1", "client-a", { ttl: 50 });
          await sleep(60);
          const lock = await manager.acquire("resource-1", "client-b");
          expect(lock).not.toBeNull();
        });

        it("extends lock TTL", async () => {
          const manager = new LockManager();
          await manager.acquire("resource-1", "client-a", { ttl: 50 });
          await manager.extend("resource-1", "client-a", 1000);
          await sleep(60);
          const lock = await manager.acquire("resource-1", "client-b", { timeout: 10 });
          expect(lock).toBeNull(); // still locked
        });
      });
# =============================================================================
# TypeScript固有の強み: 高度な型システム
# =============================================================================

- id: ts_conditional_types
  lang: typescript
  prompt: |
    Conditional Typesを使った型ユーティリティを実装。解説不要、コードのみ。
    - Flatten<T> - 配列なら要素型、そうでなければT
    - MyNonNullable<T> - nullとundefinedを除去（自作）
    - ReturnTypeOf<T> - 関数の戻り値型を取得（自作）
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import type { Flatten, MyNonNullable, ReturnTypeOf } from "../solution";
      describe("Conditional Types", () => {
        it("Flatten works", () => {
          type A = Flatten<string[]>;
          type B = Flatten<number>;
          const a: A = "test";
          const b: B = 42;
          expect(typeof a).toBe("string");
          expect(typeof b).toBe("number");
        });
        it("MyNonNullable works", () => {
          type A = MyNonNullable<string | null | undefined>;
          const a: A = "test";
          expect(a).toBe("test");
        });
        it("ReturnTypeOf works", () => {
          type Fn = () => { id: number };
          type R = ReturnTypeOf<Fn>;
          const r: R = { id: 1 };
          expect(r.id).toBe(1);
        });
      });

- id: ts_mapped_types
  lang: typescript
  prompt: |
    Mapped Typesを使った型ユーティリティを実装。解説不要、コードのみ。
    - MyReadonly<T> - 全プロパティをreadonly（自作）
    - MyPartial<T> - 全プロパティをoptional（自作）
    - MyRequired<T> - 全プロパティを必須（自作）
    - Mutable<T> - readonlyを除去
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import type { MyReadonly, MyPartial, MyRequired, Mutable } from "../solution";
      describe("Mapped Types", () => {
        it("MyReadonly works", () => {
          type User = { name: string };
          type RO = MyReadonly<User>;
          const u: RO = { name: "test" };
          expect(u.name).toBe("test");
        });
        it("MyPartial works", () => {
          type User = { name: string; age: number };
          type P = MyPartial<User>;
          const u: P = { name: "test" };
          expect(u.name).toBe("test");
        });
        it("MyRequired works", () => {
          type User = { name?: string };
          type R = MyRequired<User>;
          const u: R = { name: "test" };
          expect(u.name).toBe("test");
        });
        it("Mutable works", () => {
          type RO = { readonly name: string };
          type M = Mutable<RO>;
          const u: M = { name: "test" };
          u.name = "changed";
          expect(u.name).toBe("changed");
        });
      });

- id: ts_template_literal
  lang: typescript
  prompt: |
    Template Literal Typesを使った型を実装。解説不要、コードのみ。
    - EventName<T> - "on" + Capitalize<T> (例: "click" → "onClick")
    - toEventName(event: string): string
    - PathParams<T> - URLパスからパラメータ抽出
    - extractParams(pattern: string, path: string): Record<string, string>
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import type { EventName, PathParams } from "../solution";
      import { toEventName, extractParams } from "../solution";
      describe("Template Literal Types", () => {
        it("EventName type", () => {
          type E = EventName<"click">;
          const e: E = "onClick";
          expect(e).toBe("onClick");
        });
        it("toEventName function", () => {
          expect(toEventName("click")).toBe("onClick");
          expect(toEventName("mouseOver")).toBe("onMouseOver");
        });
        it("extractParams function", () => {
          const params = extractParams("/users/:id", "/users/123");
          expect(params.id).toBe("123");
        });
      });

- id: ts_discriminated_union
  lang: typescript
  prompt: |
    Discriminated Unionを使ったパターンマッチングを実装。解説不要、コードのみ。
    - type Action = { type: "INCREMENT" } | { type: "DECREMENT" } | { type: "SET"; value: number }
    - reducer(state: number, action: Action): number
    - increment(), decrement(), set(value) アクションクリエーター
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import { reducer, increment, decrement, set, type Action } from "../solution";
      describe("Discriminated Union", () => {
        it("handles INCREMENT", () => {
          expect(reducer(0, increment())).toBe(1);
        });
        it("handles DECREMENT", () => {
          expect(reducer(5, decrement())).toBe(4);
        });
        it("handles SET", () => {
          expect(reducer(0, set(10))).toBe(10);
        });
        it("type safety", () => {
          const action: Action = { type: "SET", value: 42 };
          expect(reducer(0, action)).toBe(42);
        });
      });

# React風パターン
- id: ts_react_hooks
  lang: typescript
  prompt: |
    React風のカスタムフックを実装（Reactなし）。解説不要、コードのみ。
    - useState<T>(initial: T): [T, (v: T | ((prev: T) => T)) => void]
    - useMemo<T>(factory: () => T, deps: any[]): T
    - resetHooks(): void
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect, beforeEach } from "vitest";
      import { useState, useMemo, resetHooks } from "../solution";
      describe("React Hooks", () => {
        beforeEach(() => resetHooks());
        it("useState returns state and setter", () => {
          const [count, setCount] = useState(0);
          expect(count).toBe(0);
          setCount(5);
          const [count2] = useState(0);
          expect(count2).toBe(5);
        });
        it("useState with updater function", () => {
          const [count, setCount] = useState(10);
          setCount(prev => prev + 1);
          const [count2] = useState(0);
          expect(count2).toBe(11);
        });
        it("useMemo caches value", () => {
          let calls = 0;
          const value = useMemo(() => { calls++; return 42; }, [1]);
          const value2 = useMemo(() => { calls++; return 42; }, [1]);
          expect(calls).toBe(1);
        });
      });

# Express風パターン
- id: ts_express_middleware
  lang: typescript
  prompt: |
    Express風のミドルウェアシステムを実装。解説不要、コードのみ。
    - createApp() でアプリ作成
    - app.use(middleware), app.get(path, handler), app.post(path, handler)
    - app.handle(req) でリクエスト処理
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import { createApp } from "../solution";
      describe("Express-like App", () => {
        it("handles GET request", async () => {
          const app = createApp();
          app.get("/users", (req, res) => { res.json([{ id: 1 }]); });
          const res = await app.handle({ method: "GET", path: "/users" });
          expect(res.body).toEqual([{ id: 1 }]);
        });
        it("extracts params", async () => {
          const app = createApp();
          app.get("/users/:id", (req, res) => { res.json({ id: req.params.id }); });
          const res = await app.handle({ method: "GET", path: "/users/123" });
          expect(res.body.id).toBe("123");
        });
        it("runs middleware", async () => {
          const app = createApp();
          const logs: string[] = [];
          app.use((req, res, next) => { logs.push("m1"); next(); });
          app.get("/test", (req, res) => { res.json({ ok: true }); });
          await app.handle({ method: "GET", path: "/test" });
          expect(logs).toContain("m1");
        });
      });

# Zod風バリデーション
- id: ts_validation_schema
  lang: typescript
  prompt: |
    Zod風のバリデーションスキーマを実装。解説不要、コードのみ。
    - z.string(), z.number(), z.boolean()
    - z.object({...}), z.array(schema)
    - .optional(), .parse(data)
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import { z } from "../solution";
      describe("Validation Schema", () => {
        it("validates string", () => {
          const schema = z.string();
          expect(schema.parse("hello")).toBe("hello");
          expect(() => schema.parse(123)).toThrow();
        });
        it("validates object", () => {
          const schema = z.object({ name: z.string(), age: z.number() });
          const result = schema.parse({ name: "Alice", age: 30 });
          expect(result.name).toBe("Alice");
        });
        it("validates array", () => {
          const schema = z.array(z.number());
          expect(schema.parse([1, 2, 3])).toEqual([1, 2, 3]);
        });
        it("handles optional", () => {
          const schema = z.object({ name: z.string(), age: z.number().optional() });
          const result = schema.parse({ name: "Bob" });
          expect(result.name).toBe("Bob");
        });
      });

# バグ修正問題
- id: ts_this_binding_bug
  lang: typescript
  prompt: |
    thisバインディングバグを修正。解説不要、コードのみ。
    問題: クラスメソッドをコールバックとして渡すとthisが失われる
    class Counter { count = 0; increment() { this.count++; } getCount() { return this.count; } }
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import { Counter } from "../solution";
      describe("Counter this binding", () => {
        it("works with direct call", () => {
          const c = new Counter();
          c.increment();
          expect(c.getCount()).toBe(1);
        });
        it("works as callback", async () => {
          const c = new Counter();
          await new Promise<void>(resolve => {
            setTimeout(() => { c.increment(); resolve(); }, 0);
          });
          expect(c.getCount()).toBe(1);
        });
        it("works with array methods", () => {
          const c = new Counter();
          [1, 2, 3].forEach(c.increment);
          expect(c.getCount()).toBe(3);
        });
      });

- id: ts_equality_bug
  lang: typescript
  prompt: |
    等価性チェックのバグを修正。解説不要、コードのみ。
    問題: オブジェクトの等価性を正しく比較できない
    元コード: function isEqual(a: any, b: any) { return a == b; }
    期待: 深い比較で正しく判定
  tests:
    tests/solution.test.ts: |
      import { describe, it, expect } from "vitest";
      import { isEqual } from "../solution";
      describe("isEqual", () => {
        it("compares primitives", () => {
          expect(isEqual(1, 1)).toBe(true);
          expect(isEqual(1, 2)).toBe(false);
        });
        it("compares objects", () => {
          expect(isEqual({ a: 1 }, { a: 1 })).toBe(true);
          expect(isEqual({ a: 1 }, { a: 2 })).toBe(false);
        });
        it("compares nested objects", () => {
          expect(isEqual({ a: { b: 1 } }, { a: { b: 1 } })).toBe(true);
        });
        it("compares arrays", () => {
          expect(isEqual([1, 2], [1, 2])).toBe(true);
          expect(isEqual([1, 2], [1, 3])).toBe(false);
        });
      });
