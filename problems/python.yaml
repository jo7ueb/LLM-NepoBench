# =============================================================================
# Python ベンチマーク問題集
# カテゴリ: バグ修正, データ処理, アルゴリズム, API設計, OOP, 例外処理, etc.
# 各問題に複数テストケースを含み、部分点評価が可能
# =============================================================================

# -----------------------------------------------------------------------------
# カテゴリ: バグ修正 (Bug Fix)
# -----------------------------------------------------------------------------

- id: py_remove_even
  lang: python
  prompt: |
    次の関数にはバグがあり、偶数が正しく削除されません。
    期待結果は remove_even_numbers([1,2,4,8,9]) == [1,9] です。
    解説不要。修正後のPythonコードのみ出力してください。

    def remove_even_numbers(numbers):
        for num in numbers:
            if num % 2 == 0:
                numbers.remove(num)
        return numbers
  tests:
    tests/test_solution.py: |
      from solution import remove_even_numbers

      def test_basic():
          assert remove_even_numbers([1,2,4,8,9]) == [1,9]

      def test_all_even():
          assert remove_even_numbers([2,4,6,8]) == []

      def test_all_odd():
          assert remove_even_numbers([1,3,5,7]) == [1,3,5,7]

      def test_empty():
          assert remove_even_numbers([]) == []

      def test_consecutive_evens():
          assert remove_even_numbers([2,4,6,1,3]) == [1,3]


- id: py_off_by_one
  lang: python
  prompt: |
    次の関数は1からnまでの合計を計算するはずですが、off-by-one エラーがあります。
    sum_to_n(5) は 1+2+3+4+5=15 を返すべきです。
    解説不要。修正後のPythonコードのみ出力してください。

    def sum_to_n(n):
        total = 0
        for i in range(n):
            total += i
        return total
  tests:
    tests/test_solution.py: |
      from solution import sum_to_n

      def test_sum_5():
          assert sum_to_n(5) == 15

      def test_sum_1():
          assert sum_to_n(1) == 1

      def test_sum_10():
          assert sum_to_n(10) == 55

      def test_sum_0():
          assert sum_to_n(0) == 0


- id: py_mutable_default
  lang: python
  prompt: |
    次の関数はミュータブルなデフォルト引数のバグがあります。
    呼び出すたびに新しい空リストから始めるべきです。
    解説不要。修正後のPythonコードのみ出力してください。

    def append_to_list(item, lst=[]):
        lst.append(item)
        return lst
  tests:
    tests/test_solution.py: |
      from solution import append_to_list

      def test_independent_calls():
          result1 = append_to_list(1)
          result2 = append_to_list(2)
          assert result1 == [1]
          assert result2 == [2]

      def test_with_provided_list():
          my_list = [10]
          result = append_to_list(20, my_list)
          assert result == [10, 20]

      def test_multiple_appends():
          append_to_list("a")
          append_to_list("b")
          result = append_to_list("c")
          assert result == ["c"]


# -----------------------------------------------------------------------------
# カテゴリ: データ処理 (Data Processing)
# -----------------------------------------------------------------------------

- id: py_word_frequency
  lang: python
  prompt: |
    テキストから単語の出現頻度を数える関数を実装してください。
    解説不要。Pythonコードのみ出力してください。

    仕様:
    - word_frequency(text: str) -> dict[str, int]
    - 単語は空白で区切られる
    - 大文字小文字は区別しない（すべて小文字に変換）
    - 句読点（.,!?）は除去する
    - 空の入力には空辞書を返す
  tests:
    tests/test_solution.py: |
      from solution import word_frequency

      def test_basic():
          result = word_frequency("Hello world hello")
          assert result == {"hello": 2, "world": 1}

      def test_punctuation():
          result = word_frequency("Hello, world! Hello.")
          assert result == {"hello": 2, "world": 1}

      def test_empty():
          assert word_frequency("") == {}

      def test_single_word():
          assert word_frequency("Python") == {"python": 1}

      def test_case_insensitive():
          result = word_frequency("Cat CAT cat")
          assert result == {"cat": 3}


- id: py_flatten_nested
  lang: python
  prompt: |
    ネストしたリストを平坦化する関数を実装してください。
    解説不要。Pythonコードのみ出力してください。

    仕様:
    - flatten(nested: list) -> list
    - 任意の深さのネストに対応
    - 再帰的に処理する
  tests:
    tests/test_solution.py: |
      from solution import flatten

      def test_simple():
          assert flatten([1, [2, 3], 4]) == [1, 2, 3, 4]

      def test_deep_nested():
          assert flatten([1, [2, [3, [4]]]]) == [1, 2, 3, 4]

      def test_already_flat():
          assert flatten([1, 2, 3]) == [1, 2, 3]

      def test_empty():
          assert flatten([]) == []

      def test_mixed_types():
          assert flatten([1, ["a", [True, [None]]]]) == [1, "a", True, None]


- id: py_group_by_key
  lang: python
  prompt: |
    辞書のリストを指定キーでグループ化する関数を実装してください。
    解説不要。Pythonコードのみ出力してください。

    仕様:
    - group_by(items: list[dict], key: str) -> dict[Any, list[dict]]
    - 指定キーの値でグループ化
    - キーが存在しないアイテムは "unknown" でグループ化
  tests:
    tests/test_solution.py: |
      from solution import group_by

      def test_basic():
          items = [
              {"name": "Alice", "dept": "Engineering"},
              {"name": "Bob", "dept": "Sales"},
              {"name": "Charlie", "dept": "Engineering"},
          ]
          result = group_by(items, "dept")
          assert len(result["Engineering"]) == 2
          assert len(result["Sales"]) == 1

      def test_missing_key():
          items = [
              {"name": "Alice", "dept": "Engineering"},
              {"name": "Bob"},
          ]
          result = group_by(items, "dept")
          assert "unknown" in result
          assert len(result["unknown"]) == 1

      def test_empty():
          assert group_by([], "key") == {}

      def test_single_group():
          items = [{"a": 1}, {"a": 1}, {"a": 1}]
          result = group_by(items, "a")
          assert len(result[1]) == 3


# -----------------------------------------------------------------------------
# カテゴリ: アルゴリズム (Algorithms)
# -----------------------------------------------------------------------------

- id: py_binary_search
  lang: python
  prompt: |
    ソート済みリストで二分探索を実装してください。
    解説不要。Pythonコードのみ出力してください。

    仕様:
    - binary_search(arr: list[int], target: int) -> int
    - ターゲットが見つかればそのインデックスを返す
    - 見つからなければ -1 を返す
    - 組み込みの bisect モジュールは使用不可
  tests:
    tests/test_solution.py: |
      from solution import binary_search

      def test_found_middle():
          assert binary_search([1, 3, 5, 7, 9], 5) == 2

      def test_found_first():
          assert binary_search([1, 3, 5, 7, 9], 1) == 0

      def test_found_last():
          assert binary_search([1, 3, 5, 7, 9], 9) == 4

      def test_not_found():
          assert binary_search([1, 3, 5, 7, 9], 6) == -1

      def test_empty():
          assert binary_search([], 5) == -1

      def test_single_element():
          assert binary_search([42], 42) == 0
          assert binary_search([42], 1) == -1


- id: py_fibonacci_memo
  lang: python
  prompt: |
    メモ化を使った効率的なフィボナッチ数列を実装してください。
    解説不要。Pythonコードのみ出力してください。

    仕様:
    - fibonacci(n: int) -> int
    - fib(0) = 0, fib(1) = 1
    - n >= 40 でも高速に動作すること
  tests:
    tests/test_solution.py: |
      from solution import fibonacci
      import time

      def test_base_cases():
          assert fibonacci(0) == 0
          assert fibonacci(1) == 1

      def test_small_values():
          assert fibonacci(5) == 5
          assert fibonacci(10) == 55

      def test_medium_values():
          assert fibonacci(20) == 6765

      def test_large_value_performance():
          start = time.time()
          result = fibonacci(40)
          elapsed = time.time() - start
          assert result == 102334155
          assert elapsed < 1.0  # 1秒以内に完了すべき


- id: py_merge_sorted
  lang: python
  prompt: |
    2つのソート済みリストをマージして1つのソート済みリストにする関数を実装してください。
    解説不要。Pythonコードのみ出力してください。

    仕様:
    - merge_sorted(list1: list[int], list2: list[int]) -> list[int]
    - O(n+m) の時間計算量で実装
    - 組み込みの sorted() や sort() は使用不可
  tests:
    tests/test_solution.py: |
      from solution import merge_sorted

      def test_basic():
          assert merge_sorted([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6]

      def test_one_empty():
          assert merge_sorted([1, 2, 3], []) == [1, 2, 3]
          assert merge_sorted([], [4, 5, 6]) == [4, 5, 6]

      def test_both_empty():
          assert merge_sorted([], []) == []

      def test_duplicates():
          assert merge_sorted([1, 2, 2], [2, 3]) == [1, 2, 2, 2, 3]

      def test_different_lengths():
          assert merge_sorted([1], [2, 3, 4, 5]) == [1, 2, 3, 4, 5]


# -----------------------------------------------------------------------------
# カテゴリ: API設計 (Web API)
# -----------------------------------------------------------------------------

- id: py_fastapi_tasks
  lang: python
  prompt: |
    FastAPI と Pydantic を使って簡単なタスク管理APIを実装してください。
    次の仕様を満たす単一ファイル solution.py を出力してください（解説不要）。

    仕様:
    - FastAPI app インスタンス名は `app`
    - POST /tasks でタスク作成
      - 入力: {"title": str, "done": bool}
      - 出力: {"id": int, "title": str, "done": bool}
    - GET /tasks で一覧取得（作成順）
    - DBはインメモリ配列でOK
    - タイトルは空文字禁止（空なら 422 などのバリデーションエラーでOK）
  tests:
    tests/test_solution.py: |
      from fastapi.testclient import TestClient
      from solution import app

      client = TestClient(app)

      def test_get_empty():
          r = client.get("/tasks")
          assert r.status_code == 200
          assert r.json() == []

      def test_create_task():
          r = client.post("/tasks", json={"title": "a", "done": False})
          assert r.status_code == 200
          body = r.json()
          assert body["id"] == 1
          assert body["title"] == "a"
          assert body["done"] is False

      def test_create_second_task():
          # Reset state by importing fresh
          r = client.post("/tasks", json={"title": "b", "done": True})
          assert r.status_code == 200
          body = r.json()
          assert body["id"] >= 1
          assert body["title"] == "b"

      def test_list_tasks():
          r = client.get("/tasks")
          assert r.status_code == 200
          items = r.json()
          assert len(items) >= 1

      def test_title_validation():
          r = client.post("/tasks", json={"title": "", "done": False})
          assert r.status_code in (400, 422)


- id: py_fastapi_crud
  lang: python
  prompt: |
    FastAPIでユーザーのCRUD APIを実装してください。
    解説不要。solution.py のみ出力してください。

    仕様:
    - app インスタンス名は `app`
    - GET /users - 全ユーザー一覧
    - GET /users/{id} - 特定ユーザー取得（存在しない場合404）
    - POST /users - ユーザー作成 {"name": str, "email": str}
    - PUT /users/{id} - ユーザー更新（存在しない場合404）
    - DELETE /users/{id} - ユーザー削除（存在しない場合404）
    - IDは自動採番、インメモリDB
  tests:
    tests/test_solution.py: |
      from fastapi.testclient import TestClient
      from solution import app

      client = TestClient(app)

      def test_list_empty():
          r = client.get("/users")
          assert r.status_code == 200
          assert isinstance(r.json(), list)

      def test_create_user():
          r = client.post("/users", json={"name": "Test", "email": "test@example.com"})
          assert r.status_code in (200, 201)
          body = r.json()
          assert "id" in body
          assert body["name"] == "Test"

      def test_get_user():
          # Create first
          r = client.post("/users", json={"name": "Get Test", "email": "get@example.com"})
          user_id = r.json()["id"]
          # Get it
          r = client.get(f"/users/{user_id}")
          assert r.status_code == 200
          assert r.json()["name"] == "Get Test"

      def test_get_nonexistent():
          r = client.get("/users/99999")
          assert r.status_code == 404

      def test_update_user():
          r = client.post("/users", json={"name": "Update Test", "email": "update@example.com"})
          user_id = r.json()["id"]
          r = client.put(f"/users/{user_id}", json={"name": "Updated", "email": "updated@example.com"})
          assert r.status_code == 200
          assert r.json()["name"] == "Updated"

      def test_delete_user():
          r = client.post("/users", json={"name": "Delete Test", "email": "delete@example.com"})
          user_id = r.json()["id"]
          r = client.delete(f"/users/{user_id}")
          assert r.status_code in (200, 204)


# -----------------------------------------------------------------------------
# カテゴリ: OOP / クラス設計
# -----------------------------------------------------------------------------

- id: py_stack_class
  lang: python
  prompt: |
    スタック（後入れ先出し）のクラスを実装してください。
    解説不要。Pythonコードのみ出力してください。

    仕様:
    - class Stack
    - push(item) - アイテムを追加
    - pop() - アイテムを取り出し（空なら IndexError）
    - peek() - 先頭を参照（取り出さない、空なら IndexError）
    - is_empty() -> bool
    - size() -> int
  tests:
    tests/test_solution.py: |
      import pytest
      from solution import Stack

      def test_push_pop():
          s = Stack()
          s.push(1)
          s.push(2)
          assert s.pop() == 2
          assert s.pop() == 1

      def test_peek():
          s = Stack()
          s.push(10)
          assert s.peek() == 10
          assert s.size() == 1  # peek doesn't remove

      def test_is_empty():
          s = Stack()
          assert s.is_empty() is True
          s.push(1)
          assert s.is_empty() is False

      def test_size():
          s = Stack()
          assert s.size() == 0
          s.push(1)
          s.push(2)
          assert s.size() == 2

      def test_pop_empty_raises():
          s = Stack()
          with pytest.raises(IndexError):
              s.pop()

      def test_peek_empty_raises():
          s = Stack()
          with pytest.raises(IndexError):
              s.peek()


- id: py_bank_account
  lang: python
  prompt: |
    銀行口座クラスを実装してください。
    解説不要。Pythonコードのみ出力してください。

    仕様:
    - class BankAccount(owner: str, initial_balance: float = 0)
    - deposit(amount: float) - 入金（負の値は ValueError）
    - withdraw(amount: float) - 出金（残高不足は ValueError）
    - get_balance() -> float
    - transfer(target: BankAccount, amount: float) - 他口座へ送金
  tests:
    tests/test_solution.py: |
      import pytest
      from solution import BankAccount

      def test_initial_balance():
          acc = BankAccount("Alice", 100)
          assert acc.get_balance() == 100

      def test_deposit():
          acc = BankAccount("Bob", 50)
          acc.deposit(25)
          assert acc.get_balance() == 75

      def test_withdraw():
          acc = BankAccount("Charlie", 100)
          acc.withdraw(30)
          assert acc.get_balance() == 70

      def test_withdraw_insufficient():
          acc = BankAccount("Dave", 50)
          with pytest.raises(ValueError):
              acc.withdraw(100)

      def test_deposit_negative():
          acc = BankAccount("Eve", 100)
          with pytest.raises(ValueError):
              acc.deposit(-10)

      def test_transfer():
          acc1 = BankAccount("From", 100)
          acc2 = BankAccount("To", 50)
          acc1.transfer(acc2, 30)
          assert acc1.get_balance() == 70
          assert acc2.get_balance() == 80


# -----------------------------------------------------------------------------
# カテゴリ: 文字列処理 / 正規表現
# -----------------------------------------------------------------------------

- id: py_email_validator
  lang: python
  prompt: |
    メールアドレスの簡易バリデーション関数を実装してください。
    解説不要。Pythonコードのみ出力してください。

    仕様:
    - is_valid_email(email: str) -> bool
    - 形式: xxx@yyy.zzz（@が1つ、ドメインに.が1つ以上）
    - 空文字、空白のみは False
    - 正規表現使用可
  tests:
    tests/test_solution.py: |
      from solution import is_valid_email

      def test_valid_simple():
          assert is_valid_email("test@example.com") is True

      def test_valid_subdomain():
          assert is_valid_email("user@mail.example.com") is True

      def test_invalid_no_at():
          assert is_valid_email("testexample.com") is False

      def test_invalid_no_domain():
          assert is_valid_email("test@") is False

      def test_invalid_no_dot():
          assert is_valid_email("test@example") is False

      def test_empty():
          assert is_valid_email("") is False

      def test_whitespace():
          assert is_valid_email("   ") is False


- id: py_parse_log
  lang: python
  prompt: |
    ログ行をパースする関数を実装してください。
    解説不要。Pythonコードのみ出力してください。

    仕様:
    - parse_log(line: str) -> dict | None
    - ログ形式: "[LEVEL] YYYY-MM-DD HH:MM:SS message"
    - 返り値: {"level": str, "timestamp": str, "message": str}
    - パース失敗時は None を返す
  tests:
    tests/test_solution.py: |
      from solution import parse_log

      def test_info_log():
          result = parse_log("[INFO] 2024-01-15 10:30:00 Application started")
          assert result is not None
          assert result["level"] == "INFO"
          assert result["timestamp"] == "2024-01-15 10:30:00"
          assert result["message"] == "Application started"

      def test_error_log():
          result = parse_log("[ERROR] 2024-01-15 11:00:00 Connection failed")
          assert result is not None
          assert result["level"] == "ERROR"

      def test_multi_word_message():
          result = parse_log("[WARN] 2024-01-15 12:00:00 Memory usage is high")
          assert result is not None
          assert result["message"] == "Memory usage is high"

      def test_invalid_format():
          assert parse_log("Invalid log line") is None

      def test_empty():
          assert parse_log("") is None


# -----------------------------------------------------------------------------
# カテゴリ: デコレータ / 高階関数
# -----------------------------------------------------------------------------

- id: py_retry_decorator
  lang: python
  prompt: |
    リトライ機能を持つデコレータを実装してください。
    解説不要。Pythonコードのみ出力してください。

    仕様:
    - @retry(max_attempts=3)
    - 関数が例外を投げたら再試行
    - max_attempts回失敗したら最後の例外を再raise
    - 成功したら即座に結果を返す
  tests:
    tests/test_solution.py: |
      import pytest
      from solution import retry

      def test_success_first_try():
          @retry(max_attempts=3)
          def always_works():
              return "ok"
          assert always_works() == "ok"

      def test_success_after_retry():
          counter = {"count": 0}
          @retry(max_attempts=3)
          def fails_twice():
              counter["count"] += 1
              if counter["count"] < 3:
                  raise ValueError("fail")
              return "success"
          assert fails_twice() == "success"
          assert counter["count"] == 3

      def test_all_attempts_fail():
          @retry(max_attempts=3)
          def always_fails():
              raise RuntimeError("always fails")
          with pytest.raises(RuntimeError):
              always_fails()

      def test_custom_attempts():
          counter = {"count": 0}
          @retry(max_attempts=5)
          def fails_four_times():
              counter["count"] += 1
              if counter["count"] < 5:
                  raise ValueError("fail")
              return "done"
          assert fails_four_times() == "done"


- id: py_cache_decorator
  lang: python
  prompt: |
    結果をキャッシュするデコレータを実装してください。
    解説不要。Pythonコードのみ出力してください。

    仕様:
    - @cache デコレータ
    - 同じ引数での呼び出しはキャッシュから返す
    - 引数が異なれば新たに計算
    - functools.lru_cache は使用不可
  tests:
    tests/test_solution.py: |
      from solution import cache

      def test_basic_caching():
          call_count = {"n": 0}
          @cache
          def expensive(x):
              call_count["n"] += 1
              return x * 2
          assert expensive(5) == 10
          assert expensive(5) == 10
          assert call_count["n"] == 1  # only called once

      def test_different_args():
          call_count = {"n": 0}
          @cache
          def add_one(x):
              call_count["n"] += 1
              return x + 1
          assert add_one(1) == 2
          assert add_one(2) == 3
          assert add_one(1) == 2
          assert call_count["n"] == 2

      def test_multiple_args():
          @cache
          def add(a, b):
              return a + b
          assert add(1, 2) == 3
          assert add(1, 2) == 3
          assert add(2, 3) == 5


# -----------------------------------------------------------------------------
# カテゴリ: 例外処理 / エラーハンドリング
# -----------------------------------------------------------------------------

- id: py_safe_json_parse
  lang: python
  prompt: |
    安全なJSON解析関数を実装してください。
    解説不要。Pythonコードのみ出力してください。

    仕様:
    - safe_json_parse(text: str, default=None) -> Any
    - 有効なJSONなら解析結果を返す
    - 無効なJSONならdefaultを返す
    - 例外は投げない
  tests:
    tests/test_solution.py: |
      from solution import safe_json_parse

      def test_valid_json():
          assert safe_json_parse('{"key": "value"}') == {"key": "value"}

      def test_valid_array():
          assert safe_json_parse('[1, 2, 3]') == [1, 2, 3]

      def test_invalid_json():
          assert safe_json_parse('not json') is None

      def test_invalid_with_default():
          assert safe_json_parse('invalid', default={}) == {}

      def test_empty_string():
          assert safe_json_parse('', default=[]) == []

      def test_number():
          assert safe_json_parse('42') == 42


- id: py_safe_divide
  lang: python
  prompt: |
    安全な除算関数を実装してください。
    解説不要。Pythonコードのみ出力してください。

    仕様:
    - safe_divide(a, b, default=0) -> float
    - b が 0 の場合は default を返す
    - 数値以外が渡された場合も default を返す
    - 正常な場合は a / b を返す
  tests:
    tests/test_solution.py: |
      from solution import safe_divide

      def test_normal_division():
          assert safe_divide(10, 2) == 5.0

      def test_division_by_zero():
          assert safe_divide(10, 0) == 0

      def test_division_by_zero_custom_default():
          assert safe_divide(10, 0, default=-1) == -1

      def test_invalid_type():
          assert safe_divide("a", "b") == 0

      def test_float_division():
          assert safe_divide(7, 2) == 3.5


# -----------------------------------------------------------------------------
# カテゴリ: データ変換 / シリアライズ
# -----------------------------------------------------------------------------

- id: py_dict_to_xml
  lang: python
  prompt: |
    辞書をXML文字列に変換する関数を実装してください。
    解説不要。Pythonコードのみ出力してください。

    仕様:
    - dict_to_xml(data: dict, root_tag: str = "root") -> str
    - ネストした辞書に対応
    - リストはサポート不要
    - 属性はサポート不要
  tests:
    tests/test_solution.py: |
      from solution import dict_to_xml

      def test_simple():
          result = dict_to_xml({"name": "Alice"}, "person")
          assert "<person>" in result
          assert "<name>Alice</name>" in result
          assert "</person>" in result

      def test_nested():
          result = dict_to_xml({"user": {"name": "Bob"}}, "data")
          assert "<user>" in result
          assert "<name>Bob</name>" in result

      def test_empty():
          result = dict_to_xml({}, "empty")
          assert "<empty>" in result
          assert "</empty>" in result

      def test_multiple_keys():
          result = dict_to_xml({"a": "1", "b": "2"}, "root")
          assert "<a>1</a>" in result
          assert "<b>2</b>" in result


# =============================================================================
# エージェント能力評価問題（Agent-Level Challenges）
# 曖昧な要件、設計判断、エッジケース発見、リファクタリング等
#
# 難易度レベル:
#   Level 1 (★☆☆☆) - Easy:    基本的な設計判断、少しだけ曖昧な要件
#   Level 2 (★★☆☆) - Medium:  中程度の曖昧さ、複数の設計判断が必要
#   Level 3 (★★★☆) - Hard:    複雑な設計判断、複数の技術領域にまたがる
#   Level 4 (★★★★) - Expert:  実務レベルの複雑な問題、多くの考慮事項
# =============================================================================

# =============================================================================
# Level 1 (★☆☆☆) - Easy: 入門レベルのエージェント問題
# =============================================================================

- id: py_agent_L1_url_shortener
  lang: python
  prompt: |
    URLを短縮する簡単なサービスを実装してください。
    解説不要。Pythonコードのみ出力してください。

    要件:
    - 長いURLを短いIDに変換
    - 短いIDから元のURLを復元
    - インメモリで動作（永続化不要）
  tests:
    tests/test_solution.py: |
      from solution import UrlShortener

      def test_shorten_and_restore():
          shortener = UrlShortener()
          short_id = shortener.shorten("https://example.com/very/long/path")
          original = shortener.restore(short_id)
          assert original == "https://example.com/very/long/path"

      def test_short_id_is_short():
          shortener = UrlShortener()
          short_id = shortener.shorten("https://example.com/a/b/c/d/e/f")
          assert len(short_id) <= 10

      def test_same_url_different_ids_or_same():
          shortener = UrlShortener()
          id1 = shortener.shorten("https://example.com")
          id2 = shortener.shorten("https://example.com")
          # 同じURLは同じIDでも異なるIDでも可
          assert shortener.restore(id1) == shortener.restore(id2)

      def test_invalid_id():
          shortener = UrlShortener()
          result = shortener.restore("nonexistent")
          assert result is None


- id: py_agent_L1_logger
  lang: python
  prompt: |
    シンプルなロガーを実装してください。
    解説不要。Pythonコードのみ出力してください。

    要件:
    - ログレベル（DEBUG, INFO, WARN, ERROR）をサポート
    - 設定したレベル以上のログのみ出力
    - タイムスタンプ付き

    実装の詳細はお任せします。
  tests:
    tests/test_solution.py: |
      from solution import Logger, LogLevel

      def test_info_log(capsys):
          logger = Logger(level=LogLevel.INFO)
          logger.info("test message")
          captured = capsys.readouterr()
          assert "test message" in captured.out
          assert "INFO" in captured.out

      def test_level_filtering(capsys):
          logger = Logger(level=LogLevel.WARN)
          logger.debug("debug msg")
          logger.info("info msg")
          logger.warn("warn msg")
          captured = capsys.readouterr()
          assert "debug msg" not in captured.out
          assert "info msg" not in captured.out
          assert "warn msg" in captured.out

      def test_timestamp_present(capsys):
          logger = Logger(level=LogLevel.INFO)
          logger.info("test")
          captured = capsys.readouterr()
          # タイムスタンプが含まれている（数字とコロンの組み合わせ）
          import re
          assert re.search(r'\d{2}:\d{2}:\d{2}', captured.out) or re.search(r'\d{4}-\d{2}-\d{2}', captured.out)

      def test_error_log(capsys):
          logger = Logger(level=LogLevel.DEBUG)
          logger.error("error occurred")
          captured = capsys.readouterr()
          assert "ERROR" in captured.out


- id: py_agent_L1_calculator
  lang: python
  prompt: |
    文字列の数式を評価する電卓を実装してください。
    解説不要。Pythonコードのみ出力してください。

    要件:
    - 四則演算（+, -, *, /）をサポート
    - カッコ対応
    - 安全に実装（eval禁止）
  tests:
    tests/test_solution.py: |
      from solution import Calculator

      def test_simple_add():
          calc = Calculator()
          assert calc.evaluate("2 + 3") == 5

      def test_multiply():
          calc = Calculator()
          assert calc.evaluate("4 * 5") == 20

      def test_precedence():
          calc = Calculator()
          assert calc.evaluate("2 + 3 * 4") == 14

      def test_parentheses():
          calc = Calculator()
          assert calc.evaluate("(2 + 3) * 4") == 20

      def test_nested_parentheses():
          calc = Calculator()
          assert calc.evaluate("((1 + 2) * (3 + 4))") == 21

      def test_division():
          calc = Calculator()
          assert calc.evaluate("10 / 2") == 5


- id: py_agent_L1_todo_list
  lang: python
  prompt: |
    シンプルなToDoリスト管理クラスを実装してください。
    解説不要。Pythonコードのみ出力してください。

    基本要件:
    - タスクの追加・削除・完了
    - 一覧表示

    「使いやすいAPI」を意識して設計してください。
  tests:
    tests/test_solution.py: |
      from solution import TodoList

      def test_add_task():
          todo = TodoList()
          task_id = todo.add("Buy milk")
          assert task_id is not None
          tasks = todo.list_all()
          assert len(tasks) == 1

      def test_complete_task():
          todo = TodoList()
          task_id = todo.add("Buy milk")
          todo.complete(task_id)
          task = todo.get(task_id)
          assert task["completed"] is True

      def test_delete_task():
          todo = TodoList()
          task_id = todo.add("Buy milk")
          todo.delete(task_id)
          assert todo.get(task_id) is None

      def test_list_pending():
          todo = TodoList()
          todo.add("Task 1")
          id2 = todo.add("Task 2")
          todo.complete(id2)
          pending = todo.list_pending()
          assert len(pending) == 1

      def test_task_has_title():
          todo = TodoList()
          task_id = todo.add("Important task")
          task = todo.get(task_id)
          assert task["title"] == "Important task"


- id: py_agent_L1_text_stats
  lang: python
  prompt: |
    テキストの統計情報を計算するクラスを実装してください。
    解説不要。Pythonコードのみ出力してください。

    最低限の要件:
    - 単語数、文字数、行数をカウント

    他に有用な統計があれば追加してください。
  tests:
    tests/test_solution.py: |
      from solution import TextStats

      def test_word_count():
          stats = TextStats("Hello world")
          assert stats.word_count() == 2

      def test_char_count():
          stats = TextStats("Hello")
          assert stats.char_count() == 5

      def test_line_count():
          stats = TextStats("Line 1\nLine 2\nLine 3")
          assert stats.line_count() == 3

      def test_empty_text():
          stats = TextStats("")
          assert stats.word_count() == 0
          assert stats.line_count() == 0

      def test_average_word_length():
          stats = TextStats("cat dog bird")
          avg = stats.average_word_length()
          assert 3.0 <= avg <= 4.0  # (3+3+4)/3 ≈ 3.33


# =============================================================================
# Level 2 (★★☆☆) - Medium: 中級レベルのエージェント問題
# =============================================================================

- id: py_agent_L2_scheduler
  lang: python
  prompt: |
    タスクスケジューラを実装してください。
    解説不要。Pythonコードのみ出力してください。

    要件:
    - 指定時間後にタスクを実行
    - 定期実行（interval）
    - タスクのキャンセル

    実際の並行処理は不要。シミュレーションでOK。
  tests:
    tests/test_solution.py: |
      import time
      from solution import Scheduler

      def test_schedule_once():
          scheduler = Scheduler()
          results = []
          scheduler.schedule(lambda: results.append("done"), delay=0.05)
          scheduler.run_pending()
          time.sleep(0.1)
          scheduler.run_pending()
          assert "done" in results

      def test_schedule_interval():
          scheduler = Scheduler()
          count = [0]
          task_id = scheduler.schedule_interval(lambda: count.__setitem__(0, count[0]+1), interval=0.05)
          for _ in range(5):
              time.sleep(0.06)
              scheduler.run_pending()
          assert count[0] >= 3

      def test_cancel_task():
          scheduler = Scheduler()
          results = []
          task_id = scheduler.schedule(lambda: results.append("done"), delay=0.1)
          scheduler.cancel(task_id)
          time.sleep(0.15)
          scheduler.run_pending()
          assert "done" not in results

      def test_multiple_tasks():
          scheduler = Scheduler()
          results = []
          scheduler.schedule(lambda: results.append("a"), delay=0.02)
          scheduler.schedule(lambda: results.append("b"), delay=0.01)
          time.sleep(0.05)
          scheduler.run_pending()
          assert "a" in results and "b" in results


- id: py_agent_L2_template_engine
  lang: python
  prompt: |
    シンプルなテンプレートエンジンを実装してください。
    解説不要。Pythonコードのみ出力してください。

    要件:
    - 変数の置換 {{ name }}
    - 条件分岐 {% if condition %}...{% endif %}
    - ループ {% for item in items %}...{% endfor %}

    Jinja2のような本格的なものは不要。基本機能のみ。
  tests:
    tests/test_solution.py: |
      from solution import TemplateEngine

      def test_variable_substitution():
          engine = TemplateEngine()
          result = engine.render("Hello {{ name }}!", {"name": "World"})
          assert result == "Hello World!"

      def test_if_true():
          engine = TemplateEngine()
          result = engine.render("{% if show %}Visible{% endif %}", {"show": True})
          assert "Visible" in result

      def test_if_false():
          engine = TemplateEngine()
          result = engine.render("{% if show %}Visible{% endif %}", {"show": False})
          assert "Visible" not in result

      def test_for_loop():
          engine = TemplateEngine()
          template = "{% for item in items %}{{ item }},{% endfor %}"
          result = engine.render(template, {"items": ["a", "b", "c"]})
          assert "a" in result and "b" in result and "c" in result

      def test_combined():
          engine = TemplateEngine()
          template = "Users: {% for u in users %}{{ u }}{% endfor %}"
          result = engine.render(template, {"users": ["Alice", "Bob"]})
          assert "Alice" in result and "Bob" in result


- id: py_agent_L2_command_parser
  lang: python
  prompt: |
    CLIコマンドパーサーを実装してください。
    解説不要。Pythonコードのみ出力してください。

    要件:
    - サブコマンドのサポート
    - 位置引数とオプション引数
    - ヘルプ生成
    - バリデーション

    例: myapp user create --name Alice
  tests:
    tests/test_solution.py: |
      from solution import CommandParser

      def test_simple_command():
          parser = CommandParser()
          parser.add_command("greet", lambda args: f"Hello {args['name']}")
          parser.add_argument("greet", "name", required=True)
          result = parser.parse_and_execute(["greet", "--name", "Alice"])
          assert result == "Hello Alice"

      def test_subcommand():
          parser = CommandParser()
          parser.add_command("user")
          parser.add_subcommand("user", "create", lambda args: f"Created {args['name']}")
          parser.add_argument("user.create", "name", required=True)
          result = parser.parse_and_execute(["user", "create", "--name", "Bob"])
          assert "Created Bob" in result

      def test_optional_argument():
          parser = CommandParser()
          parser.add_command("greet", lambda args: f"Hello {args.get('name', 'World')}")
          parser.add_argument("greet", "name", required=False, default="World")
          result = parser.parse_and_execute(["greet"])
          assert result == "Hello World"

      def test_missing_required():
          parser = CommandParser()
          parser.add_command("test", lambda args: "ok")
          parser.add_argument("test", "required_arg", required=True)
          try:
              parser.parse_and_execute(["test"])
              assert False
          except (ValueError, SystemExit, Exception):
              pass


- id: py_agent_L2_http_client
  lang: python
  prompt: |
    HTTPクライアントのラッパーを実装してください。
    解説不要。Pythonコードのみ出力してください。

    要件:
    - リトライ機能
    - タイムアウト設定
    - レスポンスのキャッシュ
    - 共通ヘッダの設定

    実際の通信は不要。インターフェースとロジックの実装のみ。
  tests:
    tests/test_solution.py: |
      from solution import HttpClient, MockTransport

      def test_get_request():
          transport = MockTransport({"GET /users": {"status": 200, "body": []}})
          client = HttpClient(transport=transport)
          resp = client.get("/users")
          assert resp.status == 200

      def test_common_headers():
          transport = MockTransport({"GET /api": {"status": 200, "body": {}}})
          client = HttpClient(transport=transport, headers={"Authorization": "Bearer token"})
          client.get("/api")
          assert transport.last_request["headers"]["Authorization"] == "Bearer token"

      def test_retry_on_failure():
          attempts = [0]
          def failing_transport(method, url, **kwargs):
              attempts[0] += 1
              if attempts[0] < 3:
                  raise ConnectionError("fail")
              return {"status": 200, "body": {}}
          client = HttpClient(transport=failing_transport, retries=3)
          resp = client.get("/api")
          assert resp.status == 200
          assert attempts[0] == 3

      def test_cache():
          call_count = [0]
          def counting_transport(method, url, **kwargs):
              call_count[0] += 1
              return {"status": 200, "body": {"data": "value"}}
          client = HttpClient(transport=counting_transport, cache_ttl=60)
          client.get("/api")
          client.get("/api")
          assert call_count[0] == 1  # cached


# -----------------------------------------------------------------------------
# カテゴリ: 曖昧な要件からの実装（Vague Requirements）
# -----------------------------------------------------------------------------

- id: py_agent_shopping_cart
  lang: python
  prompt: |
    ECサイトのショッピングカート機能を実装してください。
    解説不要。Pythonコードのみ出力してください。

    要件（意図的に曖昧）:
    - カートに商品を追加・削除できる
    - 合計金額を計算できる
    - 割引があればよしなに対応

    ヒント: 実務では要件が曖昧なことが多い。合理的な設計判断をして実装してください。
  tests:
    tests/test_solution.py: |
      from solution import ShoppingCart

      def test_add_item():
          cart = ShoppingCart()
          cart.add_item("apple", price=100, quantity=2)
          assert cart.get_total() == 200

      def test_remove_item():
          cart = ShoppingCart()
          cart.add_item("apple", price=100, quantity=3)
          cart.remove_item("apple", quantity=1)
          assert cart.get_total() == 200

      def test_remove_all():
          cart = ShoppingCart()
          cart.add_item("apple", price=100, quantity=2)
          cart.remove_item("apple")  # 数量指定なしで全削除
          assert cart.get_total() == 0

      def test_percentage_discount():
          cart = ShoppingCart()
          cart.add_item("apple", price=100, quantity=10)
          cart.apply_discount(percent=10)  # 10%オフ
          assert cart.get_total() == 900

      def test_fixed_discount():
          cart = ShoppingCart()
          cart.add_item("apple", price=100, quantity=5)
          cart.apply_discount(amount=50)  # 50円引き
          assert cart.get_total() == 450

      def test_empty_cart():
          cart = ShoppingCart()
          assert cart.get_total() == 0

      def test_item_count():
          cart = ShoppingCart()
          cart.add_item("apple", price=100, quantity=2)
          cart.add_item("banana", price=50, quantity=3)
          assert cart.item_count() == 5


- id: py_agent_password_policy
  lang: python
  prompt: |
    パスワードポリシーチェッカーを実装してください。
    解説不要。Pythonコードのみ出力してください。

    要件（曖昧）:
    - パスワードの強度をチェックする
    - 弱いパスワードは拒否
    - 一般的なセキュリティ要件を考慮

    あなたの知識で適切なポリシーを設計してください。
  tests:
    tests/test_solution.py: |
      from solution import check_password, PasswordStrength

      def test_too_short():
          result = check_password("abc")
          assert result.is_valid is False
          assert "length" in result.reason.lower() or "short" in result.reason.lower()

      def test_no_uppercase():
          result = check_password("password123!")
          assert result.is_valid is False

      def test_no_lowercase():
          result = check_password("PASSWORD123!")
          assert result.is_valid is False

      def test_no_digit():
          result = check_password("PasswordTest!")
          assert result.is_valid is False

      def test_no_special():
          result = check_password("Password123")
          assert result.is_valid is False

      def test_valid_password():
          result = check_password("SecurePass123!")
          assert result.is_valid is True

      def test_common_password():
          # "password" や "123456" のような一般的なパスワードは拒否すべき
          result = check_password("Password1!")
          # password という単語を含む場合は弱いと判断すべき
          assert result.strength != PasswordStrength.STRONG


- id: py_agent_config_loader
  lang: python
  prompt: |
    アプリケーション設定ローダーを実装してください。
    解説不要。Pythonコードのみ出力してください。

    要件（曖昧）:
    - 設定ファイル（JSON/YAML/環境変数）から設定を読み込む
    - デフォルト値のサポート
    - 必須設定のバリデーション

    実務で必要になりそうな機能を適切に設計してください。
  tests:
    tests/test_solution.py: |
      import os
      from solution import ConfigLoader

      def test_load_from_dict():
          loader = ConfigLoader({"db_host": "localhost", "db_port": 5432})
          assert loader.get("db_host") == "localhost"
          assert loader.get("db_port") == 5432

      def test_default_value():
          loader = ConfigLoader({})
          assert loader.get("missing_key", default="default") == "default"

      def test_nested_config():
          loader = ConfigLoader({"database": {"host": "localhost", "port": 5432}})
          assert loader.get("database.host") == "localhost"
          assert loader.get("database.port") == 5432

      def test_env_override():
          os.environ["APP_DB_HOST"] = "production-db"
          loader = ConfigLoader({"db_host": "localhost"}, env_prefix="APP_")
          assert loader.get("db_host") == "production-db"
          del os.environ["APP_DB_HOST"]

      def test_required_validation():
          loader = ConfigLoader({})
          loader.require("api_key")
          try:
              loader.validate()
              assert False, "Should raise error for missing required key"
          except ValueError as e:
              assert "api_key" in str(e)

      def test_type_casting():
          os.environ["APP_PORT"] = "8080"
          loader = ConfigLoader({}, env_prefix="APP_")
          assert loader.get("port", type=int) == 8080
          del os.environ["APP_PORT"]


# -----------------------------------------------------------------------------
# カテゴリ: リファクタリング（Refactoring）
# -----------------------------------------------------------------------------

- id: py_agent_refactor_spaghetti
  lang: python
  prompt: |
    以下のスパゲッティコードをリファクタリングしてください。
    機能は維持しつつ、可読性・保守性を向上させてください。
    解説不要。Pythonコードのみ出力してください。

    元コード:
    ```python
    def process_order(order_data):
        if order_data:
            if "items" in order_data:
                total = 0
                for item in order_data["items"]:
                    if "price" in item and "quantity" in item:
                        if item["quantity"] > 0:
                            total += item["price"] * item["quantity"]
                        else:
                            return {"error": "invalid quantity"}
                    else:
                        return {"error": "missing price or quantity"}
                if "discount" in order_data:
                    if order_data["discount"] > 0 and order_data["discount"] <= 100:
                        total = total * (100 - order_data["discount"]) / 100
                    else:
                        return {"error": "invalid discount"}
                if "tax_rate" in order_data:
                    if order_data["tax_rate"] >= 0:
                        total = total * (1 + order_data["tax_rate"] / 100)
                    else:
                        return {"error": "invalid tax rate"}
                return {"total": round(total, 2), "status": "success"}
            else:
                return {"error": "no items"}
        else:
            return {"error": "no data"}
    ```

    要件:
    - 同じ入出力を維持（テストが通ること）
    - ネストを減らす
    - 早期リターンパターンを使用
    - 適切な関数分割
  tests:
    tests/test_solution.py: |
      from solution import process_order

      def test_basic_order():
          order = {"items": [{"price": 100, "quantity": 2}]}
          result = process_order(order)
          assert result["status"] == "success"
          assert result["total"] == 200

      def test_with_discount():
          order = {"items": [{"price": 100, "quantity": 1}], "discount": 10}
          result = process_order(order)
          assert result["total"] == 90

      def test_with_tax():
          order = {"items": [{"price": 100, "quantity": 1}], "tax_rate": 10}
          result = process_order(order)
          assert result["total"] == 110

      def test_empty_data():
          result = process_order(None)
          assert "error" in result

      def test_no_items():
          result = process_order({})
          assert result["error"] == "no items"

      def test_invalid_quantity():
          order = {"items": [{"price": 100, "quantity": -1}]}
          result = process_order(order)
          assert result["error"] == "invalid quantity"

      def test_multiple_items():
          order = {"items": [
              {"price": 100, "quantity": 2},
              {"price": 50, "quantity": 3}
          ]}
          result = process_order(order)
          assert result["total"] == 350


- id: py_agent_refactor_god_class
  lang: python
  prompt: |
    以下の「神クラス」をリファクタリングしてください。
    単一責任の原則に従い、適切にクラスを分割してください。
    解説不要。Pythonコードのみ出力してください。

    元コード:
    ```python
    class UserManager:
        def __init__(self):
            self.users = {}
            self.email_log = []

        def create_user(self, user_id, name, email):
            self.users[user_id] = {"name": name, "email": email, "password": None}

        def set_password(self, user_id, password):
            if len(password) < 8:
                raise ValueError("Password too short")
            import hashlib
            hashed = hashlib.sha256(password.encode()).hexdigest()
            self.users[user_id]["password"] = hashed

        def verify_password(self, user_id, password):
            import hashlib
            hashed = hashlib.sha256(password.encode()).hexdigest()
            return self.users[user_id]["password"] == hashed

        def send_welcome_email(self, user_id):
            email = self.users[user_id]["email"]
            self.email_log.append({"to": email, "subject": "Welcome!", "sent": True})

        def send_password_reset(self, user_id):
            email = self.users[user_id]["email"]
            self.email_log.append({"to": email, "subject": "Password Reset", "sent": True})

        def get_email_history(self, user_id):
            email = self.users[user_id]["email"]
            return [e for e in self.email_log if e["to"] == email]
    ```

    要件:
    - UserRepository: ユーザーの永続化
    - PasswordService: パスワード処理
    - EmailService: メール送信
    - UserManager: これらを統合するファサード
  tests:
    tests/test_solution.py: |
      from solution import UserManager, UserRepository, PasswordService, EmailService

      def test_user_repository():
          repo = UserRepository()
          repo.save("u1", {"name": "Alice", "email": "alice@example.com"})
          user = repo.find("u1")
          assert user["name"] == "Alice"

      def test_password_service():
          svc = PasswordService()
          hashed = svc.hash_password("secretpass")
          assert svc.verify_password("secretpass", hashed) is True
          assert svc.verify_password("wrong", hashed) is False

      def test_password_validation():
          svc = PasswordService()
          try:
              svc.hash_password("short")
              assert False
          except ValueError:
              pass

      def test_email_service():
          svc = EmailService()
          svc.send("test@example.com", "Subject", "Body")
          history = svc.get_history("test@example.com")
          assert len(history) == 1

      def test_user_manager_integration():
          manager = UserManager()
          manager.create_user("u1", "Bob", "bob@example.com")
          manager.set_password("u1", "securepassword")
          assert manager.verify_password("u1", "securepassword") is True
          manager.send_welcome_email("u1")


# -----------------------------------------------------------------------------
# カテゴリ: エッジケース発見（Edge Case Discovery）
# -----------------------------------------------------------------------------

- id: py_agent_date_range
  lang: python
  prompt: |
    日付範囲を扱うユーティリティを実装してください。
    解説不要。Pythonコードのみ出力してください。

    基本要件:
    - DateRange クラス（start, end）
    - 範囲内の日数を計算
    - 2つの範囲の重複を検出

    注意: 日付処理には多くのエッジケースがあります。
    実務で問題になりそうなケースを考慮してください。
  tests:
    tests/test_solution.py: |
      from datetime import date
      from solution import DateRange

      def test_basic_range():
          r = DateRange(date(2024, 1, 1), date(2024, 1, 10))
          assert r.days() == 10  # 両端含む

      def test_single_day():
          r = DateRange(date(2024, 1, 1), date(2024, 1, 1))
          assert r.days() == 1

      def test_invalid_range():
          # end < start は例外
          try:
              DateRange(date(2024, 1, 10), date(2024, 1, 1))
              assert False, "Should raise ValueError"
          except ValueError:
              pass

      def test_overlap_full():
          r1 = DateRange(date(2024, 1, 1), date(2024, 1, 10))
          r2 = DateRange(date(2024, 1, 5), date(2024, 1, 15))
          assert r1.overlaps(r2) is True

      def test_no_overlap():
          r1 = DateRange(date(2024, 1, 1), date(2024, 1, 5))
          r2 = DateRange(date(2024, 1, 10), date(2024, 1, 15))
          assert r1.overlaps(r2) is False

      def test_adjacent_no_overlap():
          # 1/5で終わり、1/6で始まる → 重複なし
          r1 = DateRange(date(2024, 1, 1), date(2024, 1, 5))
          r2 = DateRange(date(2024, 1, 6), date(2024, 1, 10))
          assert r1.overlaps(r2) is False

      def test_touch_boundary():
          # 1/5で両方が境界 → 重複あり
          r1 = DateRange(date(2024, 1, 1), date(2024, 1, 5))
          r2 = DateRange(date(2024, 1, 5), date(2024, 1, 10))
          assert r1.overlaps(r2) is True

      def test_contains():
          r1 = DateRange(date(2024, 1, 1), date(2024, 1, 31))
          assert r1.contains(date(2024, 1, 15)) is True
          assert r1.contains(date(2024, 2, 1)) is False

      def test_year_boundary():
          # 年をまたぐ範囲
          r = DateRange(date(2023, 12, 25), date(2024, 1, 5))
          assert r.days() == 12


- id: py_agent_rate_limiter
  lang: python
  prompt: |
    APIレート制限を実装してください。
    解説不要。Pythonコードのみ出力してください。

    基本要件:
    - 指定された時間窓内のリクエスト数を制限
    - クライアントIDごとに制限

    考慮すべき点:
    - 時間窓の扱い（スライディング/固定）
    - 同時アクセス
    - メモリ効率
  tests:
    tests/test_solution.py: |
      import time
      from solution import RateLimiter

      def test_basic_limit():
          limiter = RateLimiter(max_requests=3, window_seconds=10)
          assert limiter.allow("client1") is True
          assert limiter.allow("client1") is True
          assert limiter.allow("client1") is True
          assert limiter.allow("client1") is False  # 4th request blocked

      def test_different_clients():
          limiter = RateLimiter(max_requests=2, window_seconds=10)
          assert limiter.allow("client1") is True
          assert limiter.allow("client1") is True
          assert limiter.allow("client1") is False
          assert limiter.allow("client2") is True  # different client

      def test_window_reset():
          limiter = RateLimiter(max_requests=2, window_seconds=0.1)
          assert limiter.allow("client1") is True
          assert limiter.allow("client1") is True
          assert limiter.allow("client1") is False
          time.sleep(0.15)  # wait for window to reset
          assert limiter.allow("client1") is True

      def test_remaining():
          limiter = RateLimiter(max_requests=5, window_seconds=10)
          limiter.allow("client1")
          limiter.allow("client1")
          assert limiter.remaining("client1") == 3


# -----------------------------------------------------------------------------
# カテゴリ: セキュリティ考慮（Security Awareness）
# -----------------------------------------------------------------------------

- id: py_agent_secure_token
  lang: python
  prompt: |
    セキュアなトークン生成・検証システムを実装してください。
    解説不要。Pythonコードのみ出力してください。

    要件:
    - ユーザーIDからトークンを生成
    - トークンからユーザーIDを復元・検証
    - 有効期限のサポート

    セキュリティを意識した実装をしてください。
  tests:
    tests/test_solution.py: |
      import time
      from solution import TokenService

      def test_generate_and_verify():
          service = TokenService(secret="my-secret-key")
          token = service.generate("user123")
          result = service.verify(token)
          assert result["user_id"] == "user123"
          assert result["valid"] is True

      def test_invalid_token():
          service = TokenService(secret="my-secret-key")
          result = service.verify("invalid-token")
          assert result["valid"] is False

      def test_tampered_token():
          service = TokenService(secret="my-secret-key")
          token = service.generate("user123")
          # トークンを改ざん
          tampered = token[:-5] + "xxxxx"
          result = service.verify(tampered)
          assert result["valid"] is False

      def test_different_secret():
          service1 = TokenService(secret="secret1")
          service2 = TokenService(secret="secret2")
          token = service1.generate("user123")
          result = service2.verify(token)
          assert result["valid"] is False

      def test_expiration():
          service = TokenService(secret="my-secret", default_ttl=0.1)
          token = service.generate("user123")
          time.sleep(0.15)
          result = service.verify(token)
          assert result["valid"] is False
          assert "expired" in result.get("reason", "").lower()

      def test_token_uniqueness():
          service = TokenService(secret="my-secret")
          token1 = service.generate("user123")
          token2 = service.generate("user123")
          # 同じユーザーでも毎回異なるトークン
          assert token1 != token2


- id: py_agent_input_sanitizer
  lang: python
  prompt: |
    ユーザー入力のサニタイズ機能を実装してください。
    解説不要。Pythonコードのみ出力してください。

    要件:
    - HTML/SQLインジェクション対策
    - XSS対策
    - 危険な文字のエスケープ

    セキュリティベストプラクティスに従ってください。
  tests:
    tests/test_solution.py: |
      from solution import sanitize_html, sanitize_sql, Sanitizer

      def test_html_script_tag():
          result = sanitize_html("<script>alert('xss')</script>")
          assert "<script>" not in result
          assert "alert" not in result or "&" in result

      def test_html_event_handler():
          result = sanitize_html('<img onerror="alert(1)" src="x">')
          assert "onerror" not in result or "onerror=" not in result

      def test_html_preserve_safe():
          result = sanitize_html("Hello <b>World</b>")
          # 安全なタグは保持しても良い
          assert "Hello" in result
          assert "World" in result

      def test_sql_quote_escape():
          result = sanitize_sql("O'Brien")
          assert "'" not in result or "''" in result or "\\'" in result

      def test_sql_semicolon():
          result = sanitize_sql("1; DROP TABLE users;")
          # セミコロンが無害化されている
          assert "DROP TABLE" not in result or result != "1; DROP TABLE users;"

      def test_sanitizer_class():
          s = Sanitizer()
          # 複数のサニタイズを適用
          result = s.sanitize("<script>alert(1)</script>", context="html")
          assert "<script>" not in result

      def test_null_byte():
          result = sanitize_html("test\x00injection")
          assert "\x00" not in result


# -----------------------------------------------------------------------------
# カテゴリ: 複雑なバグ修正（Complex Debugging）
# -----------------------------------------------------------------------------

- id: py_agent_debug_race_condition
  lang: python
  prompt: |
    以下のコードには競合状態のバグがあります。修正してください。
    解説不要。Pythonコードのみ出力してください。

    元コード:
    ```python
    class Counter:
        def __init__(self):
            self.value = 0

        def increment(self):
            current = self.value
            # 何らかの処理（遅延をシミュレート）
            self.value = current + 1

        def get_value(self):
            return self.value
    ```

    要件:
    - スレッドセーフにする
    - 複数スレッドから同時にincrementしても正確にカウント
  tests:
    tests/test_solution.py: |
      import threading
      from solution import Counter

      def test_single_thread():
          counter = Counter()
          for _ in range(100):
              counter.increment()
          assert counter.get_value() == 100

      def test_multi_thread():
          counter = Counter()
          threads = []
          for _ in range(10):
              t = threading.Thread(target=lambda: [counter.increment() for _ in range(100)])
              threads.append(t)
          for t in threads:
              t.start()
          for t in threads:
              t.join()
          assert counter.get_value() == 1000

      def test_decrement():
          counter = Counter()
          counter.increment()
          counter.increment()
          counter.decrement()
          assert counter.get_value() == 1

      def test_reset():
          counter = Counter()
          counter.increment()
          counter.increment()
          counter.reset()
          assert counter.get_value() == 0


- id: py_agent_debug_memory_leak
  lang: python
  prompt: |
    以下のコードにはメモリリークの可能性があります。修正してください。
    解説不要。Pythonコードのみ出力してください。

    元コード:
    ```python
    class EventEmitter:
        _listeners = {}  # クラス変数（問題あり）

        def on(self, event, callback):
            if event not in self._listeners:
                self._listeners[event] = []
            self._listeners[event].append(callback)

        def emit(self, event, *args):
            if event in self._listeners:
                for callback in self._listeners[event]:
                    callback(*args)

        def off(self, event, callback=None):
            if event in self._listeners:
                if callback:
                    self._listeners[event].remove(callback)
                else:
                    del self._listeners[event]
    ```

    問題点:
    - クラス変数でリスナーを共有している
    - インスタンスを破棄してもリスナーが残る
  tests:
    tests/test_solution.py: |
      from solution import EventEmitter

      def test_basic_emit():
          emitter = EventEmitter()
          results = []
          emitter.on("test", lambda x: results.append(x))
          emitter.emit("test", "hello")
          assert results == ["hello"]

      def test_multiple_listeners():
          emitter = EventEmitter()
          results = []
          emitter.on("test", lambda x: results.append(f"a:{x}"))
          emitter.on("test", lambda x: results.append(f"b:{x}"))
          emitter.emit("test", "data")
          assert len(results) == 2

      def test_off_specific():
          emitter = EventEmitter()
          results = []
          handler = lambda x: results.append(x)
          emitter.on("test", handler)
          emitter.off("test", handler)
          emitter.emit("test", "data")
          assert results == []

      def test_instance_isolation():
          # 各インスタンスは独立したリスナーを持つべき
          emitter1 = EventEmitter()
          emitter2 = EventEmitter()
          results1 = []
          results2 = []
          emitter1.on("test", lambda x: results1.append(x))
          emitter2.on("test", lambda x: results2.append(x))
          emitter1.emit("test", "for1")
          assert results1 == ["for1"]
          assert results2 == []  # emitter2には影響なし

      def test_cleanup():
          emitter = EventEmitter()
          emitter.on("test", lambda x: x)
          emitter.off("test")
          # イベントが登録されていない状態でemitしてもエラーにならない
          emitter.emit("test", "data")


# -----------------------------------------------------------------------------
# カテゴリ: パフォーマンス最適化（Performance Optimization）
# -----------------------------------------------------------------------------

- id: py_agent_optimize_search
  lang: python
  prompt: |
    以下の非効率なコードを最適化してください。
    解説不要。Pythonコードのみ出力してください。

    元コード（非効率）:
    ```python
    def find_duplicates(items):
        duplicates = []
        for i, item in enumerate(items):
            for j, other in enumerate(items):
                if i != j and item == other and item not in duplicates:
                    duplicates.append(item)
        return duplicates

    def find_common(list1, list2):
        common = []
        for item in list1:
            for other in list2:
                if item == other and item not in common:
                    common.append(item)
        return common
    ```

    要件:
    - O(n^2) を O(n) に改善
    - 同じ結果を返すこと
  tests:
    tests/test_solution.py: |
      import time
      from solution import find_duplicates, find_common

      def test_find_duplicates_basic():
          result = find_duplicates([1, 2, 3, 2, 4, 3])
          assert set(result) == {2, 3}

      def test_find_duplicates_none():
          result = find_duplicates([1, 2, 3, 4])
          assert result == []

      def test_find_duplicates_all():
          result = find_duplicates([1, 1, 1, 1])
          assert result == [1]

      def test_find_common_basic():
          result = find_common([1, 2, 3], [2, 3, 4])
          assert set(result) == {2, 3}

      def test_find_common_none():
          result = find_common([1, 2], [3, 4])
          assert result == []

      def test_performance_duplicates():
          # 大きなリストでも高速に動作すること
          large_list = list(range(10000)) + list(range(5000))
          start = time.time()
          result = find_duplicates(large_list)
          elapsed = time.time() - start
          assert elapsed < 0.5  # 0.5秒以内
          assert len(result) == 5000

      def test_performance_common():
          list1 = list(range(10000))
          list2 = list(range(5000, 15000))
          start = time.time()
          result = find_common(list1, list2)
          elapsed = time.time() - start
          assert elapsed < 0.5
          assert len(result) == 5000


# -----------------------------------------------------------------------------
# カテゴリ: 実務的なユーティリティ（Practical Utilities）
# -----------------------------------------------------------------------------

- id: py_agent_retry_with_backoff
  lang: python
  prompt: |
    実務で使えるリトライ機能を実装してください。
    解説不要。Pythonコードのみ出力してください。

    要件:
    - 指数バックオフ（exponential backoff）
    - 最大リトライ回数
    - リトライ対象の例外を指定可能
    - ジッター（jitter）でサンダリングヘッド問題を回避

    実務で必要な機能を盛り込んでください。
  tests:
    tests/test_solution.py: |
      import time
      from solution import retry_with_backoff, RetryConfig

      def test_immediate_success():
          call_count = [0]
          @retry_with_backoff(max_retries=3)
          def success():
              call_count[0] += 1
              return "ok"
          assert success() == "ok"
          assert call_count[0] == 1

      def test_retry_then_success():
          call_count = [0]
          @retry_with_backoff(max_retries=3, base_delay=0.01)
          def fail_twice():
              call_count[0] += 1
              if call_count[0] < 3:
                  raise ValueError("fail")
              return "success"
          assert fail_twice() == "success"
          assert call_count[0] == 3

      def test_max_retries_exceeded():
          @retry_with_backoff(max_retries=2, base_delay=0.01)
          def always_fail():
              raise RuntimeError("always fails")
          try:
              always_fail()
              assert False
          except RuntimeError:
              pass

      def test_retry_specific_exception():
          call_count = [0]
          @retry_with_backoff(max_retries=3, retry_on=(ValueError,), base_delay=0.01)
          def fail_with_type_error():
              call_count[0] += 1
              raise TypeError("not retryable")
          try:
              fail_with_type_error()
              assert False
          except TypeError:
              pass
          assert call_count[0] == 1  # no retry

      def test_config_object():
          config = RetryConfig(max_retries=5, base_delay=0.1, max_delay=1.0)
          assert config.max_retries == 5
          assert config.base_delay == 0.1


- id: py_agent_data_pipeline
  lang: python
  prompt: |
    データ処理パイプラインを実装してください。
    解説不要。Pythonコードのみ出力してください。

    要件:
    - 複数の変換ステップをチェーンできる
    - 各ステップはエラーハンドリングできる
    - フィルタリングとマッピングをサポート

    例: Pipeline().filter(条件).map(変換).collect()
  tests:
    tests/test_solution.py: |
      from solution import Pipeline

      def test_basic_map():
          result = Pipeline([1, 2, 3]).map(lambda x: x * 2).collect()
          assert result == [2, 4, 6]

      def test_basic_filter():
          result = Pipeline([1, 2, 3, 4]).filter(lambda x: x % 2 == 0).collect()
          assert result == [2, 4]

      def test_chain():
          result = (Pipeline([1, 2, 3, 4, 5])
                    .filter(lambda x: x > 2)
                    .map(lambda x: x * 10)
                    .collect())
          assert result == [30, 40, 50]

      def test_reduce():
          result = Pipeline([1, 2, 3, 4]).reduce(lambda acc, x: acc + x, 0)
          assert result == 10

      def test_first():
          result = Pipeline([1, 2, 3]).filter(lambda x: x > 1).first()
          assert result == 2

      def test_first_empty():
          result = Pipeline([]).first(default=None)
          assert result is None

      def test_count():
          count = Pipeline([1, 2, 3, 4]).filter(lambda x: x > 2).count()
          assert count == 2

      def test_take():
          result = Pipeline(range(100)).take(5).collect()
          assert result == [0, 1, 2, 3, 4]


# =============================================================================
# Level 3 (★★★☆) - Hard: 上級レベルのエージェント問題
# =============================================================================

- id: py_agent_L3_state_machine
  lang: python
  prompt: |
    汎用的な有限状態マシン（FSM）を実装してください。
    解説不要。Pythonコードのみ出力してください。

    要件:
    - 状態と遷移の定義
    - 無効な遷移の検出
    - 遷移時のコールバック

    例: 注文のライフサイクル（pending → paid → shipped → delivered）
  tests:
    tests/test_solution.py: |
      from solution import StateMachine

      def test_basic_transition():
          sm = StateMachine(initial="pending")
          sm.add_transition("pending", "paid", "pay")
          sm.add_transition("paid", "shipped", "ship")
          assert sm.state == "pending"
          sm.trigger("pay")
          assert sm.state == "paid"
          sm.trigger("ship")
          assert sm.state == "shipped"

      def test_invalid_transition():
          sm = StateMachine(initial="pending")
          sm.add_transition("pending", "paid", "pay")
          try:
              sm.trigger("ship")  # invalid from pending
              assert False
          except (ValueError, Exception):
              pass

      def test_callback():
          sm = StateMachine(initial="off")
          sm.add_transition("off", "on", "toggle")
          sm.add_transition("on", "off", "toggle")
          calls = []
          sm.on_enter("on", lambda: calls.append("entered on"))
          sm.trigger("toggle")
          assert "entered on" in calls

      def test_available_transitions():
          sm = StateMachine(initial="pending")
          sm.add_transition("pending", "paid", "pay")
          sm.add_transition("pending", "cancelled", "cancel")
          available = sm.available_triggers()
          assert "pay" in available
          assert "cancel" in available


- id: py_agent_L3_query_builder
  lang: python
  prompt: |
    SQLクエリビルダーを実装してください。
    解説不要。Pythonコードのみ出力してください。

    要件:
    - SELECT, WHERE, JOIN, ORDER BY をサポート
    - メソッドチェーンで組み立て
    - SQLインジェクション対策（プレースホルダー使用）

    実際にDBに接続する必要はありません。
  tests:
    tests/test_solution.py: |
      from solution import QueryBuilder

      def test_simple_select():
          qb = QueryBuilder()
          query, params = qb.select("users").build()
          assert "SELECT" in query.upper()
          assert "users" in query.lower()

      def test_select_with_columns():
          qb = QueryBuilder()
          query, params = qb.select("users", ["id", "name"]).build()
          assert "id" in query
          assert "name" in query

      def test_where_clause():
          qb = QueryBuilder()
          query, params = qb.select("users").where("age", ">", 18).build()
          assert "WHERE" in query.upper()
          assert 18 in params or "18" in query

      def test_multiple_where():
          qb = QueryBuilder()
          query, params = (qb.select("users")
                           .where("age", ">", 18)
                           .where("status", "=", "active")
                           .build())
          assert "AND" in query.upper() or query.upper().count("WHERE") >= 1

      def test_order_by():
          qb = QueryBuilder()
          query, params = qb.select("users").order_by("name", "ASC").build()
          assert "ORDER BY" in query.upper()

      def test_sql_injection_prevention():
          qb = QueryBuilder()
          query, params = qb.select("users").where("name", "=", "'; DROP TABLE users;--").build()
          # クエリに直接値が埋め込まれていない
          assert "DROP TABLE" not in query
          assert "'; DROP TABLE users;--" in params


- id: py_agent_L3_plugin_system
  lang: python
  prompt: |
    プラグインシステムを実装してください。
    解説不要。Pythonコードのみ出力してください。

    要件:
    - プラグインの登録と読み込み
    - プラグインのライフサイクル管理（有効化/無効化）
    - フック/イベントポイントでの拡張

    フレームワークやアプリケーションの拡張性を提供するシステムです。
  tests:
    tests/test_solution.py: |
      from solution import PluginManager, Plugin

      class SamplePlugin(Plugin):
          def __init__(self):
              self.activated = False
          def activate(self):
              self.activated = True
          def deactivate(self):
              self.activated = False

      def test_register_plugin():
          manager = PluginManager()
          plugin = SamplePlugin()
          manager.register("sample", plugin)
          assert "sample" in manager.list_plugins()

      def test_activate_plugin():
          manager = PluginManager()
          plugin = SamplePlugin()
          manager.register("sample", plugin)
          manager.activate("sample")
          assert plugin.activated is True

      def test_deactivate_plugin():
          manager = PluginManager()
          plugin = SamplePlugin()
          manager.register("sample", plugin)
          manager.activate("sample")
          manager.deactivate("sample")
          assert plugin.activated is False

      def test_hook_system():
          manager = PluginManager()
          results = []
          manager.add_hook("on_start", lambda: results.append("started"))
          manager.trigger_hook("on_start")
          assert "started" in results

      def test_plugin_priority():
          manager = PluginManager()
          results = []
          manager.add_hook("test", lambda: results.append("low"), priority=10)
          manager.add_hook("test", lambda: results.append("high"), priority=1)
          manager.trigger_hook("test")
          assert results[0] == "high"  # 優先度が高い方が先


- id: py_agent_L3_dependency_injector
  lang: python
  prompt: |
    シンプルな依存性注入（DI）コンテナを実装してください。
    解説不要。Pythonコードのみ出力してください。

    要件:
    - サービスの登録と解決
    - シングルトン/ファクトリのライフタイム管理
    - 依存関係の自動解決

    例:
    container.register(Database)
    container.register(UserService, dependencies=[Database])
    user_service = container.resolve(UserService)
  tests:
    tests/test_solution.py: |
      from solution import Container

      class Database:
          def __init__(self):
              self.connected = True

      class UserService:
          def __init__(self, db: Database):
              self.db = db

      def test_simple_resolve():
          container = Container()
          container.register(Database)
          db = container.resolve(Database)
          assert db.connected is True

      def test_dependency_injection():
          container = Container()
          container.register(Database)
          container.register(UserService)
          svc = container.resolve(UserService)
          assert svc.db is not None
          assert svc.db.connected is True

      def test_singleton():
          container = Container()
          container.register(Database, singleton=True)
          db1 = container.resolve(Database)
          db2 = container.resolve(Database)
          assert db1 is db2

      def test_factory():
          container = Container()
          container.register(Database, singleton=False)
          db1 = container.resolve(Database)
          db2 = container.resolve(Database)
          assert db1 is not db2

      def test_register_instance():
          container = Container()
          my_db = Database()
          container.register_instance(Database, my_db)
          resolved = container.resolve(Database)
          assert resolved is my_db


- id: py_agent_L3_circuit_breaker
  lang: python
  prompt: |
    サーキットブレーカーパターンを実装してください。
    解説不要。Pythonコードのみ出力してください。

    要件:
    - 連続失敗でサーキットをオープン（リクエスト遮断）
    - タイムアウト後にハーフオープン状態で再試行
    - 成功すればクローズ状態に復帰

    マイクロサービスの障害伝播を防ぐパターンです。
  tests:
    tests/test_solution.py: |
      import time
      from solution import CircuitBreaker, CircuitState

      def test_closed_state():
          cb = CircuitBreaker(failure_threshold=3, recovery_timeout=0.1)
          assert cb.state == CircuitState.CLOSED
          # 成功は通常通り
          result = cb.call(lambda: "ok")
          assert result == "ok"

      def test_open_after_failures():
          cb = CircuitBreaker(failure_threshold=3, recovery_timeout=0.1)
          def failing():
              raise RuntimeError("fail")
          for _ in range(3):
              try:
                  cb.call(failing)
              except RuntimeError:
                  pass
          assert cb.state == CircuitState.OPEN

      def test_open_rejects_calls():
          cb = CircuitBreaker(failure_threshold=2, recovery_timeout=1.0)
          def failing():
              raise RuntimeError("fail")
          for _ in range(2):
              try:
                  cb.call(failing)
              except RuntimeError:
                  pass
          # オープン状態では即座に例外
          try:
              cb.call(lambda: "test")
              assert False
          except Exception as e:
              assert "open" in str(e).lower() or "circuit" in str(e).lower()

      def test_half_open_after_timeout():
          cb = CircuitBreaker(failure_threshold=2, recovery_timeout=0.1)
          def failing():
              raise RuntimeError("fail")
          for _ in range(2):
              try:
                  cb.call(failing)
              except RuntimeError:
                  pass
          time.sleep(0.15)
          assert cb.state == CircuitState.HALF_OPEN

      def test_recovery_to_closed():
          cb = CircuitBreaker(failure_threshold=2, recovery_timeout=0.1)
          def failing():
              raise RuntimeError("fail")
          for _ in range(2):
              try:
                  cb.call(failing)
              except RuntimeError:
                  pass
          time.sleep(0.15)
          # ハーフオープンで成功
          result = cb.call(lambda: "recovered")
          assert result == "recovered"
          assert cb.state == CircuitState.CLOSED


- id: py_agent_L3_event_sourcing
  lang: python
  prompt: |
    簡易的なイベントソーシングシステムを実装してください。
    解説不要。Pythonコードのみ出力してください。

    要件:
    - イベントの記録と再生
    - 集約（Aggregate）の状態復元
    - イベントストアの実装

    例: 銀行口座の入出金履歴からcurrent balanceを再構築
  tests:
    tests/test_solution.py: |
      from solution import EventStore, BankAccount

      def test_record_event():
          store = EventStore()
          store.append("account-1", {"type": "deposited", "amount": 100})
          events = store.get_events("account-1")
          assert len(events) == 1

      def test_replay_events():
          store = EventStore()
          store.append("account-1", {"type": "deposited", "amount": 100})
          store.append("account-1", {"type": "deposited", "amount": 50})
          store.append("account-1", {"type": "withdrawn", "amount": 30})
          account = BankAccount.from_events(store.get_events("account-1"))
          assert account.balance == 120

      def test_multiple_aggregates():
          store = EventStore()
          store.append("account-1", {"type": "deposited", "amount": 100})
          store.append("account-2", {"type": "deposited", "amount": 200})
          events1 = store.get_events("account-1")
          events2 = store.get_events("account-2")
          assert len(events1) == 1
          assert len(events2) == 1

      def test_event_order():
          store = EventStore()
          store.append("acc", {"type": "deposited", "amount": 100})
          store.append("acc", {"type": "withdrawn", "amount": 50})
          store.append("acc", {"type": "deposited", "amount": 25})
          events = store.get_events("acc")
          assert events[0]["amount"] == 100
          assert events[1]["amount"] == 50
          assert events[2]["amount"] == 25


# =============================================================================
# Level 4 (★★★★) - Expert: エキスパートレベルのエージェント問題
# =============================================================================

- id: py_agent_L4_workflow_engine
  lang: python
  prompt: |
    ワークフローエンジンを実装してください。
    解説不要。Pythonコードのみ出力してください。

    要件:
    - タスクの定義と依存関係
    - 並列実行可能なタスクの検出
    - 失敗時のリトライ/スキップ/中断戦略
    - 実行状態の追跡

    例: データパイプライン、CI/CDワークフロー
  tests:
    tests/test_solution.py: |
      from solution import Workflow, Task, TaskStatus

      def test_sequential_tasks():
          wf = Workflow()
          results = []
          wf.add_task("a", lambda: results.append("a"))
          wf.add_task("b", lambda: results.append("b"), depends_on=["a"])
          wf.run()
          assert results == ["a", "b"]

      def test_parallel_tasks():
          wf = Workflow()
          results = []
          wf.add_task("a", lambda: results.append("a"))
          wf.add_task("b", lambda: results.append("b"))
          wf.add_task("c", lambda: results.append("c"), depends_on=["a", "b"])
          wf.run()
          assert "a" in results
          assert "b" in results
          assert results[-1] == "c"  # c is last

      def test_task_failure():
          wf = Workflow()
          def failing():
              raise RuntimeError("fail")
          wf.add_task("a", failing)
          wf.add_task("b", lambda: "ok", depends_on=["a"])
          wf.run()
          assert wf.get_status("a") == TaskStatus.FAILED
          assert wf.get_status("b") == TaskStatus.SKIPPED

      def test_retry_on_failure():
          wf = Workflow()
          attempts = [0]
          def flaky():
              attempts[0] += 1
              if attempts[0] < 3:
                  raise RuntimeError("flaky")
              return "ok"
          wf.add_task("a", flaky, retries=3)
          wf.run()
          assert wf.get_status("a") == TaskStatus.COMPLETED
          assert attempts[0] == 3


- id: py_agent_L4_rule_engine
  lang: python
  prompt: |
    ビジネスルールエンジンを実装してください。
    解説不要。Pythonコードのみ出力してください。

    要件:
    - ルールの定義（条件 + アクション）
    - ルールの優先度と競合解決
    - ファクト（入力データ）に対するルール適用
    - ルールチェーンの実行

    例: 保険の査定、ローン審査、割引適用
  tests:
    tests/test_solution.py: |
      from solution import RuleEngine, Rule

      def test_simple_rule():
          engine = RuleEngine()
          engine.add_rule(
              "adult_discount",
              condition=lambda facts: facts.get("age", 0) >= 18,
              action=lambda facts: facts.update({"discount": 10})
          )
          facts = {"age": 25, "discount": 0}
          engine.run(facts)
          assert facts["discount"] == 10

      def test_rule_not_matched():
          engine = RuleEngine()
          engine.add_rule(
              "adult_discount",
              condition=lambda facts: facts.get("age", 0) >= 18,
              action=lambda facts: facts.update({"discount": 10})
          )
          facts = {"age": 15, "discount": 0}
          engine.run(facts)
          assert facts["discount"] == 0

      def test_multiple_rules():
          engine = RuleEngine()
          engine.add_rule(
              "base_discount",
              condition=lambda f: f.get("member", False),
              action=lambda f: f.update({"discount": f.get("discount", 0) + 5})
          )
          engine.add_rule(
              "bulk_discount",
              condition=lambda f: f.get("quantity", 0) >= 10,
              action=lambda f: f.update({"discount": f.get("discount", 0) + 10})
          )
          facts = {"member": True, "quantity": 15, "discount": 0}
          engine.run(facts)
          assert facts["discount"] == 15

      def test_priority():
          engine = RuleEngine()
          results = []
          engine.add_rule("low", lambda f: True, lambda f: results.append("low"), priority=10)
          engine.add_rule("high", lambda f: True, lambda f: results.append("high"), priority=1)
          engine.run({})
          assert results[0] == "high"


- id: py_agent_L4_distributed_lock
  lang: python
  prompt: |
    分散ロック機構を実装してください。
    解説不要。Pythonコードのみ出力してください。

    要件:
    - ロックの取得と解放
    - タイムアウト付きの取得
    - 自動期限切れ（TTL）
    - ロック所有者の検証

    注: 実際のネットワーク通信は不要。インメモリでの実装でOK。
    分散システムでの利用を想定した設計を意識してください。
  tests:
    tests/test_solution.py: |
      import time
      from solution import DistributedLock, LockManager

      def test_acquire_release():
          manager = LockManager()
          lock = manager.acquire("resource-1", owner="client-a")
          assert lock is not None
          manager.release("resource-1", owner="client-a")
          # 解放後は他のクライアントが取得可能
          lock2 = manager.acquire("resource-1", owner="client-b")
          assert lock2 is not None

      def test_lock_contention():
          manager = LockManager()
          manager.acquire("resource-1", owner="client-a")
          # 別のオーナーは取得できない
          lock2 = manager.acquire("resource-1", owner="client-b", timeout=0.1)
          assert lock2 is None

      def test_wrong_owner_release():
          manager = LockManager()
          manager.acquire("resource-1", owner="client-a")
          # 別のオーナーは解放できない
          released = manager.release("resource-1", owner="client-b")
          assert released is False

      def test_ttl_expiration():
          manager = LockManager()
          manager.acquire("resource-1", owner="client-a", ttl=0.1)
          time.sleep(0.15)
          # TTL切れで他のクライアントが取得可能
          lock = manager.acquire("resource-1", owner="client-b")
          assert lock is not None

      def test_extend_lock():
          manager = LockManager()
          manager.acquire("resource-1", owner="client-a", ttl=0.1)
          manager.extend("resource-1", owner="client-a", ttl=1.0)
          time.sleep(0.15)
          # 延長されたのでまだロック中
          lock = manager.acquire("resource-1", owner="client-b", timeout=0)
          assert lock is None


- id: py_agent_L4_cqrs_impl
  lang: python
  prompt: |
    CQRS（Command Query Responsibility Segregation）パターンを実装してください。
    解説不要。Pythonコードのみ出力してください。

    要件:
    - コマンドハンドラ（書き込み）
    - クエリハンドラ（読み取り）
    - コマンドとクエリの分離
    - イベントによる読み取りモデルの更新

    例: ユーザー登録（コマンド）とユーザー検索（クエリ）の分離
  tests:
    tests/test_solution.py: |
      from solution import CQRSApp, CreateUserCommand, GetUserQuery, ListUsersQuery

      def test_create_user_command():
          app = CQRSApp()
          cmd = CreateUserCommand(user_id="u1", name="Alice", email="alice@example.com")
          result = app.execute_command(cmd)
          assert result["success"] is True

      def test_get_user_query():
          app = CQRSApp()
          app.execute_command(CreateUserCommand("u1", "Alice", "alice@example.com"))
          query = GetUserQuery(user_id="u1")
          user = app.execute_query(query)
          assert user["name"] == "Alice"

      def test_list_users_query():
          app = CQRSApp()
          app.execute_command(CreateUserCommand("u1", "Alice", "a@example.com"))
          app.execute_command(CreateUserCommand("u2", "Bob", "b@example.com"))
          query = ListUsersQuery()
          users = app.execute_query(query)
          assert len(users) == 2

      def test_command_query_separation():
          app = CQRSApp()
          # コマンドは状態を変更
          app.execute_command(CreateUserCommand("u1", "Alice", "a@example.com"))
          # クエリは状態を変更しない
          user1 = app.execute_query(GetUserQuery("u1"))
          user2 = app.execute_query(GetUserQuery("u1"))
          assert user1 == user2


- id: py_agent_L4_saga_pattern
  lang: python
  prompt: |
    Sagaパターン（分散トランザクション）を実装してください。
    解説不要。Pythonコードのみ出力してください。

    要件:
    - 複数ステップのトランザクション
    - 各ステップの補償アクション（ロールバック）
    - 失敗時の自動補償実行
    - オーケストレーション型

    例: 注文処理（在庫確保→決済→配送手配）
  tests:
    tests/test_solution.py: |
      from solution import Saga, SagaStep

      def test_successful_saga():
          results = []
          saga = Saga()
          saga.add_step(
              "reserve_stock",
              execute=lambda: results.append("reserved"),
              compensate=lambda: results.append("unreserved")
          )
          saga.add_step(
              "charge_payment",
              execute=lambda: results.append("charged"),
              compensate=lambda: results.append("refunded")
          )
          saga.run()
          assert results == ["reserved", "charged"]

      def test_compensation_on_failure():
          results = []
          saga = Saga()
          saga.add_step(
              "reserve_stock",
              execute=lambda: results.append("reserved"),
              compensate=lambda: results.append("unreserved")
          )
          def failing_payment():
              results.append("charge_attempted")
              raise RuntimeError("payment failed")
          saga.add_step(
              "charge_payment",
              execute=failing_payment,
              compensate=lambda: results.append("refunded")
          )
          saga.run()
          # 補償が逆順で実行される
          assert "unreserved" in results
          assert "reserved" in results

      def test_partial_compensation():
          results = []
          saga = Saga()
          saga.add_step("step1", lambda: results.append("s1"), lambda: results.append("c1"))
          saga.add_step("step2", lambda: results.append("s2"), lambda: results.append("c2"))
          def fail():
              raise RuntimeError("fail")
          saga.add_step("step3", fail, lambda: results.append("c3"))
          saga.run()
          # step3は実行に失敗したので補償不要、step2,step1の補償が実行
          assert "c2" in results
          assert "c1" in results
          assert "c3" not in results  # step3は実行されていないので補償も不要

      def test_saga_status():
          saga = Saga()
          saga.add_step("step1", lambda: None, lambda: None)
          saga.run()
          assert saga.status == "completed"


- id: py_agent_L4_api_gateway
  lang: python
  prompt: |
    APIゲートウェイのコア機能を実装してください。
    解説不要。Pythonコードのみ出力してください。

    要件:
    - リクエストルーティング（パスベース）
    - 認証/認可ミドルウェア
    - レート制限
    - レスポンス変換
    - ヘルスチェックエンドポイント

    実際のHTTPサーバーは不要。リクエストオブジェクトを受け取って処理。
  tests:
    tests/test_solution.py: |
      from solution import APIGateway, Request, Response

      def test_route_registration():
          gw = APIGateway()
          gw.route("/users", lambda req: Response(200, {"users": []}))
          req = Request("GET", "/users")
          resp = gw.handle(req)
          assert resp.status == 200

      def test_path_parameters():
          gw = APIGateway()
          gw.route("/users/{id}", lambda req: Response(200, {"id": req.params["id"]}))
          req = Request("GET", "/users/123")
          resp = gw.handle(req)
          assert resp.body["id"] == "123"

      def test_auth_middleware():
          gw = APIGateway()
          gw.use_auth(lambda req: req.headers.get("Authorization") == "Bearer valid")
          gw.route("/protected", lambda req: Response(200, {"data": "secret"}))
          req = Request("GET", "/protected", headers={"Authorization": "Bearer valid"})
          resp = gw.handle(req)
          assert resp.status == 200
          req_invalid = Request("GET", "/protected", headers={})
          resp_invalid = gw.handle(req_invalid)
          assert resp_invalid.status == 401

      def test_rate_limiting():
          gw = APIGateway()
          gw.rate_limit(max_requests=2, window_seconds=10)
          gw.route("/api", lambda req: Response(200, {}))
          req = Request("GET", "/api", client_id="client1")
          gw.handle(req)
          gw.handle(req)
          resp = gw.handle(req)
          assert resp.status == 429

      def test_not_found():
          gw = APIGateway()
          req = Request("GET", "/nonexistent")
          resp = gw.handle(req)
          assert resp.status == 404
