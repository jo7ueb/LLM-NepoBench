# =============================================================================
# Python ベンチマーク問題集
# カテゴリ: バグ修正, データ処理, アルゴリズム, API設計, OOP, 例外処理, etc.
# 各問題に複数テストケースを含み、部分点評価が可能
# =============================================================================

# -----------------------------------------------------------------------------
# カテゴリ: バグ修正 (Bug Fix)
# -----------------------------------------------------------------------------

- id: py_remove_even
  lang: python
  prompt: |
    次の関数にはバグがあり、偶数が正しく削除されません。
    期待結果は remove_even_numbers([1,2,4,8,9]) == [1,9] です。
    解説不要。修正後のPythonコードのみ出力してください。

    def remove_even_numbers(numbers):
        for num in numbers:
            if num % 2 == 0:
                numbers.remove(num)
        return numbers
  tests:
    tests/test_solution.py: |
      from solution import remove_even_numbers

      def test_basic():
          assert remove_even_numbers([1,2,4,8,9]) == [1,9]

      def test_all_even():
          assert remove_even_numbers([2,4,6,8]) == []

      def test_all_odd():
          assert remove_even_numbers([1,3,5,7]) == [1,3,5,7]

      def test_empty():
          assert remove_even_numbers([]) == []

      def test_consecutive_evens():
          assert remove_even_numbers([2,4,6,1,3]) == [1,3]


- id: py_off_by_one
  lang: python
  prompt: |
    次の関数は1からnまでの合計を計算するはずですが、off-by-one エラーがあります。
    sum_to_n(5) は 1+2+3+4+5=15 を返すべきです。
    解説不要。修正後のPythonコードのみ出力してください。

    def sum_to_n(n):
        total = 0
        for i in range(n):
            total += i
        return total
  tests:
    tests/test_solution.py: |
      from solution import sum_to_n

      def test_sum_5():
          assert sum_to_n(5) == 15

      def test_sum_1():
          assert sum_to_n(1) == 1

      def test_sum_10():
          assert sum_to_n(10) == 55

      def test_sum_0():
          assert sum_to_n(0) == 0


- id: py_mutable_default
  lang: python
  prompt: |
    次の関数はミュータブルなデフォルト引数のバグがあります。
    呼び出すたびに新しい空リストから始めるべきです。
    解説不要。修正後のPythonコードのみ出力してください。

    def append_to_list(item, lst=[]):
        lst.append(item)
        return lst
  tests:
    tests/test_solution.py: |
      from solution import append_to_list

      def test_independent_calls():
          result1 = append_to_list(1)
          result2 = append_to_list(2)
          assert result1 == [1]
          assert result2 == [2]

      def test_with_provided_list():
          my_list = [10]
          result = append_to_list(20, my_list)
          assert result == [10, 20]

      def test_multiple_appends():
          append_to_list("a")
          append_to_list("b")
          result = append_to_list("c")
          assert result == ["c"]


# -----------------------------------------------------------------------------
# カテゴリ: データ処理 (Data Processing)
# -----------------------------------------------------------------------------

- id: py_word_frequency
  lang: python
  prompt: |
    テキストから単語の出現頻度を数える関数を実装してください。
    解説不要。Pythonコードのみ出力してください。

    仕様:
    - word_frequency(text: str) -> dict[str, int]
    - 単語は空白で区切られる
    - 大文字小文字は区別しない（すべて小文字に変換）
    - 句読点（.,!?）は除去する
    - 空の入力には空辞書を返す
  tests:
    tests/test_solution.py: |
      from solution import word_frequency

      def test_basic():
          result = word_frequency("Hello world hello")
          assert result == {"hello": 2, "world": 1}

      def test_punctuation():
          result = word_frequency("Hello, world! Hello.")
          assert result == {"hello": 2, "world": 1}

      def test_empty():
          assert word_frequency("") == {}

      def test_single_word():
          assert word_frequency("Python") == {"python": 1}

      def test_case_insensitive():
          result = word_frequency("Cat CAT cat")
          assert result == {"cat": 3}


- id: py_flatten_nested
  lang: python
  prompt: |
    ネストしたリストを平坦化する関数を実装してください。
    解説不要。Pythonコードのみ出力してください。

    仕様:
    - flatten(nested: list) -> list
    - 任意の深さのネストに対応
    - 再帰的に処理する
  tests:
    tests/test_solution.py: |
      from solution import flatten

      def test_simple():
          assert flatten([1, [2, 3], 4]) == [1, 2, 3, 4]

      def test_deep_nested():
          assert flatten([1, [2, [3, [4]]]]) == [1, 2, 3, 4]

      def test_already_flat():
          assert flatten([1, 2, 3]) == [1, 2, 3]

      def test_empty():
          assert flatten([]) == []

      def test_mixed_types():
          assert flatten([1, ["a", [True, [None]]]]) == [1, "a", True, None]


- id: py_group_by_key
  lang: python
  prompt: |
    辞書のリストを指定キーでグループ化する関数を実装してください。
    解説不要。Pythonコードのみ出力してください。

    仕様:
    - group_by(items: list[dict], key: str) -> dict[Any, list[dict]]
    - 指定キーの値でグループ化
    - キーが存在しないアイテムは "unknown" でグループ化
  tests:
    tests/test_solution.py: |
      from solution import group_by

      def test_basic():
          items = [
              {"name": "Alice", "dept": "Engineering"},
              {"name": "Bob", "dept": "Sales"},
              {"name": "Charlie", "dept": "Engineering"},
          ]
          result = group_by(items, "dept")
          assert len(result["Engineering"]) == 2
          assert len(result["Sales"]) == 1

      def test_missing_key():
          items = [
              {"name": "Alice", "dept": "Engineering"},
              {"name": "Bob"},
          ]
          result = group_by(items, "dept")
          assert "unknown" in result
          assert len(result["unknown"]) == 1

      def test_empty():
          assert group_by([], "key") == {}

      def test_single_group():
          items = [{"a": 1}, {"a": 1}, {"a": 1}]
          result = group_by(items, "a")
          assert len(result[1]) == 3


# -----------------------------------------------------------------------------
# カテゴリ: アルゴリズム (Algorithms)
# -----------------------------------------------------------------------------

- id: py_binary_search
  lang: python
  prompt: |
    ソート済みリストで二分探索を実装してください。
    解説不要。Pythonコードのみ出力してください。

    仕様:
    - binary_search(arr: list[int], target: int) -> int
    - ターゲットが見つかればそのインデックスを返す
    - 見つからなければ -1 を返す
    - 組み込みの bisect モジュールは使用不可
  tests:
    tests/test_solution.py: |
      from solution import binary_search

      def test_found_middle():
          assert binary_search([1, 3, 5, 7, 9], 5) == 2

      def test_found_first():
          assert binary_search([1, 3, 5, 7, 9], 1) == 0

      def test_found_last():
          assert binary_search([1, 3, 5, 7, 9], 9) == 4

      def test_not_found():
          assert binary_search([1, 3, 5, 7, 9], 6) == -1

      def test_empty():
          assert binary_search([], 5) == -1

      def test_single_element():
          assert binary_search([42], 42) == 0
          assert binary_search([42], 1) == -1


- id: py_fibonacci_memo
  lang: python
  prompt: |
    メモ化を使った効率的なフィボナッチ数列を実装してください。
    解説不要。Pythonコードのみ出力してください。

    仕様:
    - fibonacci(n: int) -> int
    - fib(0) = 0, fib(1) = 1
    - n >= 40 でも高速に動作すること
  tests:
    tests/test_solution.py: |
      from solution import fibonacci
      import time

      def test_base_cases():
          assert fibonacci(0) == 0
          assert fibonacci(1) == 1

      def test_small_values():
          assert fibonacci(5) == 5
          assert fibonacci(10) == 55

      def test_medium_values():
          assert fibonacci(20) == 6765

      def test_large_value_performance():
          start = time.time()
          result = fibonacci(40)
          elapsed = time.time() - start
          assert result == 102334155
          assert elapsed < 1.0  # 1秒以内に完了すべき


- id: py_merge_sorted
  lang: python
  prompt: |
    2つのソート済みリストをマージして1つのソート済みリストにする関数を実装してください。
    解説不要。Pythonコードのみ出力してください。

    仕様:
    - merge_sorted(list1: list[int], list2: list[int]) -> list[int]
    - O(n+m) の時間計算量で実装
    - 組み込みの sorted() や sort() は使用不可
  tests:
    tests/test_solution.py: |
      from solution import merge_sorted

      def test_basic():
          assert merge_sorted([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6]

      def test_one_empty():
          assert merge_sorted([1, 2, 3], []) == [1, 2, 3]
          assert merge_sorted([], [4, 5, 6]) == [4, 5, 6]

      def test_both_empty():
          assert merge_sorted([], []) == []

      def test_duplicates():
          assert merge_sorted([1, 2, 2], [2, 3]) == [1, 2, 2, 2, 3]

      def test_different_lengths():
          assert merge_sorted([1], [2, 3, 4, 5]) == [1, 2, 3, 4, 5]


# -----------------------------------------------------------------------------
# カテゴリ: API設計 (Web API)
# -----------------------------------------------------------------------------

- id: py_fastapi_tasks
  lang: python
  prompt: |
    FastAPI と Pydantic を使って簡単なタスク管理APIを実装してください。
    次の仕様を満たす単一ファイル solution.py を出力してください（解説不要）。

    仕様:
    - FastAPI app インスタンス名は `app`
    - POST /tasks でタスク作成
      - 入力: {"title": str, "done": bool}
      - 出力: {"id": int, "title": str, "done": bool}
    - GET /tasks で一覧取得（作成順）
    - DBはインメモリ配列でOK
    - タイトルは空文字禁止（空なら 422 などのバリデーションエラーでOK）
  tests:
    tests/test_solution.py: |
      from fastapi.testclient import TestClient
      from solution import app

      client = TestClient(app)

      def test_get_empty():
          r = client.get("/tasks")
          assert r.status_code == 200
          assert r.json() == []

      def test_create_task():
          r = client.post("/tasks", json={"title": "a", "done": False})
          assert r.status_code == 200
          body = r.json()
          assert body["id"] == 1
          assert body["title"] == "a"
          assert body["done"] is False

      def test_create_second_task():
          # Reset state by importing fresh
          r = client.post("/tasks", json={"title": "b", "done": True})
          assert r.status_code == 200
          body = r.json()
          assert body["id"] >= 1
          assert body["title"] == "b"

      def test_list_tasks():
          r = client.get("/tasks")
          assert r.status_code == 200
          items = r.json()
          assert len(items) >= 1

      def test_title_validation():
          r = client.post("/tasks", json={"title": "", "done": False})
          assert r.status_code in (400, 422)


- id: py_fastapi_crud
  lang: python
  prompt: |
    FastAPIでユーザーのCRUD APIを実装してください。
    解説不要。solution.py のみ出力してください。

    仕様:
    - app インスタンス名は `app`
    - GET /users - 全ユーザー一覧
    - GET /users/{id} - 特定ユーザー取得（存在しない場合404）
    - POST /users - ユーザー作成 {"name": str, "email": str}
    - PUT /users/{id} - ユーザー更新（存在しない場合404）
    - DELETE /users/{id} - ユーザー削除（存在しない場合404）
    - IDは自動採番、インメモリDB
  tests:
    tests/test_solution.py: |
      from fastapi.testclient import TestClient
      from solution import app

      client = TestClient(app)

      def test_list_empty():
          r = client.get("/users")
          assert r.status_code == 200
          assert isinstance(r.json(), list)

      def test_create_user():
          r = client.post("/users", json={"name": "Test", "email": "test@example.com"})
          assert r.status_code in (200, 201)
          body = r.json()
          assert "id" in body
          assert body["name"] == "Test"

      def test_get_user():
          # Create first
          r = client.post("/users", json={"name": "Get Test", "email": "get@example.com"})
          user_id = r.json()["id"]
          # Get it
          r = client.get(f"/users/{user_id}")
          assert r.status_code == 200
          assert r.json()["name"] == "Get Test"

      def test_get_nonexistent():
          r = client.get("/users/99999")
          assert r.status_code == 404

      def test_update_user():
          r = client.post("/users", json={"name": "Update Test", "email": "update@example.com"})
          user_id = r.json()["id"]
          r = client.put(f"/users/{user_id}", json={"name": "Updated", "email": "updated@example.com"})
          assert r.status_code == 200
          assert r.json()["name"] == "Updated"

      def test_delete_user():
          r = client.post("/users", json={"name": "Delete Test", "email": "delete@example.com"})
          user_id = r.json()["id"]
          r = client.delete(f"/users/{user_id}")
          assert r.status_code in (200, 204)


# -----------------------------------------------------------------------------
# カテゴリ: OOP / クラス設計
# -----------------------------------------------------------------------------

- id: py_stack_class
  lang: python
  prompt: |
    スタック（後入れ先出し）のクラスを実装してください。
    解説不要。Pythonコードのみ出力してください。

    仕様:
    - class Stack
    - push(item) - アイテムを追加
    - pop() - アイテムを取り出し（空なら IndexError）
    - peek() - 先頭を参照（取り出さない、空なら IndexError）
    - is_empty() -> bool
    - size() -> int
  tests:
    tests/test_solution.py: |
      import pytest
      from solution import Stack

      def test_push_pop():
          s = Stack()
          s.push(1)
          s.push(2)
          assert s.pop() == 2
          assert s.pop() == 1

      def test_peek():
          s = Stack()
          s.push(10)
          assert s.peek() == 10
          assert s.size() == 1  # peek doesn't remove

      def test_is_empty():
          s = Stack()
          assert s.is_empty() is True
          s.push(1)
          assert s.is_empty() is False

      def test_size():
          s = Stack()
          assert s.size() == 0
          s.push(1)
          s.push(2)
          assert s.size() == 2

      def test_pop_empty_raises():
          s = Stack()
          with pytest.raises(IndexError):
              s.pop()

      def test_peek_empty_raises():
          s = Stack()
          with pytest.raises(IndexError):
              s.peek()


- id: py_bank_account
  lang: python
  prompt: |
    銀行口座クラスを実装してください。
    解説不要。Pythonコードのみ出力してください。

    仕様:
    - class BankAccount(owner: str, initial_balance: float = 0)
    - deposit(amount: float) - 入金（負の値は ValueError）
    - withdraw(amount: float) - 出金（残高不足は ValueError）
    - get_balance() -> float
    - transfer(target: BankAccount, amount: float) - 他口座へ送金
  tests:
    tests/test_solution.py: |
      import pytest
      from solution import BankAccount

      def test_initial_balance():
          acc = BankAccount("Alice", 100)
          assert acc.get_balance() == 100

      def test_deposit():
          acc = BankAccount("Bob", 50)
          acc.deposit(25)
          assert acc.get_balance() == 75

      def test_withdraw():
          acc = BankAccount("Charlie", 100)
          acc.withdraw(30)
          assert acc.get_balance() == 70

      def test_withdraw_insufficient():
          acc = BankAccount("Dave", 50)
          with pytest.raises(ValueError):
              acc.withdraw(100)

      def test_deposit_negative():
          acc = BankAccount("Eve", 100)
          with pytest.raises(ValueError):
              acc.deposit(-10)

      def test_transfer():
          acc1 = BankAccount("From", 100)
          acc2 = BankAccount("To", 50)
          acc1.transfer(acc2, 30)
          assert acc1.get_balance() == 70
          assert acc2.get_balance() == 80


# -----------------------------------------------------------------------------
# カテゴリ: 文字列処理 / 正規表現
# -----------------------------------------------------------------------------

- id: py_email_validator
  lang: python
  prompt: |
    メールアドレスの簡易バリデーション関数を実装してください。
    解説不要。Pythonコードのみ出力してください。

    仕様:
    - is_valid_email(email: str) -> bool
    - 形式: xxx@yyy.zzz（@が1つ、ドメインに.が1つ以上）
    - 空文字、空白のみは False
    - 正規表現使用可
  tests:
    tests/test_solution.py: |
      from solution import is_valid_email

      def test_valid_simple():
          assert is_valid_email("test@example.com") is True

      def test_valid_subdomain():
          assert is_valid_email("user@mail.example.com") is True

      def test_invalid_no_at():
          assert is_valid_email("testexample.com") is False

      def test_invalid_no_domain():
          assert is_valid_email("test@") is False

      def test_invalid_no_dot():
          assert is_valid_email("test@example") is False

      def test_empty():
          assert is_valid_email("") is False

      def test_whitespace():
          assert is_valid_email("   ") is False


- id: py_parse_log
  lang: python
  prompt: |
    ログ行をパースする関数を実装してください。
    解説不要。Pythonコードのみ出力してください。

    仕様:
    - parse_log(line: str) -> dict | None
    - ログ形式: "[LEVEL] YYYY-MM-DD HH:MM:SS message"
    - 返り値: {"level": str, "timestamp": str, "message": str}
    - パース失敗時は None を返す
  tests:
    tests/test_solution.py: |
      from solution import parse_log

      def test_info_log():
          result = parse_log("[INFO] 2024-01-15 10:30:00 Application started")
          assert result is not None
          assert result["level"] == "INFO"
          assert result["timestamp"] == "2024-01-15 10:30:00"
          assert result["message"] == "Application started"

      def test_error_log():
          result = parse_log("[ERROR] 2024-01-15 11:00:00 Connection failed")
          assert result is not None
          assert result["level"] == "ERROR"

      def test_multi_word_message():
          result = parse_log("[WARN] 2024-01-15 12:00:00 Memory usage is high")
          assert result is not None
          assert result["message"] == "Memory usage is high"

      def test_invalid_format():
          assert parse_log("Invalid log line") is None

      def test_empty():
          assert parse_log("") is None


# -----------------------------------------------------------------------------
# カテゴリ: デコレータ / 高階関数
# -----------------------------------------------------------------------------

- id: py_retry_decorator
  lang: python
  prompt: |
    リトライ機能を持つデコレータを実装してください。
    解説不要。Pythonコードのみ出力してください。

    仕様:
    - @retry(max_attempts=3)
    - 関数が例外を投げたら再試行
    - max_attempts回失敗したら最後の例外を再raise
    - 成功したら即座に結果を返す
  tests:
    tests/test_solution.py: |
      import pytest
      from solution import retry

      def test_success_first_try():
          @retry(max_attempts=3)
          def always_works():
              return "ok"
          assert always_works() == "ok"

      def test_success_after_retry():
          counter = {"count": 0}
          @retry(max_attempts=3)
          def fails_twice():
              counter["count"] += 1
              if counter["count"] < 3:
                  raise ValueError("fail")
              return "success"
          assert fails_twice() == "success"
          assert counter["count"] == 3

      def test_all_attempts_fail():
          @retry(max_attempts=3)
          def always_fails():
              raise RuntimeError("always fails")
          with pytest.raises(RuntimeError):
              always_fails()

      def test_custom_attempts():
          counter = {"count": 0}
          @retry(max_attempts=5)
          def fails_four_times():
              counter["count"] += 1
              if counter["count"] < 5:
                  raise ValueError("fail")
              return "done"
          assert fails_four_times() == "done"


- id: py_cache_decorator
  lang: python
  prompt: |
    結果をキャッシュするデコレータを実装してください。
    解説不要。Pythonコードのみ出力してください。

    仕様:
    - @cache デコレータ
    - 同じ引数での呼び出しはキャッシュから返す
    - 引数が異なれば新たに計算
    - functools.lru_cache は使用不可
  tests:
    tests/test_solution.py: |
      from solution import cache

      def test_basic_caching():
          call_count = {"n": 0}
          @cache
          def expensive(x):
              call_count["n"] += 1
              return x * 2
          assert expensive(5) == 10
          assert expensive(5) == 10
          assert call_count["n"] == 1  # only called once

      def test_different_args():
          call_count = {"n": 0}
          @cache
          def add_one(x):
              call_count["n"] += 1
              return x + 1
          assert add_one(1) == 2
          assert add_one(2) == 3
          assert add_one(1) == 2
          assert call_count["n"] == 2

      def test_multiple_args():
          @cache
          def add(a, b):
              return a + b
          assert add(1, 2) == 3
          assert add(1, 2) == 3
          assert add(2, 3) == 5


# -----------------------------------------------------------------------------
# カテゴリ: 例外処理 / エラーハンドリング
# -----------------------------------------------------------------------------

- id: py_safe_json_parse
  lang: python
  prompt: |
    安全なJSON解析関数を実装してください。
    解説不要。Pythonコードのみ出力してください。

    仕様:
    - safe_json_parse(text: str, default=None) -> Any
    - 有効なJSONなら解析結果を返す
    - 無効なJSONならdefaultを返す
    - 例外は投げない
  tests:
    tests/test_solution.py: |
      from solution import safe_json_parse

      def test_valid_json():
          assert safe_json_parse('{"key": "value"}') == {"key": "value"}

      def test_valid_array():
          assert safe_json_parse('[1, 2, 3]') == [1, 2, 3]

      def test_invalid_json():
          assert safe_json_parse('not json') is None

      def test_invalid_with_default():
          assert safe_json_parse('invalid', default={}) == {}

      def test_empty_string():
          assert safe_json_parse('', default=[]) == []

      def test_number():
          assert safe_json_parse('42') == 42


- id: py_safe_divide
  lang: python
  prompt: |
    安全な除算関数を実装してください。
    解説不要。Pythonコードのみ出力してください。

    仕様:
    - safe_divide(a, b, default=0) -> float
    - b が 0 の場合は default を返す
    - 数値以外が渡された場合も default を返す
    - 正常な場合は a / b を返す
  tests:
    tests/test_solution.py: |
      from solution import safe_divide

      def test_normal_division():
          assert safe_divide(10, 2) == 5.0

      def test_division_by_zero():
          assert safe_divide(10, 0) == 0

      def test_division_by_zero_custom_default():
          assert safe_divide(10, 0, default=-1) == -1

      def test_invalid_type():
          assert safe_divide("a", "b") == 0

      def test_float_division():
          assert safe_divide(7, 2) == 3.5


# -----------------------------------------------------------------------------
# カテゴリ: データ変換 / シリアライズ
# -----------------------------------------------------------------------------

- id: py_dict_to_xml
  lang: python
  prompt: |
    辞書をXML文字列に変換する関数を実装してください。
    解説不要。Pythonコードのみ出力してください。

    仕様:
    - dict_to_xml(data: dict, root_tag: str = "root") -> str
    - ネストした辞書に対応
    - リストはサポート不要
    - 属性はサポート不要
  tests:
    tests/test_solution.py: |
      from solution import dict_to_xml

      def test_simple():
          result = dict_to_xml({"name": "Alice"}, "person")
          assert "<person>" in result
          assert "<name>Alice</name>" in result
          assert "</person>" in result

      def test_nested():
          result = dict_to_xml({"user": {"name": "Bob"}}, "data")
          assert "<user>" in result
          assert "<name>Bob</name>" in result

      def test_empty():
          result = dict_to_xml({}, "empty")
          assert "<empty>" in result
          assert "</empty>" in result

      def test_multiple_keys():
          result = dict_to_xml({"a": "1", "b": "2"}, "root")
          assert "<a>1</a>" in result
          assert "<b>2</b>" in result


# =============================================================================
# エージェント能力評価問題（Agent-Level Challenges）
# 曖昧な要件、設計判断、エッジケース発見、リファクタリング等
# =============================================================================

# -----------------------------------------------------------------------------
# カテゴリ: 曖昧な要件からの実装（Vague Requirements）
# -----------------------------------------------------------------------------

- id: py_agent_shopping_cart
  lang: python
  prompt: |
    ECサイトのショッピングカート機能を実装してください。
    解説不要。Pythonコードのみ出力してください。

    要件（意図的に曖昧）:
    - カートに商品を追加・削除できる
    - 合計金額を計算できる
    - 割引があればよしなに対応

    ヒント: 実務では要件が曖昧なことが多い。合理的な設計判断をして実装してください。
  tests:
    tests/test_solution.py: |
      from solution import ShoppingCart

      def test_add_item():
          cart = ShoppingCart()
          cart.add_item("apple", price=100, quantity=2)
          assert cart.get_total() == 200

      def test_remove_item():
          cart = ShoppingCart()
          cart.add_item("apple", price=100, quantity=3)
          cart.remove_item("apple", quantity=1)
          assert cart.get_total() == 200

      def test_remove_all():
          cart = ShoppingCart()
          cart.add_item("apple", price=100, quantity=2)
          cart.remove_item("apple")  # 数量指定なしで全削除
          assert cart.get_total() == 0

      def test_percentage_discount():
          cart = ShoppingCart()
          cart.add_item("apple", price=100, quantity=10)
          cart.apply_discount(percent=10)  # 10%オフ
          assert cart.get_total() == 900

      def test_fixed_discount():
          cart = ShoppingCart()
          cart.add_item("apple", price=100, quantity=5)
          cart.apply_discount(amount=50)  # 50円引き
          assert cart.get_total() == 450

      def test_empty_cart():
          cart = ShoppingCart()
          assert cart.get_total() == 0

      def test_item_count():
          cart = ShoppingCart()
          cart.add_item("apple", price=100, quantity=2)
          cart.add_item("banana", price=50, quantity=3)
          assert cart.item_count() == 5


- id: py_agent_password_policy
  lang: python
  prompt: |
    パスワードポリシーチェッカーを実装してください。
    解説不要。Pythonコードのみ出力してください。

    要件（曖昧）:
    - パスワードの強度をチェックする
    - 弱いパスワードは拒否
    - 一般的なセキュリティ要件を考慮

    あなたの知識で適切なポリシーを設計してください。
  tests:
    tests/test_solution.py: |
      from solution import check_password, PasswordStrength

      def test_too_short():
          result = check_password("abc")
          assert result.is_valid is False
          assert "length" in result.reason.lower() or "short" in result.reason.lower()

      def test_no_uppercase():
          result = check_password("password123!")
          assert result.is_valid is False

      def test_no_lowercase():
          result = check_password("PASSWORD123!")
          assert result.is_valid is False

      def test_no_digit():
          result = check_password("PasswordTest!")
          assert result.is_valid is False

      def test_no_special():
          result = check_password("Password123")
          assert result.is_valid is False

      def test_valid_password():
          result = check_password("SecurePass123!")
          assert result.is_valid is True

      def test_common_password():
          # "password" や "123456" のような一般的なパスワードは拒否すべき
          result = check_password("Password1!")
          # password という単語を含む場合は弱いと判断すべき
          assert result.strength != PasswordStrength.STRONG


- id: py_agent_config_loader
  lang: python
  prompt: |
    アプリケーション設定ローダーを実装してください。
    解説不要。Pythonコードのみ出力してください。

    要件（曖昧）:
    - 設定ファイル（JSON/YAML/環境変数）から設定を読み込む
    - デフォルト値のサポート
    - 必須設定のバリデーション

    実務で必要になりそうな機能を適切に設計してください。
  tests:
    tests/test_solution.py: |
      import os
      from solution import ConfigLoader

      def test_load_from_dict():
          loader = ConfigLoader({"db_host": "localhost", "db_port": 5432})
          assert loader.get("db_host") == "localhost"
          assert loader.get("db_port") == 5432

      def test_default_value():
          loader = ConfigLoader({})
          assert loader.get("missing_key", default="default") == "default"

      def test_nested_config():
          loader = ConfigLoader({"database": {"host": "localhost", "port": 5432}})
          assert loader.get("database.host") == "localhost"
          assert loader.get("database.port") == 5432

      def test_env_override():
          os.environ["APP_DB_HOST"] = "production-db"
          loader = ConfigLoader({"db_host": "localhost"}, env_prefix="APP_")
          assert loader.get("db_host") == "production-db"
          del os.environ["APP_DB_HOST"]

      def test_required_validation():
          loader = ConfigLoader({})
          loader.require("api_key")
          try:
              loader.validate()
              assert False, "Should raise error for missing required key"
          except ValueError as e:
              assert "api_key" in str(e)

      def test_type_casting():
          os.environ["APP_PORT"] = "8080"
          loader = ConfigLoader({}, env_prefix="APP_")
          assert loader.get("port", type=int) == 8080
          del os.environ["APP_PORT"]


# -----------------------------------------------------------------------------
# カテゴリ: リファクタリング（Refactoring）
# -----------------------------------------------------------------------------

- id: py_agent_refactor_spaghetti
  lang: python
  prompt: |
    以下のスパゲッティコードをリファクタリングしてください。
    機能は維持しつつ、可読性・保守性を向上させてください。
    解説不要。Pythonコードのみ出力してください。

    元コード:
    ```python
    def process_order(order_data):
        if order_data:
            if "items" in order_data:
                total = 0
                for item in order_data["items"]:
                    if "price" in item and "quantity" in item:
                        if item["quantity"] > 0:
                            total += item["price"] * item["quantity"]
                        else:
                            return {"error": "invalid quantity"}
                    else:
                        return {"error": "missing price or quantity"}
                if "discount" in order_data:
                    if order_data["discount"] > 0 and order_data["discount"] <= 100:
                        total = total * (100 - order_data["discount"]) / 100
                    else:
                        return {"error": "invalid discount"}
                if "tax_rate" in order_data:
                    if order_data["tax_rate"] >= 0:
                        total = total * (1 + order_data["tax_rate"] / 100)
                    else:
                        return {"error": "invalid tax rate"}
                return {"total": round(total, 2), "status": "success"}
            else:
                return {"error": "no items"}
        else:
            return {"error": "no data"}
    ```

    要件:
    - 同じ入出力を維持（テストが通ること）
    - ネストを減らす
    - 早期リターンパターンを使用
    - 適切な関数分割
  tests:
    tests/test_solution.py: |
      from solution import process_order

      def test_basic_order():
          order = {"items": [{"price": 100, "quantity": 2}]}
          result = process_order(order)
          assert result["status"] == "success"
          assert result["total"] == 200

      def test_with_discount():
          order = {"items": [{"price": 100, "quantity": 1}], "discount": 10}
          result = process_order(order)
          assert result["total"] == 90

      def test_with_tax():
          order = {"items": [{"price": 100, "quantity": 1}], "tax_rate": 10}
          result = process_order(order)
          assert result["total"] == 110

      def test_empty_data():
          result = process_order(None)
          assert "error" in result

      def test_no_items():
          result = process_order({})
          assert result["error"] == "no items"

      def test_invalid_quantity():
          order = {"items": [{"price": 100, "quantity": -1}]}
          result = process_order(order)
          assert result["error"] == "invalid quantity"

      def test_multiple_items():
          order = {"items": [
              {"price": 100, "quantity": 2},
              {"price": 50, "quantity": 3}
          ]}
          result = process_order(order)
          assert result["total"] == 350


- id: py_agent_refactor_god_class
  lang: python
  prompt: |
    以下の「神クラス」をリファクタリングしてください。
    単一責任の原則に従い、適切にクラスを分割してください。
    解説不要。Pythonコードのみ出力してください。

    元コード:
    ```python
    class UserManager:
        def __init__(self):
            self.users = {}
            self.email_log = []

        def create_user(self, user_id, name, email):
            self.users[user_id] = {"name": name, "email": email, "password": None}

        def set_password(self, user_id, password):
            if len(password) < 8:
                raise ValueError("Password too short")
            import hashlib
            hashed = hashlib.sha256(password.encode()).hexdigest()
            self.users[user_id]["password"] = hashed

        def verify_password(self, user_id, password):
            import hashlib
            hashed = hashlib.sha256(password.encode()).hexdigest()
            return self.users[user_id]["password"] == hashed

        def send_welcome_email(self, user_id):
            email = self.users[user_id]["email"]
            self.email_log.append({"to": email, "subject": "Welcome!", "sent": True})

        def send_password_reset(self, user_id):
            email = self.users[user_id]["email"]
            self.email_log.append({"to": email, "subject": "Password Reset", "sent": True})

        def get_email_history(self, user_id):
            email = self.users[user_id]["email"]
            return [e for e in self.email_log if e["to"] == email]
    ```

    要件:
    - UserRepository: ユーザーの永続化
    - PasswordService: パスワード処理
    - EmailService: メール送信
    - UserManager: これらを統合するファサード
  tests:
    tests/test_solution.py: |
      from solution import UserManager, UserRepository, PasswordService, EmailService

      def test_user_repository():
          repo = UserRepository()
          repo.save("u1", {"name": "Alice", "email": "alice@example.com"})
          user = repo.find("u1")
          assert user["name"] == "Alice"

      def test_password_service():
          svc = PasswordService()
          hashed = svc.hash_password("secretpass")
          assert svc.verify_password("secretpass", hashed) is True
          assert svc.verify_password("wrong", hashed) is False

      def test_password_validation():
          svc = PasswordService()
          try:
              svc.hash_password("short")
              assert False
          except ValueError:
              pass

      def test_email_service():
          svc = EmailService()
          svc.send("test@example.com", "Subject", "Body")
          history = svc.get_history("test@example.com")
          assert len(history) == 1

      def test_user_manager_integration():
          manager = UserManager()
          manager.create_user("u1", "Bob", "bob@example.com")
          manager.set_password("u1", "securepassword")
          assert manager.verify_password("u1", "securepassword") is True
          manager.send_welcome_email("u1")


# -----------------------------------------------------------------------------
# カテゴリ: エッジケース発見（Edge Case Discovery）
# -----------------------------------------------------------------------------

- id: py_agent_date_range
  lang: python
  prompt: |
    日付範囲を扱うユーティリティを実装してください。
    解説不要。Pythonコードのみ出力してください。

    基本要件:
    - DateRange クラス（start, end）
    - 範囲内の日数を計算
    - 2つの範囲の重複を検出

    注意: 日付処理には多くのエッジケースがあります。
    実務で問題になりそうなケースを考慮してください。
  tests:
    tests/test_solution.py: |
      from datetime import date
      from solution import DateRange

      def test_basic_range():
          r = DateRange(date(2024, 1, 1), date(2024, 1, 10))
          assert r.days() == 10  # 両端含む

      def test_single_day():
          r = DateRange(date(2024, 1, 1), date(2024, 1, 1))
          assert r.days() == 1

      def test_invalid_range():
          # end < start は例外
          try:
              DateRange(date(2024, 1, 10), date(2024, 1, 1))
              assert False, "Should raise ValueError"
          except ValueError:
              pass

      def test_overlap_full():
          r1 = DateRange(date(2024, 1, 1), date(2024, 1, 10))
          r2 = DateRange(date(2024, 1, 5), date(2024, 1, 15))
          assert r1.overlaps(r2) is True

      def test_no_overlap():
          r1 = DateRange(date(2024, 1, 1), date(2024, 1, 5))
          r2 = DateRange(date(2024, 1, 10), date(2024, 1, 15))
          assert r1.overlaps(r2) is False

      def test_adjacent_no_overlap():
          # 1/5で終わり、1/6で始まる → 重複なし
          r1 = DateRange(date(2024, 1, 1), date(2024, 1, 5))
          r2 = DateRange(date(2024, 1, 6), date(2024, 1, 10))
          assert r1.overlaps(r2) is False

      def test_touch_boundary():
          # 1/5で両方が境界 → 重複あり
          r1 = DateRange(date(2024, 1, 1), date(2024, 1, 5))
          r2 = DateRange(date(2024, 1, 5), date(2024, 1, 10))
          assert r1.overlaps(r2) is True

      def test_contains():
          r1 = DateRange(date(2024, 1, 1), date(2024, 1, 31))
          assert r1.contains(date(2024, 1, 15)) is True
          assert r1.contains(date(2024, 2, 1)) is False

      def test_year_boundary():
          # 年をまたぐ範囲
          r = DateRange(date(2023, 12, 25), date(2024, 1, 5))
          assert r.days() == 12


- id: py_agent_rate_limiter
  lang: python
  prompt: |
    APIレート制限を実装してください。
    解説不要。Pythonコードのみ出力してください。

    基本要件:
    - 指定された時間窓内のリクエスト数を制限
    - クライアントIDごとに制限

    考慮すべき点:
    - 時間窓の扱い（スライディング/固定）
    - 同時アクセス
    - メモリ効率
  tests:
    tests/test_solution.py: |
      import time
      from solution import RateLimiter

      def test_basic_limit():
          limiter = RateLimiter(max_requests=3, window_seconds=10)
          assert limiter.allow("client1") is True
          assert limiter.allow("client1") is True
          assert limiter.allow("client1") is True
          assert limiter.allow("client1") is False  # 4th request blocked

      def test_different_clients():
          limiter = RateLimiter(max_requests=2, window_seconds=10)
          assert limiter.allow("client1") is True
          assert limiter.allow("client1") is True
          assert limiter.allow("client1") is False
          assert limiter.allow("client2") is True  # different client

      def test_window_reset():
          limiter = RateLimiter(max_requests=2, window_seconds=0.1)
          assert limiter.allow("client1") is True
          assert limiter.allow("client1") is True
          assert limiter.allow("client1") is False
          time.sleep(0.15)  # wait for window to reset
          assert limiter.allow("client1") is True

      def test_remaining():
          limiter = RateLimiter(max_requests=5, window_seconds=10)
          limiter.allow("client1")
          limiter.allow("client1")
          assert limiter.remaining("client1") == 3


# -----------------------------------------------------------------------------
# カテゴリ: セキュリティ考慮（Security Awareness）
# -----------------------------------------------------------------------------

- id: py_agent_secure_token
  lang: python
  prompt: |
    セキュアなトークン生成・検証システムを実装してください。
    解説不要。Pythonコードのみ出力してください。

    要件:
    - ユーザーIDからトークンを生成
    - トークンからユーザーIDを復元・検証
    - 有効期限のサポート

    セキュリティを意識した実装をしてください。
  tests:
    tests/test_solution.py: |
      import time
      from solution import TokenService

      def test_generate_and_verify():
          service = TokenService(secret="my-secret-key")
          token = service.generate("user123")
          result = service.verify(token)
          assert result["user_id"] == "user123"
          assert result["valid"] is True

      def test_invalid_token():
          service = TokenService(secret="my-secret-key")
          result = service.verify("invalid-token")
          assert result["valid"] is False

      def test_tampered_token():
          service = TokenService(secret="my-secret-key")
          token = service.generate("user123")
          # トークンを改ざん
          tampered = token[:-5] + "xxxxx"
          result = service.verify(tampered)
          assert result["valid"] is False

      def test_different_secret():
          service1 = TokenService(secret="secret1")
          service2 = TokenService(secret="secret2")
          token = service1.generate("user123")
          result = service2.verify(token)
          assert result["valid"] is False

      def test_expiration():
          service = TokenService(secret="my-secret", default_ttl=0.1)
          token = service.generate("user123")
          time.sleep(0.15)
          result = service.verify(token)
          assert result["valid"] is False
          assert "expired" in result.get("reason", "").lower()

      def test_token_uniqueness():
          service = TokenService(secret="my-secret")
          token1 = service.generate("user123")
          token2 = service.generate("user123")
          # 同じユーザーでも毎回異なるトークン
          assert token1 != token2


- id: py_agent_input_sanitizer
  lang: python
  prompt: |
    ユーザー入力のサニタイズ機能を実装してください。
    解説不要。Pythonコードのみ出力してください。

    要件:
    - HTML/SQLインジェクション対策
    - XSS対策
    - 危険な文字のエスケープ

    セキュリティベストプラクティスに従ってください。
  tests:
    tests/test_solution.py: |
      from solution import sanitize_html, sanitize_sql, Sanitizer

      def test_html_script_tag():
          result = sanitize_html("<script>alert('xss')</script>")
          assert "<script>" not in result
          assert "alert" not in result or "&" in result

      def test_html_event_handler():
          result = sanitize_html('<img onerror="alert(1)" src="x">')
          assert "onerror" not in result or "onerror=" not in result

      def test_html_preserve_safe():
          result = sanitize_html("Hello <b>World</b>")
          # 安全なタグは保持しても良い
          assert "Hello" in result
          assert "World" in result

      def test_sql_quote_escape():
          result = sanitize_sql("O'Brien")
          assert "'" not in result or "''" in result or "\\'" in result

      def test_sql_semicolon():
          result = sanitize_sql("1; DROP TABLE users;")
          # セミコロンが無害化されている
          assert "DROP TABLE" not in result or result != "1; DROP TABLE users;"

      def test_sanitizer_class():
          s = Sanitizer()
          # 複数のサニタイズを適用
          result = s.sanitize("<script>alert(1)</script>", context="html")
          assert "<script>" not in result

      def test_null_byte():
          result = sanitize_html("test\x00injection")
          assert "\x00" not in result


# -----------------------------------------------------------------------------
# カテゴリ: 複雑なバグ修正（Complex Debugging）
# -----------------------------------------------------------------------------

- id: py_agent_debug_race_condition
  lang: python
  prompt: |
    以下のコードには競合状態のバグがあります。修正してください。
    解説不要。Pythonコードのみ出力してください。

    元コード:
    ```python
    class Counter:
        def __init__(self):
            self.value = 0

        def increment(self):
            current = self.value
            # 何らかの処理（遅延をシミュレート）
            self.value = current + 1

        def get_value(self):
            return self.value
    ```

    要件:
    - スレッドセーフにする
    - 複数スレッドから同時にincrementしても正確にカウント
  tests:
    tests/test_solution.py: |
      import threading
      from solution import Counter

      def test_single_thread():
          counter = Counter()
          for _ in range(100):
              counter.increment()
          assert counter.get_value() == 100

      def test_multi_thread():
          counter = Counter()
          threads = []
          for _ in range(10):
              t = threading.Thread(target=lambda: [counter.increment() for _ in range(100)])
              threads.append(t)
          for t in threads:
              t.start()
          for t in threads:
              t.join()
          assert counter.get_value() == 1000

      def test_decrement():
          counter = Counter()
          counter.increment()
          counter.increment()
          counter.decrement()
          assert counter.get_value() == 1

      def test_reset():
          counter = Counter()
          counter.increment()
          counter.increment()
          counter.reset()
          assert counter.get_value() == 0


- id: py_agent_debug_memory_leak
  lang: python
  prompt: |
    以下のコードにはメモリリークの可能性があります。修正してください。
    解説不要。Pythonコードのみ出力してください。

    元コード:
    ```python
    class EventEmitter:
        _listeners = {}  # クラス変数（問題あり）

        def on(self, event, callback):
            if event not in self._listeners:
                self._listeners[event] = []
            self._listeners[event].append(callback)

        def emit(self, event, *args):
            if event in self._listeners:
                for callback in self._listeners[event]:
                    callback(*args)

        def off(self, event, callback=None):
            if event in self._listeners:
                if callback:
                    self._listeners[event].remove(callback)
                else:
                    del self._listeners[event]
    ```

    問題点:
    - クラス変数でリスナーを共有している
    - インスタンスを破棄してもリスナーが残る
  tests:
    tests/test_solution.py: |
      from solution import EventEmitter

      def test_basic_emit():
          emitter = EventEmitter()
          results = []
          emitter.on("test", lambda x: results.append(x))
          emitter.emit("test", "hello")
          assert results == ["hello"]

      def test_multiple_listeners():
          emitter = EventEmitter()
          results = []
          emitter.on("test", lambda x: results.append(f"a:{x}"))
          emitter.on("test", lambda x: results.append(f"b:{x}"))
          emitter.emit("test", "data")
          assert len(results) == 2

      def test_off_specific():
          emitter = EventEmitter()
          results = []
          handler = lambda x: results.append(x)
          emitter.on("test", handler)
          emitter.off("test", handler)
          emitter.emit("test", "data")
          assert results == []

      def test_instance_isolation():
          # 各インスタンスは独立したリスナーを持つべき
          emitter1 = EventEmitter()
          emitter2 = EventEmitter()
          results1 = []
          results2 = []
          emitter1.on("test", lambda x: results1.append(x))
          emitter2.on("test", lambda x: results2.append(x))
          emitter1.emit("test", "for1")
          assert results1 == ["for1"]
          assert results2 == []  # emitter2には影響なし

      def test_cleanup():
          emitter = EventEmitter()
          emitter.on("test", lambda x: x)
          emitter.off("test")
          # イベントが登録されていない状態でemitしてもエラーにならない
          emitter.emit("test", "data")


# -----------------------------------------------------------------------------
# カテゴリ: パフォーマンス最適化（Performance Optimization）
# -----------------------------------------------------------------------------

- id: py_agent_optimize_search
  lang: python
  prompt: |
    以下の非効率なコードを最適化してください。
    解説不要。Pythonコードのみ出力してください。

    元コード（非効率）:
    ```python
    def find_duplicates(items):
        duplicates = []
        for i, item in enumerate(items):
            for j, other in enumerate(items):
                if i != j and item == other and item not in duplicates:
                    duplicates.append(item)
        return duplicates

    def find_common(list1, list2):
        common = []
        for item in list1:
            for other in list2:
                if item == other and item not in common:
                    common.append(item)
        return common
    ```

    要件:
    - O(n^2) を O(n) に改善
    - 同じ結果を返すこと
  tests:
    tests/test_solution.py: |
      import time
      from solution import find_duplicates, find_common

      def test_find_duplicates_basic():
          result = find_duplicates([1, 2, 3, 2, 4, 3])
          assert set(result) == {2, 3}

      def test_find_duplicates_none():
          result = find_duplicates([1, 2, 3, 4])
          assert result == []

      def test_find_duplicates_all():
          result = find_duplicates([1, 1, 1, 1])
          assert result == [1]

      def test_find_common_basic():
          result = find_common([1, 2, 3], [2, 3, 4])
          assert set(result) == {2, 3}

      def test_find_common_none():
          result = find_common([1, 2], [3, 4])
          assert result == []

      def test_performance_duplicates():
          # 大きなリストでも高速に動作すること
          large_list = list(range(10000)) + list(range(5000))
          start = time.time()
          result = find_duplicates(large_list)
          elapsed = time.time() - start
          assert elapsed < 0.5  # 0.5秒以内
          assert len(result) == 5000

      def test_performance_common():
          list1 = list(range(10000))
          list2 = list(range(5000, 15000))
          start = time.time()
          result = find_common(list1, list2)
          elapsed = time.time() - start
          assert elapsed < 0.5
          assert len(result) == 5000


# -----------------------------------------------------------------------------
# カテゴリ: 実務的なユーティリティ（Practical Utilities）
# -----------------------------------------------------------------------------

- id: py_agent_retry_with_backoff
  lang: python
  prompt: |
    実務で使えるリトライ機能を実装してください。
    解説不要。Pythonコードのみ出力してください。

    要件:
    - 指数バックオフ（exponential backoff）
    - 最大リトライ回数
    - リトライ対象の例外を指定可能
    - ジッター（jitter）でサンダリングヘッド問題を回避

    実務で必要な機能を盛り込んでください。
  tests:
    tests/test_solution.py: |
      import time
      from solution import retry_with_backoff, RetryConfig

      def test_immediate_success():
          call_count = [0]
          @retry_with_backoff(max_retries=3)
          def success():
              call_count[0] += 1
              return "ok"
          assert success() == "ok"
          assert call_count[0] == 1

      def test_retry_then_success():
          call_count = [0]
          @retry_with_backoff(max_retries=3, base_delay=0.01)
          def fail_twice():
              call_count[0] += 1
              if call_count[0] < 3:
                  raise ValueError("fail")
              return "success"
          assert fail_twice() == "success"
          assert call_count[0] == 3

      def test_max_retries_exceeded():
          @retry_with_backoff(max_retries=2, base_delay=0.01)
          def always_fail():
              raise RuntimeError("always fails")
          try:
              always_fail()
              assert False
          except RuntimeError:
              pass

      def test_retry_specific_exception():
          call_count = [0]
          @retry_with_backoff(max_retries=3, retry_on=(ValueError,), base_delay=0.01)
          def fail_with_type_error():
              call_count[0] += 1
              raise TypeError("not retryable")
          try:
              fail_with_type_error()
              assert False
          except TypeError:
              pass
          assert call_count[0] == 1  # no retry

      def test_config_object():
          config = RetryConfig(max_retries=5, base_delay=0.1, max_delay=1.0)
          assert config.max_retries == 5
          assert config.base_delay == 0.1


- id: py_agent_data_pipeline
  lang: python
  prompt: |
    データ処理パイプラインを実装してください。
    解説不要。Pythonコードのみ出力してください。

    要件:
    - 複数の変換ステップをチェーンできる
    - 各ステップはエラーハンドリングできる
    - フィルタリングとマッピングをサポート

    例: Pipeline().filter(条件).map(変換).collect()
  tests:
    tests/test_solution.py: |
      from solution import Pipeline

      def test_basic_map():
          result = Pipeline([1, 2, 3]).map(lambda x: x * 2).collect()
          assert result == [2, 4, 6]

      def test_basic_filter():
          result = Pipeline([1, 2, 3, 4]).filter(lambda x: x % 2 == 0).collect()
          assert result == [2, 4]

      def test_chain():
          result = (Pipeline([1, 2, 3, 4, 5])
                    .filter(lambda x: x > 2)
                    .map(lambda x: x * 10)
                    .collect())
          assert result == [30, 40, 50]

      def test_reduce():
          result = Pipeline([1, 2, 3, 4]).reduce(lambda acc, x: acc + x, 0)
          assert result == 10

      def test_first():
          result = Pipeline([1, 2, 3]).filter(lambda x: x > 1).first()
          assert result == 2

      def test_first_empty():
          result = Pipeline([]).first(default=None)
          assert result is None

      def test_count():
          count = Pipeline([1, 2, 3, 4]).filter(lambda x: x > 2).count()
          assert count == 2

      def test_take():
          result = Pipeline(range(100)).take(5).collect()
          assert result == [0, 1, 2, 3, 4]
