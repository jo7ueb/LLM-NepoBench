import argparse
import json
import os
import re
import shutil
import subprocess
import time
from dataclasses import dataclass
from typing import Any, Dict, List, Optional, Tuple

import pandas as pd
import yaml
from openai import OpenAI


WORKDIR = "./_work"

RUNNER_SERVICE = {
    "python": "py-runner",
    "typescript": "ts-runner",
    "go": "go-runner",
}

SOLUTION_FILENAME = {
    "python": "solution.py",
    "typescript": "solution.ts",
    "go": "solution.go",
}

DEFAULT_BASE_URL = {
    "lmstudio": "http://localhost:1234/v1",
    "openrouter": "https://openrouter.ai/api/v1",
    "openai": "https://api.openai.com/v1",
}


@dataclass
class Problem:
    id: str
    lang: str
    prompt: str
    tests: Dict[str, str]


def parse_args() -> argparse.Namespace:
    p = argparse.ArgumentParser()
    p.add_argument("--provider", required=True, choices=["lmstudio", "openrouter", "openai"])
    p.add_argument("--model", required=True)
    p.add_argument("--base-url", default=None)
    p.add_argument("--api-key", default=None)

    p.add_argument("--langs", default="python,typescript,go", help="comma-separated, e.g. python,go")
    p.add_argument("--runs", type=int, default=3)
    p.add_argument("--temperature", type=float, default=0.1)
    p.add_argument("--max-tokens", type=int, default=16384)
    p.add_argument("--docker-timeout", type=int, default=45, help="seconds for docker test run")
    p.add_argument("--out", default="results.csv")
    return p.parse_args()


def build_client(args: argparse.Namespace) -> OpenAI:
    provider = args.provider.lower()
    base_url = args.base_url or DEFAULT_BASE_URL[provider]

    if provider == "lmstudio":
        # LM Studio ã¯ãƒ€ãƒŸãƒ¼ã‚­ãƒ¼ã§ã‚‚é€šã‚‹ã“ã¨ãŒå¤šã„
        api_key = args.api_key or os.getenv("LMSTUDIO_API_KEY", "lm-studio")
        return OpenAI(base_url=base_url, api_key=api_key)

    if provider == "openrouter":
        api_key = args.api_key or os.getenv("OPENROUTER_API_KEY")
        if not api_key:
            raise RuntimeError("OPENROUTER_API_KEY ãŒæœªè¨­å®šã§ã™ï¼ˆã¾ãŸã¯ --api-key ã‚’æŒ‡å®šã—ã¦ãã ã•ã„ï¼‰")
        return OpenAI(base_url=base_url, api_key=api_key)

    if provider == "openai":
        api_key = args.api_key or os.getenv("OPENAI_API_KEY")
        if not api_key:
            raise RuntimeError("OPENAI_API_KEY ãŒæœªè¨­å®šã§ã™ï¼ˆã¾ãŸã¯ --api-key ã‚’æŒ‡å®šã—ã¦ãã ã•ã„ï¼‰")
        return OpenAI(base_url=base_url, api_key=api_key)

    raise ValueError(f"Unknown provider: {provider}")


_CODE_FENCE_RE = re.compile(r"```(?:[a-zA-Z0-9_+-]*)\n(.*?)```", re.DOTALL)


def extract_code(text: str) -> str:
    """
    ç”Ÿæˆç‰©ã« ``` ãŒå«ã¾ã‚Œã‚‹å ´åˆã¯æœ€åˆã®ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã‚’æ¡ç”¨ã€‚
    ç„¡ã„å ´åˆã¯å…¨æ–‡ã‚’æ¡ç”¨ã€‚
    """
    if not text:
        return ""
    m = _CODE_FENCE_RE.search(text)
    if m:
        return m.group(1).strip() + "\n"
    return text.strip() + "\n"


def reset_workdir() -> None:
    if os.path.exists(WORKDIR):
        try:
            shutil.rmtree(WORKDIR)
        except PermissionError:
            print("PermissionError detected. Attempting to clean up using Docker...")
            try:
                subprocess.run(
                    [
                        "docker", "run", "--rm",
                        "-v", f"{os.path.abspath(WORKDIR)}:/clean_target",
                        "alpine",
                        "sh", "-c", "rm -rf /clean_target/*"
                    ],
                    check=True,
                    capture_output=True
                )
                shutil.rmtree(WORKDIR)
            except Exception as e:
                print(f"Warning: Failed to clean up {WORKDIR} using Docker: {e}")
                raise
    os.makedirs(WORKDIR, exist_ok=True)


def write_files(tree: Dict[str, str]) -> None:
    for relpath, content in tree.items():
        abspath = os.path.join(WORKDIR, relpath)
        os.makedirs(os.path.dirname(abspath), exist_ok=True)
        with open(abspath, "w", encoding="utf-8") as f:
            f.write(content)


def ensure_typescript_test_helpers() -> None:
    """
    TypeScript ã®ãƒ†ã‚¹ãƒˆã‚’ã€Œexportåã®ä¸€è‡´ã€ã§ã¯ãªãã€ŒæŒ¯ã‚‹èˆã„ã€ã§è©•ä¾¡ã—ã‚„ã™ãã™ã‚‹ãŸã‚ã®å…±é€šãƒ˜ãƒ«ãƒ‘ã‚’é…ç½®ã™ã‚‹ã€‚
    å„å•é¡Œã® tests/solution.test.ts ã‹ã‚‰ `./_flex` ã‚’ import ã§ãã‚‹æƒ³å®šã€‚
    """
    helper_path = os.path.join(WORKDIR, "tests", "_flex.ts")
    os.makedirs(os.path.dirname(helper_path), exist_ok=True)
    with open(helper_path, "w", encoding="utf-8") as f:
        f.write(
            """// Auto-generated by bench.py
export type AnyObj = Record<string, any>;

export function pickExport<T = any>(solution: AnyObj, names: string[]): T | undefined {
  for (const name of names) {
    if (name in solution) return solution[name] as T;
  }
  // default export fallback
  if ("default" in solution) return solution.default as T;
  return undefined;
}

export function pickFn(solution: AnyObj, names: string[], probe?: (fn: (...args: any[]) => any) => boolean) {
  const candidates: any[] = [];
  for (const name of names) {
    if (name in solution) candidates.push(solution[name]);
  }
  if ("default" in solution) candidates.push(solution.default);

  for (const c of candidates) {
    if (typeof c !== "function") continue;
    if (probe && !safeBool(() => probe(c))) continue;
    return c as (...args: any[]) => any;
  }

  // æœ€çµ‚æ‰‹æ®µ: ä½•ã‚‰ã‹ã®é–¢æ•°exportãŒ1ã¤ã ã‘ãªã‚‰æ¡ç”¨
  const fns = Object.values(solution).filter((v) => typeof v === "function");
  if (fns.length === 1) return fns[0] as (...args: any[]) => any;
  return undefined;
}

export function pickValue(solution: AnyObj, names: string[], probe?: (v: any) => boolean) {
  const candidates: any[] = [];
  for (const name of names) {
    if (name in solution) candidates.push(solution[name]);
  }
  if ("default" in solution) candidates.push(solution.default);
  for (const c of candidates) {
    if (probe && !safeBool(() => probe(c))) continue;
    return c;
  }
  return undefined;
}

export function makeInstance<T = any>(
  solution: AnyObj,
  ctorNames: string[],
  ctorArgsList: any[][],
  factoryNames: string[] = [],
  factoryArgsList: any[][] = [[]],
): T | undefined {
  // ctor
  for (const name of ctorNames) {
    const C: any = (solution as any)[name];
    if (typeof C !== "function") continue;
    for (const args of ctorArgsList) {
      const inst = safe(() => new C(...args));
      if (inst != null) return inst as T;
    }
  }
  // default as ctor
  if (typeof (solution as any).default === "function") {
    const C: any = (solution as any).default;
    for (const args of ctorArgsList) {
      const inst = safe(() => new C(...args));
      if (inst != null) return inst as T;
    }
  }
  // factory
  for (const name of factoryNames) {
    const fn: any = (solution as any)[name];
    if (typeof fn !== "function") continue;
    for (const args of factoryArgsList) {
      const inst = safe(() => fn(...args));
      if (inst != null) return inst as T;
    }
  }
  return undefined;
}

export function bindAny(obj: any, methods: string[]): ((...args: any[]) => any) | undefined {
  if (!obj) return undefined;
  for (const name of methods) {
    if (typeof obj[name] === "function") {
      return obj[name].bind(obj);
    }
  }
  // If not found by name, try finding any function property if methods has a wildcard "*"
  if (methods.includes("*")) {
     for (const key in obj) {
        if (typeof obj[key] === "function") return obj[key].bind(obj);
     }
  }
  return undefined;
}

export function safe<T>(fn: () => T): T | undefined {
  try { return fn(); } catch { return undefined; }
}
export function safeBool(fn: () => boolean): boolean {
  try { return !!fn(); } catch { return false; }
}

export function findMethod(
  obj: any,
  predicate: (fn: Function, name: string) => boolean
): Function | undefined {
  if (obj == null) return undefined;
  const candidates = new Set<string>();
  let curr = obj;
  while (curr && curr !== Object.prototype) {
    Object.getOwnPropertyNames(curr).forEach((k) => candidates.add(k));
    for (const k in curr) candidates.add(k);
    curr = Object.getPrototypeOf(curr);
  }

  for (const key of candidates) {
    if (key === "constructor") continue;
    try {
      const val = obj[key];
      if (typeof val === "function" && predicate(val, key)) {
        return val.bind(obj);
      }
    } catch {}
  }
  return undefined;
}
"""
        )


def docker_run(service: str, timeout_s: int) -> tuple[int, str]:
    """
    docker compose run --rm <service>
    """
    try:
        p = subprocess.run(
            ["docker", "compose", "run", "--rm", service],
            capture_output=True,
            text=True,
            timeout=timeout_s,
        )
        out = (p.stdout or "") + (p.stderr or "")
        return p.returncode, out
    except subprocess.TimeoutExpired as e:
        out = (e.stdout or "") + (e.stderr or "")
        return 124, f"[TIMEOUT] docker run exceeded {timeout_s}s\n" + out
    except Exception as e:
        return 125, f"[ERROR] docker invocation failed: {e}"


def parse_test_report(lang: str) -> Tuple[int, int, int]:
    """
    ãƒ†ã‚¹ãƒˆãƒ¬ãƒãƒ¼ãƒˆã‚’ãƒ‘ãƒ¼ã‚¹ã—ã¦ (passed, failed, total) ã‚’è¿”ã™ã€‚
    éƒ¨åˆ†ç‚¹è©•ä¾¡ç”¨ã€‚ãƒ¬ãƒãƒ¼ãƒˆãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯ (0, 0, 0) ã‚’è¿”ã™ã€‚
    """
    report_path = os.path.join(WORKDIR, ".report.json")

    if lang == "python" and os.path.exists(report_path):
        try:
            with open(report_path, "r", encoding="utf-8") as f:
                data = json.load(f)
            summary = data.get("summary", {})
            passed = summary.get("passed", 0)
            failed = summary.get("failed", 0)
            error = summary.get("error", 0)
            total = summary.get("total", passed + failed + error)
            return passed, failed + error, total
        except (json.JSONDecodeError, KeyError):
            pass

    if lang == "typescript" and os.path.exists(report_path):
        try:
            with open(report_path, "r", encoding="utf-8") as f:
                data = json.load(f)
            # vitest JSON format: { testResults: [{ assertionResults: [...] }] }
            passed = 0
            failed = 0
            for test_file in data.get("testResults", []):
                for assertion in test_file.get("assertionResults", []):
                    if assertion.get("status") == "passed":
                        passed += 1
                    else:
                        failed += 1
            total = passed + failed
            if total > 0:
                return passed, failed, total
        except (json.JSONDecodeError, KeyError):
            pass

    if lang == "go" and os.path.exists(report_path):
        try:
            with open(report_path, "r", encoding="utf-8") as f:
                # go test -json ã¯å„è¡ŒãŒç‹¬ç«‹ã—ãŸJSONã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
                passed = 0
                failed = 0
                seen_tests = set()
                for line in f:
                    line = line.strip()
                    if not line:
                        continue
                    try:
                        event = json.loads(line)
                        action = event.get("Action")
                        test_name = event.get("Test")
                        # ãƒ†ã‚¹ãƒˆé–¢æ•°å˜ä½ã§ã‚«ã‚¦ãƒ³ãƒˆï¼ˆã‚µãƒ–ãƒ†ã‚¹ãƒˆã¯è¦ªã«å«ã‚ã‚‹ï¼‰
                        if test_name and "/" not in test_name:
                            if action == "pass" and test_name not in seen_tests:
                                passed += 1
                                seen_tests.add(test_name)
                            elif action == "fail" and test_name not in seen_tests:
                                failed += 1
                                seen_tests.add(test_name)
                    except json.JSONDecodeError:
                        continue
                total = passed + failed
                if total > 0:
                    return passed, failed, total
        except IOError:
            pass

    return 0, 0, 0


def calculate_score(rc: int, lang: str) -> Tuple[int, int, int, int]:
    """
    éƒ¨åˆ†ç‚¹ã‚¹ã‚³ã‚¢ã‚’è¨ˆç®—ã™ã‚‹ã€‚
    Returns: (score, passed, failed, total)
    - å…¨ãƒ†ã‚¹ãƒˆé€šé: 100ç‚¹
    - éƒ¨åˆ†é€šé: (passed / total) * 100
    - ãƒ¬ãƒãƒ¼ãƒˆãŒãªã„å ´åˆ: å¾“æ¥ã©ãŠã‚Š0/100
    """
    passed, failed, total = parse_test_report(lang)

    if total > 0:
        # éƒ¨åˆ†ç‚¹è¨ˆç®—
        score = round((passed / total) * 100)
        return score, passed, failed, total

    # å¾“æ¥ã©ãŠã‚Šã®0/100è©•ä¾¡
    if rc == 0:
        return 100, 1, 0, 1
    return 0, 0, 1, 1


def extract_failure_reason(rc: int, log: str, lang: str) -> Tuple[str, str]:
    """
    å¤±æ•—ã®åŸå› ã‚’ç‰¹å®šã™ã‚‹ã€‚
    Returns: (blame, detail)
        blame: "LLM" or "ENV" 
        detail: çŸ­ã„èª¬æ˜
    """
    if rc == 0:
        return "", ""
    
    # ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã¯LLMãŒç„¡é™ãƒ«ãƒ¼ãƒ—ç­‰ã‚’æ›¸ã„ãŸå¯èƒ½æ€§ãŒé«˜ã„
    if rc == 124:
        return "LLM", "ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆç„¡é™ãƒ«ãƒ¼ãƒ—ï¼Ÿï¼‰"
    
    # Dockerè‡ªä½“ã®ã‚¨ãƒ©ãƒ¼ã¯ç’°å¢ƒã®å•é¡Œ
    if rc == 125:
        return "ENV", "Dockerå®Ÿè¡Œã‚¨ãƒ©ãƒ¼"
    
    log_lower = log.lower()
    
    # ç’°å¢ƒå´ã®æ˜ã‚‰ã‹ãªå•é¡Œ
    if "permission denied" in log_lower:
        return "ENV", "æ¨©é™ã‚¨ãƒ©ãƒ¼"
    if "no space left" in log_lower:
        return "ENV", "ãƒ‡ã‚£ã‚¹ã‚¯å®¹é‡ä¸è¶³"
    if "connection refused" in log_lower:
        return "ENV", "æ¥ç¶šæ‹’å¦"
    
    # ãã‚Œä»¥å¤–ã¯ã™ã¹ã¦LLMã®å•é¡Œ
    # rc=2: ã‚³ãƒ¼ãƒ‰å®Ÿè¡Œå‰ã®ã‚¨ãƒ©ãƒ¼
    if rc == 2:
        if "syntaxerror" in log_lower:
            if "unterminated" in log_lower or "eof" in log_lower:
                return "ENV", "max_tokensä¸è¶³ï¼ˆã‚³ãƒ¼ãƒ‰ãŒé€”ä¸­ã§åˆ‡ã‚ŒãŸï¼‰"
            return "LLM", "æ§‹æ–‡ã‚¨ãƒ©ãƒ¼"
        if "importerror" in log_lower or "cannot import" in log_lower:
            match = re.search(r"cannot import name '(\w+)'", log)
            if match:
                return "LLM", f"'{match.group(1)}'ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¦ã„ãªã„"
            return "LLM", "ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆåãŒé•ã†"
        if "modulenotfounderror" in log_lower:
            return "LLM", "å­˜åœ¨ã—ãªã„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’import"
        if "nameerror" in log_lower:
            return "LLM", "æœªå®šç¾©ã®å¤‰æ•°/é–¢æ•°ã‚’ä½¿ç”¨"
        if "typeerror" in log_lower:
            return "LLM", "å‹ã‚¨ãƒ©ãƒ¼"
        if "attributeerror" in log_lower:
            return "LLM", "å­˜åœ¨ã—ãªã„å±æ€§ã‚’å‚ç…§"
        # TypeScript
        if "cannot find module" in log_lower:
            return "LLM", "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒè¦‹ã¤ã‹ã‚‰ãªã„"
        if "is not a function" in log_lower:
            return "LLM", "é–¢æ•°ã‚’exportã—ã¦ã„ãªã„"
        if "is not defined" in log_lower:
            return "LLM", "exportã—ã¦ã„ãªã„"
        if "unexpected token" in log_lower:
            return "LLM", "æ§‹æ–‡ã‚¨ãƒ©ãƒ¼"
        # Go
        if "undefined:" in log_lower:
            return "LLM", "æœªå®šç¾©ã®è­˜åˆ¥å­"
        if "cannot use" in log_lower:
            return "LLM", "å‹ã®ä¸ä¸€è‡´"
        
        return "LLM", "ã‚³ãƒ¼ãƒ‰å®Ÿè¡Œã‚¨ãƒ©ãƒ¼"
    
    # rc=1: ãƒ†ã‚¹ãƒˆå¤±æ•— â†’ LLMã®ãƒ­ã‚¸ãƒƒã‚¯ãŒé–“é•ã£ã¦ã„ã‚‹
    if rc == 1:
        return "LLM", "ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ä¸åˆæ ¼"
    
    return "LLM", f"ä¸æ˜ãªã‚¨ãƒ©ãƒ¼(exit={rc})"


def load_problems(selected_langs: List[str]) -> List[Problem]:
    problems: List[Problem] = []
    for lang in selected_langs:
        path = os.path.join("problems", f"{lang}.yaml")
        if not os.path.exists(path):
            print(f"[WARN] not found: {path} (skip)")
            continue
        with open(path, "r", encoding="utf-8") as f:
            data = yaml.safe_load(f) or []
        for item in data:
            problems.append(
                Problem(
                    id=str(item["id"]),
                    lang=str(item["lang"]).lower(),
                    prompt=str(item["prompt"]),
                    tests=dict(item.get("tests", {})),
                )
            )
    return problems


def main() -> None:
    args = parse_args()
    selected_langs = [s.strip().lower() for s in args.langs.split(",") if s.strip()]
    client = build_client(args)

    problems = load_problems(selected_langs)
    if not problems:
        raise RuntimeError("å•é¡ŒãŒãƒ­ãƒ¼ãƒ‰ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚problems/*.yaml ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚")

    rows: List[Dict[str, Any]] = []

    print(f"Provider: {args.provider}")
    print(f"Base URL: {args.base_url or DEFAULT_BASE_URL[args.provider]}")
    print(f"Model:    {args.model}")
    print(f"Langs:    {selected_langs}")
    print(f"Runs:     {args.runs}")
    print("")

    for prob in problems:
        if prob.lang not in RUNNER_SERVICE:
            print(f"[WARN] unsupported runner for lang={prob.lang}, skip {prob.id}")
            continue

        service = RUNNER_SERVICE[prob.lang]
        sol_name = SOLUTION_FILENAME[prob.lang]

        for run_idx in range(1, args.runs + 1):
            reset_workdir()
            write_files(prob.tests)

            # TypeScript ãƒ†ã‚¹ãƒˆå…±é€šãƒ˜ãƒ«ãƒ‘ï¼ˆtests/_flex.tsï¼‰ã‚’é…ç½®
            if prob.lang == "typescript":
                ensure_typescript_test_helpers()

            # Go ã¯ go.mod ãŒå¿…è¦
            if prob.lang == "go":
                write_files({"go.mod": "module bench\n\ngo 1.22\n"})

            # LLM å‘¼ã³å‡ºã—
            t0 = time.time()
            resp = client.chat.completions.create(
                model=args.model,
                messages=[
                    {"role": "system", "content": f"You are an expert {prob.lang} developer. Output code only. Do NOT use external APIs or LLM libraries. Use only standard library and built-in features. All functions and classes MUST be exported."},
                    {"role": "user", "content": prob.prompt},
                ],
                temperature=args.temperature,
                max_tokens=args.max_tokens,
            )
            t1 = time.time()
            llm_seconds = t1 - t0

            content = resp.choices[0].message.content or ""
            code = extract_code(content)
            
            # Remove bad imports that LLMs tend to hallucinate/add habitually
            bad_imports = ["@anthropic-ai/sdk", "sqlite3"]
            lines = code.splitlines()
            code = "\n".join([line for line in lines if not any(bad in line for bad in bad_imports)]) + "\n"

            # ãƒˆãƒ¼ã‚¯ãƒ³æƒ…å ±ã‚’å–å¾—
            usage = resp.usage
            prompt_tokens = usage.prompt_tokens if usage else 0
            completion_tokens = usage.completion_tokens if usage else 0
            total_tokens = usage.total_tokens if usage else 0
            tokens_per_second = round(completion_tokens / llm_seconds, 2) if llm_seconds > 0 and completion_tokens > 0 else 0
            write_files({sol_name: code})

            # Docker å†…ã§ãƒ†ã‚¹ãƒˆ
            rc, log = docker_run(service, timeout_s=args.docker_timeout)
            score, tests_passed, tests_failed, tests_total = calculate_score(rc, prob.lang)
            # vitest/go test ã¯ã€Œå…¨ãƒ†ã‚¹ãƒˆé€šéãªã®ã« rc!=0ã€ã«ãªã‚‹ã“ã¨ãŒã‚ã‚‹ï¼ˆä¾‹: solution å´ã®å‰¯ä½œç”¨ã§ exitCode ãŒç«‹ã¤ç­‰ï¼‰ã€‚
            # ã“ã“ã§ã¯ã€Œãƒ†ã‚¹ãƒˆãƒ¬ãƒãƒ¼ãƒˆã€ã‚’æœ€å„ªå…ˆã—ã¦ PASS/FAIL ã‚’åˆ¤å®šã™ã‚‹ã€‚
            if tests_total > 0:
                all_passed = (tests_failed == 0)
            else:
                all_passed = (rc == 0)

            rows.append(
                {
                    "problem_id": prob.id,
                    "lang": prob.lang,
                    "run": run_idx,
                    "score": score,
                    "passed": all_passed,
                    "tests_passed": tests_passed,
                    "tests_failed": tests_failed,
                    "tests_total": tests_total,
                    "exit_code": rc,
                    "llm_seconds": round(llm_seconds, 3),
                    "prompt_tokens": prompt_tokens,
                    "completion_tokens": completion_tokens,
                    "total_tokens": total_tokens,
                    "tokens_per_second": tokens_per_second,
                    "docker_timeout_s": args.docker_timeout,
                    "log_head": log[:2000],  # ãƒ­ã‚°é•·æš´èµ°ã‚’é˜²ã
                }
            )

            # çµæœè¡¨ç¤º
            if all_passed:
                print(f"[{prob.lang}] {prob.id} run {run_idx}/{args.runs} -> âœ… PASS score={score}")
            else:
                blame, detail = extract_failure_reason(rc, log, prob.lang)
                if tests_passed > 0:
                    status = f"ğŸ”¶ PARTIAL({tests_passed}/{tests_total})"
                else:
                    status = "âŒ FAIL"
                print(f"[{prob.lang}] {prob.id} run {run_idx}/{args.runs} -> {status} score={score} [{blame}] {detail}")

    df = pd.DataFrame(rows)
    df.to_csv(args.out, index=False, encoding="utf-8")
    print("")
    print(f"Saved: {args.out}")

    # ã‚µãƒãƒªè¡¨ç¤º
    summary = (
        df.groupby(["lang", "problem_id"])
        .agg(
            pass_rate=("passed", "mean"),
            avg_score=("score", "mean"),
            std_score=("score", "std"),
            avg_llm_seconds=("llm_seconds", "mean"),
            avg_tokens_per_sec=("tokens_per_second", "mean"),
        )
        .reset_index()
        .sort_values(["lang", "problem_id"])
    )
    print("\n=== Summary (per problem) ===")
    print(summary.to_string(index=False))

    lang_summary = (
        df.groupby(["lang"])
        .agg(
            pass_rate=("passed", "mean"),
            avg_score=("score", "mean"),
            std_score=("score", "std"),
            avg_llm_seconds=("llm_seconds", "mean"),
            avg_tokens_per_sec=("tokens_per_second", "mean"),
            total_tokens=("total_tokens", "sum"),
        )
        .reset_index()
        .sort_values(["lang"])
    )
    print("\n=== Summary (per language) ===")
    print(lang_summary.to_string(index=False))

    # å…¨ä½“ã‚µãƒãƒª
    overall_tps = df["tokens_per_second"].mean()
    overall_tokens = df["total_tokens"].sum()
    print(f"\n=== Overall ===")
    print(f"Average tokens/sec: {overall_tps:.1f}")
    print(f"Total tokens used:  {overall_tokens}")


if __name__ == "__main__":
    main()
